import { AccessGroupEntryResponse, DecryptedMessageEntryResponse, NewMessageEntryResponse, SubmitTransactionResponse, type TransactionSpendingLimitResponse } from '../backend-types/index.js';
import { AccessGroupPrivateInfo, IdentityState, LoginOptions, StorageProvider, type APIProvider, type IdentityConfiguration, type IdentityDerivePayload, type SubscriberNotification, type TransactionSpendingLimitResponseOptions } from './types.js';
export declare class Identity<T extends StorageProvider> {
    #private;
    /**
     * The configured nodeURI used for any network calls. Making this accessible
     * behind a getter ensures it is read-only and can only be set via the
     * configure call.
     */
    get nodeURI(): string;
    /**
     * The configured transaction spending limit values provided by the initial
     * configure call.  These can be used to determine the default tx limit count
     * to use if a derived key needs to be re-authorized.
     */
    get transactionSpendingLimitOptions(): TransactionSpendingLimitResponse;
    constructor(windowProvider: typeof globalThis, apiProvider: APIProvider);
    /**
     * Configures the identity instance. This should be called before any other
     * method calls, ideally before any app code is run.  The most important
     * configuration options are `spendingLimitOptions` and `appName`.
     * `spendingLimitOptions` is used to determine the default permissions that a
     * user will be asked to approve when logging into an app. `appName` is used
     * to identity derived keys issued by an app.
     *
     * See more about the spending limit options object here
     * https://docs.deso.org/for-developers/backend/blockchain-data/basics/data-types#transactionspendinglimitresponse
     *
     * And See an exhaustive list of transaction types here:
     * https://github.com/deso-protocol/core/blob/a836e4d2e92f59f7570c7a00f82a3107ec80dd02/lib/network.go#L244
     *
     * @example
     * ```typescript
     * import { identity } from '@deso/identity';
     *
     * identity.configure({
     *   spendingLimitOptions: {
     *     // NOTE: this value is in Deso nanos, 1000000000 nanos (or 1e9) = 1 Deso
     *     GlobalDESOLimit: 1 * 1e9 // 1 Deso
     *     // Map of transaction type to the number of times this derived key is
     *     // allowed to perform this operation on behalf of the owner public key
     *     TransactionCountLimitMap: {
     *       BASIC_TRANSFER: 2, // 2 basic transfer transactions are authorized
     *       SUBMIT_POST: 'UNLIMITED', // unlimited submit post transactions are authorized
     *     },
     *   }
     * });
     * ```
     */
    configure({ identityURI, network, nodeURI, spendingLimitOptions, redirectURI, jwtAlgorithm, appName, storageProvider, identityPresenter, showSkip, }: IdentityConfiguration): void;
    /**
     * Allows listening to changes to identity state. The subscriber will be
     * called with the new state any time a user logs in, logs out, approves a
     * derived key, etc. Apps can use this to sync their state with the identity
     * instance such that their application reacts to changes and re-renders
     * accordingly.
     *
     * NOTE: This method could be very chatty. Depending on the needs of your
     * application, you may want to implement some caching or memoization to
     * reduce any unnecessary re-renders or network calls.
     *
     * @example
     * ```typescript
     * identity.subscribe(({ event, currentUser, alternateUsers }) => {
     *   if (event === NOTIFICATION_EVENTS.AUTHORIZE_DERIVED_KEY_START) {
     *     // show a loading indicator while the underlying network call to authorize the derived key is made.
     *   }
     *
     *   if (event === NOTIFICATION_EVENTS.LOGIN_END) {
     *      // do something with currentUser
     *   }
     *
     *   // see and exhaustive list of events here: https://github.com/deso-protocol/deso-workspace/blob/a3c02742a342610bb6af8f2b1396d5430931cf41/libs/identity/src/lib/types.ts#L182
     * });
     * ```
     *
     * @param subscriber this is a callback that will be called with the current
     * state and the event that triggered the change.
     */
    subscribe(subscriber: (notification: SubscriberNotification) => void): Promise<void>;
    /**
     * Remove a subscriber so it no longer gets called when identity state changes.
     */
    unsubscribe(subscriber: (notification: SubscriberNotification) => void): void;
    /**
     * Returns the current underlying state of the identity instance. In general,
     * you should use the `subscribe` method to listen to changes to observe and
     * react to the state over time, but if you need a snapshot of the current
     * state you can use this method. Can be useful for debugging or setting up
     * initial state in your app.
     */
    snapshot(): T extends Storage ? IdentityState : Promise<IdentityState>;
    /**
     * Starts a login flow. This will open a new window and prompt the user to
     * select an existing account or create a new account. If there is an error
     * during the login flow, the promise will reject with an error which you can
     * catch and handle in your app by showing some error feedback in the UI.
     *
     * @example
     * ```typescript
     * import { identity, ERROR_TYPES } from '@deso/identity';
     *
     *
     * await identity.login().catch((err) => {
     *   if (err.type === ERROR_TYPES.NO_MONEY) {
     *     // handle no money error
     *   } else {
     *     // handle other errors
     *   }
     * });
     * ```
     *
     * @returns returns a promise that resolves to the identity login
     * payload, or rejects if there was an error.
     */
    login({ getFreeDeso, derivedKeyLogin, }?: LoginOptions): Promise<IdentityDerivePayload>;
    /**
     * @param ownerSeedHex This is the seed hex of the owner key. This must be provided by the app.
     * @param options.derivedSeedHex This is optional and primarily only used for testing. If not provided, a new random derived key will be generated.
     */
    loginWithAutoDerive(ownerSeedHex: string, { derivedSeedHex }?: {
        derivedSeedHex?: string;
    }): Promise<IdentityDerivePayload>;
    /**
     * Starts a logout flow. This will open a new window and prompt the user to
     * confirm they want to logout. Similar to the login flow, if there is an error
     * the returned promise will reject with an error which you can catch and handle.
     *
     * @example
     * ```typescript
     * import { identity } from '@deso/identity';
     *
     *
     * await identity.logout().catch((err) => {
     *   // handle errors
     * });
     * ```
     *
     * @returns returns a promise that resolves to undefined, or rejects if there
     * was an error.
     */
    logout(): Promise<undefined>;
    /**
     * Signs a transaction hex using the derived key issued to the currently
     * active user when they logged into an application. The `TransactionHex`
     * parameter should come from a transaction object returned from a transaction
     * construction endpoint, such as the `submit-post` endpoint of the DeSo
     * backend api.
     *
     * We return a signed transaction hex value that can be used to submit a
     * transaction to the network for confirmation. This method is used internally
     * by the signAndSubmit method, which is a convenience method to sign and
     * submit a transaction in a single step. It can also be used as a standalone
     * method if you want to sign a transaction and submit it yourself.
     *
     *
     * @example
     * ```typescript
     * const signedTxHex = await identity.signTx(txHex);
     * ```
     */
    signTx(TransactionHex: string): Promise<string>;
    /**
     * Submits a signed transaction to the network for confirmation. NOTE: you
     * must sign a transaction before submitting it. This method is used
     * internally by the `signAndSubmit` method, which is a convenience method to
     * sign and submit a transaction in a single step.
     *
     * @example
     * ```typescript
     * const submittedTx = await identity.submitTx(signedTxHex);
     * ```
     */
    submitTx(TransactionHex: string): Promise<any>;
    /**
     * This is a convenience method to sign and submit a transaction in a single
     * step. It receives a transaction object and signs it using the derived key
     * issued to the currently logged in user. This can be chained with
     * transaction construction promises that return a transaction object such as
     * a promise that wraps the call to the `submit-post` endpoint of the DeSo
     * backend api.
     *
     * @example
     * ```typescript
     * const transactionObject = await myApiClient.post('https://node.deso.org/api/v0/submit-post', { ...data });
     *
     * await identity.signAndSubmit(transactionObject);
     * ```
     */
    signAndSubmit(tx: {
        TransactionHex: string;
    }): Promise<SubmitTransactionResponse>;
    /**
     * @deprecated Use signAndSubmit instead. Since we don't support unauthorized
     * keys anymore, this is no longer necessary. It's only purpose was to
     * authorize a derived key if it wasn't already authorized and retry the
     * transaction.
     *
     * @param constructTx generic function for constructing a transaction. Should
     * return a promise that resolves to a transaction object.
     * @returns
     */
    signAndSubmitTx(constructTx: () => Promise<{
        TransactionHex: string;
    }>): Promise<any>;
    /**
     * Encrypt an arbitrary string using the recipient's
     * public key.
     *
     * @example
     * ```typescript
     * const message = "Hi, this is my first encrypted message!";
     *
     * const cipherText = await identity.encryptMessage(
     *   recipientPublicKeyBase58Check,
     *   message
     * );
     * ```
     */
    encryptMessage(recipientPublicKeyBase58Check: string, messagePlainText: string): Promise<string>;
    /**
     * @param message This is a message object returned any of the messages
     * endpoints of the DeSo backend api, could be a DM or a Group message.
     * @param groups This is an array of group chats the user belongs to. This is
     * required to decrypt group messages.
     * @returns
     */
    decryptMessage(message: NewMessageEntryResponse, groups: AccessGroupEntryResponse[]): Promise<DecryptedMessageEntryResponse>;
    /**
     * Decrypts the encrypted access group private key that we will need to use to decrypt group messages.
     *
     * @param encryptedKeyHex
     * @returns returns a promise that resolves t the decrypted key pair.
     */
    decryptAccessGroupKeyPair(encryptedKeyHex: string): Promise<import("./types.js").KeyPair>;
    /**
     * Generate a key pair for an access group. This is used to encrypt and
     * decrypt group messages.
     *
     * @param groupName the plaintext name of the group chat
     * @param options.messagingPrivateKey the optional messaging private key
     * @returns a promise that resolves to the new key info.
     */
    accessGroupStandardDerivation(groupName: string): Promise<AccessGroupPrivateInfo>;
    /**
     * Get a jwt token signed by the derived key issued to the currently active user. This can be used to pass to
     * authenticated endpoints on the DeSo backend api or to create authenticated endpoints on your own backend.
     * Typically this will be used to construct an Authorization header or pass as a parameter in a post body.
     *
     * @example
     * ```typescript
     * const token = await identity.jwt();
     *
     * const authHeaders = {
     *   Authorization: `Bearer ${token}`,
     * }
     *
     * myApiClient.post('https://myapi.com/some-authenticated-endpoint', { ...data }, { headers: authHeaders });
     * ```
     */
    jwt(): Promise<string>;
    /**
     * This method will open a new identity window with a options for getting deso
     * by verifying a phone number or buying/transferring deso anonymously for the
     * currently logged in user. NOTE: A user must already be logged in to use
     * this method.
     *
     * @example
     * ```typescript
     * await identity.getDeso();
     * ```
     */
    getDeso(): Promise<unknown>;
    /**
     * This method is very similar to getDeso, but it will only present the option
     * for verifying a phone number to get deso. Also requires a user to be logged in.
     *
     * @example
     * ```typescript
     * await identity.verifyPhoneNumber();
     * ```
     */
    verifyPhoneNumber(): Promise<unknown>;
    /**
     * This method will set the currently active user. This is useful for changing
     * accounts when a user has logged into an application with multiple accounts.
     * NOTE: This method will not trigger a login event, but, rather, it will do a
     * lookup on all the users that have already been logged in to find the user
     * with the matching public key.  If the key is not found, it will throw an
     * error. The users that are available to be set as active are provided via
     * the `alternateUsers` property on the state object.
     *
     * @example
     * ```typescript
     * identity.setActiveUser(someLoggedInPublicKey);
     * ```
     */
    setActiveUser(publicKey: string): T extends Storage ? void : Promise<void>;
    /**
     * Reloads the derived key permissions for the active user. NOTE: In general
     * consumers should not need to call this directly, but it is exposed for
     * advanced use cases. We call this internally any time derived key
     * permissions are updated, a transaction is submitted, or the logged in user
     * changes.
     * @returns void
     */
    refreshDerivedKeyPermissions(): Promise<void>;
    /**
     * Use this in a browser context where localStorage is used as the storage
     * provider, and it is necessary to check permissions synchronously to prevent
     * issues with pop up blockers. If a user's derived key has the permissions to
     * perform a given action or batch of actions. The permissions are passed in
     * as an object with the same shape as the
     * `TransactionSpendingLimitResponseOptions` type, which is the same as the
     * `spendingLimitOptions` passed to the configure method.
     *
     *
     * @example
     * Here we check if the user has the permissions to submit at least 1 post.
     *
     * ```typescript
     * const hasPermissions = identity.hasPermissions({
     *   TransactionCountLimitMap: {
     *     SUBMIT_POST: 1,
     *    },
     * });
     * ```
     */
    hasPermissions(permissionsToCheck: Partial<TransactionSpendingLimitResponseOptions>): T extends Storage ? boolean : Promise<boolean>;
    /**
     * This method will request permissions from the user to perform an action or
     * batch of actions. It will open an identity window and prompt the user to
     * approve the permissions requested. It also takes a
     * `TransactionSpendingLimitResponseOptions` object.
     *
     * @example
     *
     * ```typescript
     * await identity.requestPermissions({
     *   TransactionCountLimitMap: {
     *     SUBMIT_POST: 'UNLIMITED',
     *    },
     * });
     * ```
     */
    requestPermissions(transactionSpendingLimitResponse: Partial<TransactionSpendingLimitResponseOptions>): Promise<IdentityDerivePayload>;
    /**
     * This method will issue a derive request to identity which can be used to
     * either create a new derived key or to update an existing derived key.  It
     * will open an identity window and prompt the user to approve the action for
     * the derived key. It optionally take an existing derived key and/or an owner
     * public key. If the owner key is not provided, the user will first be asked
     * to login or create an account. Otherwise the user will be prompted with the
     * derived key approval window immediately. If a derived key is not provided,
     * a new one will be created.
     *
     * @example
     *
     * ```typescript
     * await identity.derive({
     *   TransactionCountLimitMap: {
     *     SUBMIT_POST: 'UNLIMITED',
     *    },
     * }, {
     * });
     * ```
     */
    derive(transactionSpendingLimitResponse: Partial<TransactionSpendingLimitResponseOptions>, options?: {
        derivedPublicKey?: string;
        expirationDays?: number;
        deleteKey?: boolean;
        ownerPublicKey?: string;
    }): Promise<IdentityDerivePayload>;
    desoAddressToEthereumAddress(address: string): string;
    ethereumAddressToDesoAddress(address: string): Promise<string>;
    /**
     * Method to handle the redirect URI from the identity service. Typically this
     * would be useful in a mobile context where the user is redirected back to
     * the app after completing the identity flow.
     */
    handleRedirectURI(redirectURI: string): void;
}

import { sha256 } from '@noble/hashes/sha256';
import { Point, sign as ecSign, utils as ecUtils, getPublicKey, getSharedSecret as nobleGetSharedSecret, } from '@noble/secp256k1';
import bs58 from 'bs58';
import { PUBLIC_KEY_PREFIXES } from './constants.js';
import { TransactionV0 } from './transaction-transcoders.js';
// Browser friendly version of node's Buffer.concat.
export function concatUint8Arrays(arrays, length) {
    if (length === undefined) {
        length = arrays.reduce((acc, array) => acc + array.length, 0);
    }
    const result = new Uint8Array(length);
    let offset = 0;
    for (let i = 0; i < arrays.length; i++) {
        if (offset + arrays[i].length > length) {
            result.set(arrays[i].slice(0, length - offset), offset);
            break;
        }
        result.set(arrays[i], offset);
        offset += arrays[i].length;
    }
    return result;
}
export const uvarint64ToBuf = (uint) => {
    const result = [];
    while (uint >= 0x80) {
        result.push(Number((BigInt(uint) & BigInt(0xff)) | BigInt(0x80)));
        uint = Number(BigInt(uint) >> BigInt(7));
    }
    result.push(uint | 0);
    return new Uint8Array(result);
};
export const bufToUvarint64 = (buffer) => {
    let x = BigInt(0);
    let s = BigInt(0);
    // TODO: fix linting error
    // eslint-disable-next-line no-constant-condition
    for (let i = 0; true; i++) {
        const byte = buffer[i];
        if (i > 9 || (i == 9 && byte > 1)) {
            throw new Error('uint64 overflow');
        }
        if (byte < 0x80) {
            return [
                Number(BigInt(x) | (BigInt(byte) << BigInt(s))),
                buffer.slice(i + 1),
            ];
        }
        x |= BigInt(byte & 0x7f) << BigInt(s);
        s += BigInt(7);
    }
};
export const uint64ToBufBigEndian = (uint) => {
    const result = [];
    while (BigInt(uint) >= BigInt(0xff)) {
        result.push(Number(BigInt(uint) & BigInt(0xff)));
        uint = Number(BigInt(uint) >> BigInt(8));
    }
    result.push(Number(BigInt(uint) | BigInt(0)));
    while (result.length < 8) {
        result.push(0);
    }
    return new Uint8Array(result.reverse());
};
// We are not using the native web crypto API to actually generate keys
// because it does not support the secp256k1 curve. Instead, we are using
// https://github.com/paulmillr/noble-secp256k1 which is a browser friendly
// alternative to the node elliptic package which is far smaller and only
// focuses on supporting the ec algorithm we are actually interested in here.
// If the web crypto API ever adds support for secp256k1, we should change
// this to use it.
//
// See the following for more info:
// https://github.com/w3c/webcrypto/issues/82
//
// If you don't provide a seed, a random one will be generated for you and a
// random key pair will be returned. If you do provide a seed, it should be a
// randomly generated 32 byte value (Uint8Array of length 32 or hex string of
// length 64)
export const keygen = (seed) => {
    const privateKey = seed ? normalizeSeed(seed) : ecUtils.randomBytes(32);
    const seedHex = ecUtils.bytesToHex(privateKey);
    return {
        seedHex,
        private: privateKey,
        public: getPublicKey(privateKey, true /* isCompressed */),
    };
};
const normalizeSeed = (seed) => {
    if (typeof seed === 'string') {
        return ecUtils.hexToBytes(seed);
    }
    else {
        return seed;
    }
};
/**
 *
 * @param data could be a hex string or a byte array (Uint8Array)
 * @returns
 */
export const sha256X2 = (data) => {
    const d = typeof data === 'string' ? ecUtils.hexToBytes(data) : data;
    return sha256(sha256(d));
};
export const publicKeyToBase58Check = (publicKeyBytes, options) => {
    const prefix = PUBLIC_KEY_PREFIXES[options?.network ?? 'mainnet'].deso;
    // This is the same as the implementation in the bs58check package, but we
    // slightly modify it to use the browser friendly version of Buffer.concat.
    // See: https://github.com/bitcoinjs/bs58check/blob/12b3e700f355c5c49d0be3f8fc29be6c66e753e9/base.js#L1
    const bytes = new Uint8Array([...prefix, ...publicKeyBytes]);
    const checksum = sha256X2(bytes);
    return bs58.encode(concatUint8Arrays([bytes, checksum], bytes.length + 4));
};
export const sign = (msgHashHex, privateKey) => {
    return ecSign(msgHashHex, privateKey, {
        // For details about the signing options see: https://github.com/paulmillr/noble-secp256k1#signmsghash-privatekey
        canonical: true,
        der: true,
        extraEntropy: true,
        recovered: true,
    });
};
export const signTx = async (txHex, seedHex, options) => {
    const transactionBytes = ecUtils.hexToBytes(txHex);
    const [_, v1FieldsBuffer] = TransactionV0.fromBytes(transactionBytes);
    const signatureIndex = transactionBytes.length - v1FieldsBuffer.length - 1;
    const v0FieldsWithoutSignature = transactionBytes.slice(0, signatureIndex);
    const hashedTxBytes = sha256X2(transactionBytes);
    const transactionHashHex = ecUtils.bytesToHex(hashedTxBytes);
    const privateKey = ecUtils.hexToBytes(seedHex);
    const [signatureBytes, recoveryParam] = await sign(transactionHashHex, privateKey);
    const signatureLength = uvarint64ToBuf(signatureBytes.length);
    if (options?.isDerivedKey) {
        signatureBytes[0] += 1 + recoveryParam;
    }
    const signedTransactionBytes = ecUtils.concatBytes(v0FieldsWithoutSignature, signatureLength, signatureBytes, v1FieldsBuffer);
    return ecUtils.bytesToHex(signedTransactionBytes);
};
export const getSignedJWT = async (seedHex, alg, { derivedPublicKeyBase58Check, 
// TODO: actually support this... or remove it.
expiration, }) => {
    const header = JSON.stringify({ alg, typ: 'JWT' });
    const issuedAt = Math.floor(Date.now() / 1000);
    const thirtyMinFromNow = issuedAt + 30 * 60;
    const payload = JSON.stringify({
        ...(derivedPublicKeyBase58Check ? { derivedPublicKeyBase58Check } : {}),
        iat: issuedAt,
        exp: thirtyMinFromNow,
    });
    const jwt = `${urlSafeBase64(header)}.${urlSafeBase64(payload)}`;
    const [signature] = await sign(ecUtils.bytesToHex(sha256(new Uint8Array(new TextEncoder().encode(jwt)))), ecUtils.hexToBytes(seedHex));
    const encodedSignature = derToJoseEncoding(signature);
    return `${jwt}.${encodedSignature}`;
};
function urlSafeBase64(str) {
    return window
        .btoa(str)
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=/g, '');
}
export const encryptChatMessage = (senderSeedHex, recipientPublicKeyBase58Check, message) => {
    const privateKey = ecUtils.hexToBytes(senderSeedHex);
    const recipientPublicKey = bs58PublicKeyToBytes(recipientPublicKeyBase58Check);
    const sharedPrivateKey = getSharedPrivateKey(privateKey, recipientPublicKey);
    const sharedPublicKey = getPublicKey(sharedPrivateKey);
    return encrypt(sharedPublicKey, message);
};
/**
 * @param publicEncryptionKey could be in raw bytes or base58check format
 * @param plaintext
 * @returns cipher text as a hex string
 */
export const encrypt = async (publicKey, plaintext) => {
    const ephemPrivateKey = ecUtils.randomBytes(32);
    const ephemPublicKey = getPublicKey(ephemPrivateKey);
    const publicKeyBytes = typeof publicKey === 'string' ? bs58PublicKeyToBytes(publicKey) : publicKey;
    const privKey = getSharedPrivateKey(ephemPrivateKey, publicKeyBytes);
    const encryptionKey = privKey.slice(0, 16);
    const iv = ecUtils.randomBytes(16);
    const macKey = sha256(privKey.slice(16));
    const bytes = new TextEncoder().encode(plaintext);
    const cryptoKey = await globalThis.crypto.subtle.importKey('raw', encryptionKey, 'AES-CTR', true, ['encrypt']);
    const cipherBytes = await globalThis.crypto.subtle.encrypt({
        name: 'AES-CTR',
        counter: iv,
        length: 128,
    }, cryptoKey, bytes);
    const hmac = await ecUtils.hmacSha256(macKey, new Uint8Array([...iv, ...new Uint8Array(cipherBytes)]));
    return ecUtils.bytesToHex(new Uint8Array([
        ...ephemPublicKey,
        ...iv,
        ...new Uint8Array(cipherBytes),
        ...hmac,
    ]));
};
export const bs58PublicKeyToCompressedBytes = (str) => {
    if (!str) {
        return new Uint8Array(33);
    }
    const pubKeyUncompressed = bs58PublicKeyToBytes(str);
    return Point.fromHex(ecUtils.bytesToHex(pubKeyUncompressed)).toRawBytes(true);
};
export const bs58PublicKeyToBytes = (str) => {
    const bytes = bs58.decode(str);
    const payload = bytes.slice(0, -4);
    const checksumA = bytes.slice(-4);
    const checksumB = sha256X2(payload);
    if ((checksumA[0] ^ checksumB[0]) |
        (checksumA[1] ^ checksumB[1]) |
        (checksumA[2] ^ checksumB[2]) |
        (checksumA[3] ^ checksumB[3])) {
        throw new Error('Invalid checksum');
    }
    return Point.fromHex(ecUtils.bytesToHex(payload.slice(3))).toRawBytes(false);
};
const regexMainnet = /^BC[1-9A-HJ-NP-Za-km-z]{53}$/;
const regexTestnet = /^tBC[1-9A-HJ-NP-Za-km-z]{51}$/;
export const isValidBS58PublicKey = (publicKey, isTestnet = false) => {
    const regexPattern = isTestnet ? regexTestnet : regexMainnet;
    if (!regexPattern.test(publicKey)) {
        return false;
    }
    try {
        bs58PublicKeyToBytes(publicKey);
        return true;
    }
    catch (e) {
        return false;
    }
};
const isValidHmac = (candidate, knownGood) => {
    if (candidate.length !== knownGood.length) {
        return false;
    }
    for (let i = 0; i < knownGood.length; i++) {
        if (candidate[i] !== knownGood[i]) {
            return false;
        }
    }
    return true;
};
export const decryptChatMessage = async (recipientSeedHex, publicDecryptionKey, cipherTextHex) => {
    const privateKey = ecUtils.hexToBytes(recipientSeedHex);
    const publicKey = await bs58PublicKeyToBytes(publicDecryptionKey);
    const sharedPrivateKey = await getSharedPrivateKey(privateKey, publicKey);
    return decrypt(sharedPrivateKey, cipherTextHex);
};
export const decrypt = async (privateDecryptionKey, cipherTextHex) => {
    const cipherBytes = ecUtils.hexToBytes(cipherTextHex);
    const metaLength = 113;
    if (cipherBytes.length < metaLength) {
        throw new Error('invalid cipher text. data too small.');
    }
    if (!(cipherBytes[0] >= 2 && cipherBytes[0] <= 4)) {
        throw new Error('invalid cipher text.');
    }
    const privateKey = normalizeSeed(privateDecryptionKey);
    const ephemPublicKey = cipherBytes.slice(0, 65);
    const cipherTextLength = cipherBytes.length - metaLength;
    const iv = cipherBytes.slice(65, 65 + 16);
    const cipherAndIv = cipherBytes.slice(65, 65 + 16 + cipherTextLength);
    const cipherText = cipherAndIv.slice(16);
    const msgMac = cipherBytes.slice(65 + 16 + cipherTextLength);
    const sharedSecretKey = await getSharedPrivateKey(privateKey, ephemPublicKey);
    const encryptionKey = sharedSecretKey.slice(0, 16);
    const macKey = sha256(sharedSecretKey.slice(16));
    const hmacKnownGood = await ecUtils.hmacSha256(macKey, cipherAndIv);
    if (!isValidHmac(msgMac, hmacKnownGood)) {
        throw new Error('incorrect MAC');
    }
    const cryptoKey = await globalThis.crypto.subtle.importKey('raw', encryptionKey, 'AES-CTR', true, ['decrypt']);
    const decryptedBuffer = await globalThis.crypto.subtle.decrypt({ name: 'AES-CTR', counter: iv, length: 128 }, cryptoKey, cipherText);
    return new TextDecoder().decode(decryptedBuffer);
};
export const getSharedPrivateKey = (privKey, pubKey) => {
    const sharedSecret = getSharedSecret(privKey, pubKey);
    return kdf(sharedSecret, 32);
};
export const decodePublicKey = async (publicKeyBase58Check) => {
    const decoded = await bs58PublicKeyToBytes(publicKeyBase58Check);
    const withPrefixRemoved = decoded.slice(3);
    const senderPubKeyHex = ecUtils.bytesToHex(withPrefixRemoved);
    return Point.fromHex(senderPubKeyHex).toRawBytes(false);
};
export const getSharedSecret = (privKey, pubKey) => {
    // passing true to compress the public key, and then slicing off the first byte
    // matches the implementation of derive in the elliptic package.
    // https://github.com/paulmillr/noble-secp256k1/issues/28#issuecomment-946538037
    return nobleGetSharedSecret(privKey, pubKey, true).slice(1);
};
// taken from reference implementation in the deso chat app:
// https://github.com/deso-protocol/access-group-messaging-app/blob/cd5c237f5e5729196aac0da161d0851bde78092c/src/services/crypto-utils.service.tsx#L91
export const kdf = (secret, outputLength) => {
    let ctr = 1;
    let written = 0;
    let result = new Uint8Array();
    while (written < outputLength) {
        const hash = sha256(new Uint8Array([
            ...new Uint8Array([ctr >> 24, ctr >> 16, ctr >> 8, ctr]),
            ...secret,
        ]));
        result = new Uint8Array([...result, ...hash]);
        written += 32;
        ctr += 1;
    }
    return result;
};
// This is a modified version of the derToJose function from
// https://github.com/Brightspace/node-ecdsa-sig-formatter/blob/ca25a2fd5ae9dd85036081632936e802a47a1289/src/ecdsa-sig-formatter.js#L32
// The original package is not browser friendly and requires node polyfills. We
// also don't need to be quite as defensive as the original package since we
// have full control of the input.
function derToJoseEncoding(signature) {
    const paramBytes = 32;
    let offset = 3;
    const rLength = signature[offset];
    offset += 1;
    const rOffset = offset;
    offset += rLength + 1;
    const sLength = signature[offset];
    offset += 1;
    const sOffset = offset;
    offset += sLength;
    const rPadding = paramBytes - rLength;
    const sPadding = paramBytes - sLength;
    const outPut = new Uint8Array(rPadding + rLength + sPadding + sLength);
    for (offset = 0; offset < rPadding; ++offset) {
        outPut[offset] = 0;
    }
    outPut.set(signature.slice(rOffset + Math.max(-rPadding, 0), rOffset + rLength), offset);
    offset = paramBytes;
    for (const o = offset; offset < o + sPadding; ++offset) {
        outPut[offset] = 0;
    }
    outPut.set(signature.slice(sOffset + Math.max(-sPadding, 0), sOffset + sLength), offset);
    const outputChars = outPut.reduce((data, byte) => data + String.fromCharCode(byte), '');
    return urlSafeBase64(outputChars);
}
export function deriveAccessGroupKeyPair(privateKeyHex, groupKeyName) {
    const secretHash = sha256X2(privateKeyHex);
    const keyNameHash = sha256X2(new TextEncoder().encode(groupKeyName));
    const privateKey = sha256X2(new Uint8Array([...secretHash, ...keyNameHash]));
    return keygen(privateKey);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J5cHRvLXV0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2lkZW50aXR5L2NyeXB0by11dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDOUMsT0FBTyxFQUNMLEtBQUssRUFDTCxJQUFJLElBQUksTUFBTSxFQUNkLEtBQUssSUFBSSxPQUFPLEVBQ2hCLFlBQVksRUFDWixlQUFlLElBQUksb0JBQW9CLEdBQ3hDLE1BQU0sa0JBQWtCLENBQUM7QUFDMUIsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBQ3hCLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUc3RCxvREFBb0Q7QUFDcEQsTUFBTSxVQUFVLGlCQUFpQixDQUFDLE1BQW9CLEVBQUUsTUFBZTtJQUNyRSxJQUFJLE1BQU0sS0FBSyxTQUFTLEVBQUU7UUFDeEIsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztLQUMvRDtJQUNELE1BQU0sTUFBTSxHQUFHLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3RDLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQztJQUNmLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3RDLElBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsTUFBTSxFQUFFO1lBQ3RDLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUss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QUFDLGFBQWEsQ0FBQyxDQUFDO0lBQzNDLE1BQU0sV0FBVyxHQUFHLFFBQVEsQ0FBQyxJQUFJLFdBQVcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQ3JFLE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLEdBQUcsVUFBVSxFQUFFLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRTdFLE9BQU8sTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQzVCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQge1xuICBQb2ludCxcbiAgc2lnbiBhcyBlY1NpZ24sXG4gIHV0aWxzIGFzIGVjVXRpbHMsXG4gIGdldFB1YmxpY0tleSxcbiAgZ2V0U2hhcmVkU2VjcmV0IGFzIG5vYmxlR2V0U2hhcmVkU2VjcmV0LFxufSBmcm9tICdAbm9ibGUvc2VjcDI1NmsxJztcbmltcG9ydCBiczU4IGZyb20gJ2JzNTgnO1xuaW1wb3J0IHsgUFVCTElDX0tFWV9QUkVGSVhFUyB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uVjAgfSBmcm9tICcuL3RyYW5zYWN0aW9uLXRyYW5zY29kZXJzLmpzJztcbmltcG9ydCB7IEtleVBhaXIsIE5ldHdvcmssIGp3dEFsZ29yaXRobSB9IGZyb20gJy4vdHlwZXMuanMnO1xuXG4vLyBCcm93c2VyIGZyaWVuZGx5IHZlcnNpb24gb2Ygbm9kZSdzIEJ1ZmZlci5jb25jYXQuXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0VWludDhBcnJheXMoYXJyYXlzOiBVaW50OEFycmF5W10sIGxlbmd0aD86IG51bWJlcikge1xuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSBhcnJheXMucmVkdWNlKChhY2MsIGFycmF5KSA9PiBhY2MgKyBhcnJheS5sZW5ndGgsIDApO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChvZmZzZXQgKyBhcnJheXNbaV0ubGVuZ3RoID4gbGVuZ3RoKSB7XG4gICAgICByZXN1bHQuc2V0KGFycmF5c1tpXS5zbGljZSgwLCBsZW5ndGggLSBvZmZzZXQpLCBvZmZzZXQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJlc3VsdC5zZXQoYXJyYXlzW2ldLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBhcnJheXNbaV0ubGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBjb25zdCB1dmFyaW50NjRUb0J1ZiA9ICh1aW50OiBudW1iZXIpOiBVaW50OEFycmF5ID0+IHtcbiAgY29uc3QgcmVzdWx0OiBudW1iZXJbXSA9IFtdO1xuICB3aGlsZSAodWludCA+PSAweDgwKSB7XG4gICAgcmVzdWx0LnB1c2goTnVtYmVyKChCaWdJbnQodWludCkgJiBCaWdJbnQoMHhmZikpIHwgQmlnSW50KDB4ODApKSk7XG4gICAgdWludCA9IE51bWJlcihCaWdJbnQodWludCkgPj4gQmlnSW50KDcpKTtcbiAgfVxuICByZXN1bHQucHVzaCh1aW50IHwgMCk7XG5cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59O1xuXG5leHBvcnQgY29uc3QgYnVmVG9VdmFyaW50NjQgPSAoYnVmZmVyOiBVaW50OEFycmF5KTogW251bWJlciwgVWludDhBcnJheV0gPT4ge1xuICBsZXQgeCA9IEJpZ0ludCgwKTtcbiAgbGV0IHMgPSBCaWdJbnQoMCk7XG5cbiAgLy8gVE9ETzogZml4IGxpbnRpbmcgZXJyb3JcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICBmb3IgKGxldCBpID0gMDsgdHJ1ZTsgaSsrKSB7XG4gICAgY29uc3QgYnl0ZSA9IGJ1ZmZlcltpXTtcblxuICAgIGlmIChpID4gOSB8fCAoaSA9PSA5ICYmIGJ5dGUgPiAxKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1aW50NjQgb3ZlcmZsb3cnKTtcbiAgICB9XG5cbiAgICBpZiAoYnl0ZSA8IDB4ODApIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIE51bWJlcihCaWdJbnQoeCkgfCAoQmlnSW50KGJ5dGUpIDw8IEJpZ0ludChzKSkpLFxuICAgICAgICBidWZmZXIuc2xpY2UoaSArIDEpLFxuICAgICAgXTtcbiAgICB9XG5cbiAgICB4IHw9IEJpZ0ludChieXRlICYgMHg3ZikgPDwgQmlnSW50KHMpO1xuICAgIHMgKz0gQmlnSW50KDcpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdWludDY0VG9CdWZCaWdFbmRpYW4gPSAodWludDogbnVtYmVyKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICB3aGlsZSAoQmlnSW50KHVpbnQpID49IEJpZ0ludCgweGZmKSkge1xuICAgIHJlc3VsdC5wdXNoKE51bWJlcihCaWdJbnQodWludCkgJiBCaWdJbnQoMHhmZikpKTtcbiAgICB1aW50ID0gTnVtYmVyKEJpZ0ludCh1aW50KSA+PiBCaWdJbnQoOCkpO1xuICB9XG4gIHJlc3VsdC5wdXNoKE51bWJlcihCaWdJbnQodWludCkgfCBCaWdJbnQoMCkpKTtcbiAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCA4KSB7XG4gICAgcmVzdWx0LnB1c2goMCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdC5yZXZlcnNlKCkpO1xufTtcblxuaW50ZXJmYWNlIEJhc2U1OENoZWNrT3B0aW9ucyB7XG4gIG5ldHdvcms6IE5ldHdvcms7XG59XG5cbi8vIFdlIGFyZSBub3QgdXNpbmcgdGhlIG5hdGl2ZSB3ZWIgY3J5cHRvIEFQSSB0byBhY3R1YWxseSBnZW5lcmF0ZSBrZXlzXG4vLyBiZWNhdXNlIGl0IGRvZXMgbm90IHN1cHBvcnQgdGhlIHNlY3AyNTZrMSBjdXJ2ZS4gSW5zdGVhZCwgd2UgYXJlIHVzaW5nXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL25vYmxlLXNlY3AyNTZrMSB3aGljaCBpcyBhIGJyb3dzZXIgZnJpZW5kbHlcbi8vIGFsdGVybmF0aXZlIHRvIHRoZSBub2RlIGVsbGlwdGljIHBhY2thZ2Ugd2hpY2ggaXMgZmFyIHNtYWxsZXIgYW5kIG9ubHlcbi8vIGZvY3VzZXMgb24gc3VwcG9ydGluZyB0aGUgZWMgYWxnb3JpdGhtIHdlIGFyZSBhY3R1YWxseSBpbnRlcmVzdGVkIGluIGhlcmUuXG4vLyBJZiB0aGUgd2ViIGNyeXB0byBBUEkgZXZlciBhZGRzIHN1cHBvcnQgZm9yIHNlY3AyNTZrMSwgd2Ugc2hvdWxkIGNoYW5nZVxuLy8gdGhpcyB0byB1c2UgaXQuXG4vL1xuLy8gU2VlIHRoZSBmb2xsb3dpbmcgZm9yIG1vcmUgaW5mbzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvd2ViY3J5cHRvL2lzc3Vlcy84MlxuLy9cbi8vIElmIHlvdSBkb24ndCBwcm92aWRlIGEgc2VlZCwgYSByYW5kb20gb25lIHdpbGwgYmUgZ2VuZXJhdGVkIGZvciB5b3UgYW5kIGFcbi8vIHJhbmRvbSBrZXkgcGFpciB3aWxsIGJlIHJldHVybmVkLiBJZiB5b3UgZG8gcHJvdmlkZSBhIHNlZWQsIGl0IHNob3VsZCBiZSBhXG4vLyByYW5kb21seSBnZW5lcmF0ZWQgMzIgYnl0ZSB2YWx1ZSAoVWludDhBcnJheSBvZiBsZW5ndGggMzIgb3IgaGV4IHN0cmluZyBvZlxuLy8gbGVuZ3RoIDY0KVxuZXhwb3J0IGNvbnN0IGtleWdlbiA9IChzZWVkPzogc3RyaW5nIHwgVWludDhBcnJheSk6IEtleVBhaXIgPT4ge1xuICBjb25zdCBwcml2YXRlS2V5ID0gc2VlZCA/IG5vcm1hbGl6ZVNlZWQoc2VlZCkgOiBlY1V0aWxzLnJhbmRvbUJ5dGVzKDMyKTtcbiAgY29uc3Qgc2VlZEhleCA9IGVjVXRpbHMuYnl0ZXNUb0hleChwcml2YXRlS2V5KTtcblxuICByZXR1cm4ge1xuICAgIHNlZWRIZXgsXG4gICAgcHJpdmF0ZTogcHJpdmF0ZUtleSxcbiAgICBwdWJsaWM6IGdldFB1YmxpY0tleShwcml2YXRlS2V5LCB0cnVlIC8qIGlzQ29tcHJlc3NlZCAqLyksXG4gIH07XG59O1xuXG5jb25zdCBub3JtYWxpemVTZWVkID0gKHNlZWQ6IHN0cmluZyB8IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5ID0+IHtcbiAgaWYgKHR5cGVvZiBzZWVkID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBlY1V0aWxzLmhleFRvQnl0ZXMoc2VlZCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNlZWQ7XG4gIH1cbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBkYXRhIGNvdWxkIGJlIGEgaGV4IHN0cmluZyBvciBhIGJ5dGUgYXJyYXkgKFVpbnQ4QXJyYXkpXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2WDIgPSAoZGF0YTogVWludDhBcnJheSB8IHN0cmluZyk6IFVpbnQ4QXJyYXkgPT4ge1xuICBjb25zdCBkID0gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gZWNVdGlscy5oZXhUb0J5dGVzKGRhdGEpIDogZGF0YTtcbiAgcmV0dXJuIHNoYTI1NihzaGEyNTYoZCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHB1YmxpY0tleVRvQmFzZTU4Q2hlY2sgPSAoXG4gIHB1YmxpY0tleUJ5dGVzOiBVaW50OEFycmF5LFxuICBvcHRpb25zPzogQmFzZTU4Q2hlY2tPcHRpb25zXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBwcmVmaXggPSBQVUJMSUNfS0VZX1BSRUZJWEVTW29wdGlvbnM/Lm5ldHdvcmsgPz8gJ21haW5uZXQnXS5kZXNvO1xuICAvLyBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBpbXBsZW1lbnRhdGlvbiBpbiB0aGUgYnM1OGNoZWNrIHBhY2thZ2UsIGJ1dCB3ZVxuICAvLyBzbGlnaHRseSBtb2RpZnkgaXQgdG8gdXNlIHRoZSBicm93c2VyIGZyaWVuZGx5IHZlcnNpb24gb2YgQnVmZmVyLmNvbmNhdC5cbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbmpzL2JzNThjaGVjay9ibG9iLzEyYjNlNzAwZjM1NWM1YzQ5ZDBiZTNmOGZjMjliZTZjNjZlNzUzZTkvYmFzZS5qcyNMMVxuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFsuLi5wcmVmaXgsIC4uLnB1YmxpY0tleUJ5dGVzXSk7XG4gIGNvbnN0IGNoZWNrc3VtID0gc2hhMjU2WDIoYnl0ZXMpO1xuICByZXR1cm4gYnM1OC5lbmNvZGUoY29uY2F0VWludDhBcnJheXMoW2J5dGVzLCBjaGVja3N1bV0sIGJ5dGVzLmxlbmd0aCArIDQpKTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbk9wdGlvbnMge1xuICBpc0Rlcml2ZWRLZXk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBzaWduID0gKG1zZ0hhc2hIZXg6IHN0cmluZywgcHJpdmF0ZUtleTogVWludDhBcnJheSkgPT4ge1xuICByZXR1cm4gZWNTaWduKG1zZ0hhc2hIZXgsIHByaXZhdGVLZXksIHtcbiAgICAvLyBGb3IgZGV0YWlscyBhYm91dCB0aGUgc2lnbmluZyBvcHRpb25zIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9ub2JsZS1zZWNwMjU2azEjc2lnbm1zZ2hhc2gtcHJpdmF0ZWtleVxuICAgIGNhbm9uaWNhbDogdHJ1ZSxcbiAgICBkZXI6IHRydWUsXG4gICAgZXh0cmFFbnRyb3B5OiB0cnVlLFxuICAgIHJlY292ZXJlZDogdHJ1ZSxcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2lnblR4ID0gYXN5bmMgKFxuICB0eEhleDogc3RyaW5nLFxuICBzZWVkSGV4OiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBTaWduT3B0aW9uc1xuKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgY29uc3QgdHJhbnNhY3Rpb25CeXRlcyA9IGVjVXRpbHMuaGV4VG9CeXRlcyh0eEhleCk7XG4gIGNvbnN0IFtfLCB2MUZpZWxkc0J1ZmZlcl0gPSBUcmFuc2FjdGlvblYwLmZyb21CeXRlcyh0cmFuc2FjdGlvbkJ5dGVzKTtcbiAgY29uc3Qgc2lnbmF0dXJlSW5kZXggPSB0cmFuc2FjdGlvbkJ5dGVzLmxlbmd0aCAtIHYxRmllbGRzQnVmZmVyLmxlbmd0aCAtIDE7XG4gIGNvbnN0IHYwRmllbGRzV2l0aG91dFNpZ25hdHVyZSA9IHRyYW5zYWN0aW9uQnl0ZXMuc2xpY2UoMCwgc2lnbmF0dXJlSW5kZXgpO1xuICBjb25zdCBoYXNoZWRUeEJ5dGVzID0gc2hhMjU2WDIodHJhbnNhY3Rpb25CeXRlcyk7XG4gIGNvbnN0IHRyYW5zYWN0aW9uSGFzaEhleCA9IGVjVXRpbHMuYnl0ZXNUb0hleChoYXNoZWRUeEJ5dGVzKTtcbiAgY29uc3QgcHJpdmF0ZUtleSA9IGVjVXRpbHMuaGV4VG9CeXRlcyhzZWVkSGV4KTtcbiAgY29uc3QgW3NpZ25hdHVyZUJ5dGVzLCByZWNvdmVyeVBhcmFtXSA9IGF3YWl0IHNpZ24oXG4gICAgdHJhbnNhY3Rpb25IYXNoSGV4LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcblxuICBjb25zdCBzaWduYXR1cmVMZW5ndGggPSB1dmFyaW50NjRUb0J1ZihzaWduYXR1cmVCeXRlcy5sZW5ndGgpO1xuXG4gIGlmIChvcHRpb25zPy5pc0Rlcml2ZWRLZXkpIHtcbiAgICBzaWduYXR1cmVCeXRlc1swXSArPSAxICsgcmVjb3ZlcnlQYXJhbTtcbiAgfVxuXG4gIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uQnl0ZXMgPSBlY1V0aWxzLmNvbmNhdEJ5dGVzKFxuICAgIHYwRmllbGRzV2l0aG91dFNpZ25hdHVyZSxcbiAgICBzaWduYXR1cmVMZW5ndGgsXG4gICAgc2lnbmF0dXJlQnl0ZXMsXG4gICAgdjFGaWVsZHNCdWZmZXJcbiAgKTtcblxuICByZXR1cm4gZWNVdGlscy5ieXRlc1RvSGV4KHNpZ25lZFRyYW5zYWN0aW9uQnl0ZXMpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFNpZ25lZEpXVCA9IGFzeW5jIChcbiAgc2VlZEhleDogc3RyaW5nLFxuICBhbGc6IGp3dEFsZ29yaXRobSxcbiAge1xuICAgIGRlcml2ZWRQdWJsaWNLZXlCYXNlNThDaGVjayxcbiAgICAvLyBUT0RPOiBhY3R1YWxseSBzdXBwb3J0IHRoaXMuLi4gb3IgcmVtb3ZlIGl0LlxuICAgIGV4cGlyYXRpb24sXG4gIH06IHtcbiAgICBkZXJpdmVkUHVibGljS2V5QmFzZTU4Q2hlY2s/OiBzdHJpbmc7XG4gICAgZXhwaXJhdGlvbj86IG51bWJlcjtcbiAgfVxuKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgY29uc3QgaGVhZGVyID0gSlNPTi5zdHJpbmdpZnkoeyBhbGcsIHR5cDogJ0pXVCcgfSk7XG4gIGNvbnN0IGlzc3VlZEF0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gIGNvbnN0IHRoaXJ0eU1pbkZyb21Ob3cgPSBpc3N1ZWRBdCArIDMwICogNjA7XG4gIGNvbnN0IHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgLi4uKGRlcml2ZWRQdWJsaWNLZXlCYXNlNThDaGVjayA/IHsgZGVyaXZlZFB1YmxpY0tleUJhc2U1OENoZWNrIH0gOiB7fSksXG4gICAgaWF0OiBpc3N1ZWRBdCxcbiAgICBleHA6IHRoaXJ0eU1pbkZyb21Ob3csXG4gIH0pO1xuXG4gIGNvbnN0IGp3dCA9IGAke3VybFNhZmVCYXNlNjQoaGVhZGVyKX0uJHt1cmxTYWZlQmFzZTY0KHBheWxvYWQpfWA7XG4gIGNvbnN0IFtzaWduYXR1cmVdID0gYXdhaXQgc2lnbihcbiAgICBlY1V0aWxzLmJ5dGVzVG9IZXgoc2hhMjU2KG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShqd3QpKSkpLFxuICAgIGVjVXRpbHMuaGV4VG9CeXRlcyhzZWVkSGV4KVxuICApO1xuICBjb25zdCBlbmNvZGVkU2lnbmF0dXJlID0gZGVyVG9Kb3NlRW5jb2Rpbmcoc2lnbmF0dXJlKTtcblxuICByZXR1cm4gYCR7and0fS4ke2VuY29kZWRTaWduYXR1cmV9YDtcbn07XG5cbmZ1bmN0aW9uIHVybFNhZmVCYXNlNjQoc3RyOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHdpbmRvd1xuICAgIC5idG9hKHN0cilcbiAgICAucmVwbGFjZSgvXFwrL2csICctJylcbiAgICAucmVwbGFjZSgvXFwvL2csICdfJylcbiAgICAucmVwbGFjZSgvPS9nLCAnJyk7XG59XG5cbmV4cG9ydCBjb25zdCBlbmNyeXB0Q2hhdE1lc3NhZ2UgPSAoXG4gIHNlbmRlclNlZWRIZXg6IHN0cmluZyxcbiAgcmVjaXBpZW50UHVibGljS2V5QmFzZTU4Q2hlY2s6IHN0cmluZyxcbiAgbWVzc2FnZTogc3RyaW5nXG4pID0+IHtcbiAgY29uc3QgcHJpdmF0ZUtleSA9IGVjVXRpbHMuaGV4VG9CeXRlcyhzZW5kZXJTZWVkSGV4KTtcbiAgY29uc3QgcmVjaXBpZW50UHVibGljS2V5ID0gYnM1OFB1YmxpY0tleVRvQnl0ZXMoXG4gICAgcmVjaXBpZW50UHVibGljS2V5QmFzZTU4Q2hlY2tcbiAgKTtcbiAgY29uc3Qgc2hhcmVkUHJpdmF0ZUtleSA9IGdldFNoYXJlZFByaXZhdGVLZXkocHJpdmF0ZUtleSwgcmVjaXBpZW50UHVibGljS2V5KTtcbiAgY29uc3Qgc2hhcmVkUHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHNoYXJlZFByaXZhdGVLZXkpO1xuXG4gIHJldHVybiBlbmNyeXB0KHNoYXJlZFB1YmxpY0tleSwgbWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBwdWJsaWNFbmNyeXB0aW9uS2V5IGNvdWxkIGJlIGluIHJhdyBieXRlcyBvciBiYXNlNThjaGVjayBmb3JtYXRcbiAqIEBwYXJhbSBwbGFpbnRleHRcbiAqIEByZXR1cm5zIGNpcGhlciB0ZXh0IGFzIGEgaGV4IHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgZW5jcnlwdCA9IGFzeW5jIChcbiAgcHVibGljS2V5OiBVaW50OEFycmF5IHwgc3RyaW5nLFxuICBwbGFpbnRleHQ6IHN0cmluZ1xuKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgY29uc3QgZXBoZW1Qcml2YXRlS2V5ID0gZWNVdGlscy5yYW5kb21CeXRlcygzMik7XG4gIGNvbnN0IGVwaGVtUHVibGljS2V5ID0gZ2V0UHVibGljS2V5KGVwaGVtUHJpdmF0ZUtleSk7XG4gIGNvbnN0IHB1YmxpY0tleUJ5dGVzID1cbiAgICB0eXBlb2YgcHVibGljS2V5ID09PSAnc3RyaW5nJyA/IGJzNThQdWJsaWNLZXlUb0J5dGVzKHB1YmxpY0tleSkgOiBwdWJsaWNLZXk7XG4gIGNvbnN0IHByaXZLZXkgPSBnZXRTaGFyZWRQcml2YXRlS2V5KGVwaGVtUHJpdmF0ZUtleSwgcHVibGljS2V5Qnl0ZXMpO1xuICBjb25zdCBlbmNyeXB0aW9uS2V5ID0gcHJpdktleS5zbGljZSgwLCAxNik7XG4gIGNvbnN0IGl2ID0gZWNVdGlscy5yYW5kb21CeXRlcygxNik7XG4gIGNvbnN0IG1hY0tleSA9IHNoYTI1Nihwcml2S2V5LnNsaWNlKDE2KSk7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHBsYWludGV4dCk7XG4gIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IGdsb2JhbFRoaXMuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gICAgJ3JhdycsXG4gICAgZW5jcnlwdGlvbktleSxcbiAgICAnQUVTLUNUUicsXG4gICAgdHJ1ZSxcbiAgICBbJ2VuY3J5cHQnXVxuICApO1xuICBjb25zdCBjaXBoZXJCeXRlcyA9IGF3YWl0IGdsb2JhbFRoaXMuY3J5cHRvLnN1YnRsZS5lbmNyeXB0KFxuICAgIHtcbiAgICAgIG5hbWU6ICdBRVMtQ1RSJyxcbiAgICAgIGNvdW50ZXI6IGl2LFxuICAgICAgbGVuZ3RoOiAxMjgsXG4gICAgfSxcbiAgICBjcnlwdG9LZXksXG4gICAgYnl0ZXNcbiAgKTtcbiAgY29uc3QgaG1hYyA9IGF3YWl0IGVjVXRpbHMuaG1hY1NoYTI1NihcbiAgICBtYWNLZXksXG4gICAgbmV3IFVpbnQ4QXJyYXkoWy4uLml2LCAuLi5uZXcgVWludDhBcnJheShjaXBoZXJCeXRlcyldKVxuICApO1xuXG4gIHJldHVybiBlY1V0aWxzLmJ5dGVzVG9IZXgoXG4gICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgLi4uZXBoZW1QdWJsaWNLZXksXG4gICAgICAuLi5pdixcbiAgICAgIC4uLm5ldyBVaW50OEFycmF5KGNpcGhlckJ5dGVzKSxcbiAgICAgIC4uLmhtYWMsXG4gICAgXSlcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBiczU4UHVibGljS2V5VG9Db21wcmVzc2VkQnl0ZXMgPSAoc3RyOiBzdHJpbmcpID0+IHtcbiAgaWYgKCFzdHIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMzMpO1xuICB9XG4gIGNvbnN0IHB1YktleVVuY29tcHJlc3NlZCA9IGJzNThQdWJsaWNLZXlUb0J5dGVzKHN0cik7XG4gIHJldHVybiBQb2ludC5mcm9tSGV4KGVjVXRpbHMuYnl0ZXNUb0hleChwdWJLZXlVbmNvbXByZXNzZWQpKS50b1Jhd0J5dGVzKHRydWUpO1xufTtcblxuZXhwb3J0IGNvbnN0IGJzNThQdWJsaWNLZXlUb0J5dGVzID0gKHN0cjogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGJ5dGVzID0gYnM1OC5kZWNvZGUoc3RyKTtcbiAgY29uc3QgcGF5bG9hZCA9IGJ5dGVzLnNsaWNlKDAsIC00KTtcbiAgY29uc3QgY2hlY2tzdW1BID0gYnl0ZXMuc2xpY2UoLTQpO1xuICBjb25zdCBjaGVja3N1bUIgPSBzaGEyNTZYMihwYXlsb2FkKTtcblxuICBpZiAoXG4gICAgKGNoZWNrc3VtQVswXSBeIGNoZWNrc3VtQlswXSkgfFxuICAgIChjaGVja3N1bUFbMV0gXiBjaGVja3N1bUJbMV0pIHxcbiAgICAoY2hlY2tzdW1BWzJdIF4gY2hlY2tzdW1CWzJdKSB8XG4gICAgKGNoZWNrc3VtQVszXSBeIGNoZWNrc3VtQlszXSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJyk7XG4gIH1cblxuICByZXR1cm4gUG9pbnQuZnJvbUhleChlY1V0aWxzLmJ5dGVzVG9IZXgocGF5bG9hZC5zbGljZSgzKSkpLnRvUmF3Qnl0ZXMoZmFsc2UpO1xufTtcblxuY29uc3QgcmVnZXhNYWlubmV0ID0gL15CQ1sxLTlBLUhKLU5QLVphLWttLXpdezUzfSQvO1xuY29uc3QgcmVnZXhUZXN0bmV0ID0gL150QkNbMS05QS1ISi1OUC1aYS1rbS16XXs1MX0kLztcblxuZXhwb3J0IGNvbnN0IGlzVmFsaWRCUzU4UHVibGljS2V5ID0gKHB1YmxpY0tleTogc3RyaW5nLCBpc1Rlc3RuZXQgPSBmYWxzZSkgPT4ge1xuICBjb25zdCByZWdleFBhdHRlcm4gPSBpc1Rlc3RuZXQgPyByZWdleFRlc3RuZXQgOiByZWdleE1haW5uZXQ7XG4gIGlmICghcmVnZXhQYXR0ZXJuLnRlc3QocHVibGljS2V5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIGJzNThQdWJsaWNLZXlUb0J5dGVzKHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmNvbnN0IGlzVmFsaWRIbWFjID0gKGNhbmRpZGF0ZTogVWludDhBcnJheSwga25vd25Hb29kOiBVaW50OEFycmF5KSA9PiB7XG4gIGlmIChjYW5kaWRhdGUubGVuZ3RoICE9PSBrbm93bkdvb2QubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrbm93bkdvb2QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY2FuZGlkYXRlW2ldICE9PSBrbm93bkdvb2RbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWNyeXB0Q2hhdE1lc3NhZ2UgPSBhc3luYyAoXG4gIHJlY2lwaWVudFNlZWRIZXg6IHN0cmluZyxcbiAgcHVibGljRGVjcnlwdGlvbktleTogc3RyaW5nLFxuICBjaXBoZXJUZXh0SGV4OiBzdHJpbmdcbikgPT4ge1xuICBjb25zdCBwcml2YXRlS2V5ID0gZWNVdGlscy5oZXhUb0J5dGVzKHJlY2lwaWVudFNlZWRIZXgpO1xuICBjb25zdCBwdWJsaWNLZXkgPSBhd2FpdCBiczU4UHVibGljS2V5VG9CeXRlcyhwdWJsaWNEZWNyeXB0aW9uS2V5KTtcbiAgY29uc3Qgc2hhcmVkUHJpdmF0ZUtleSA9IGF3YWl0IGdldFNoYXJlZFByaXZhdGVLZXkocHJpdmF0ZUtleSwgcHVibGljS2V5KTtcbiAgcmV0dXJuIGRlY3J5cHQoc2hhcmVkUHJpdmF0ZUtleSwgY2lwaGVyVGV4dEhleCk7XG59O1xuXG5leHBvcnQgY29uc3QgZGVjcnlwdCA9IGFzeW5jIChcbiAgcHJpdmF0ZURlY3J5cHRpb25LZXk6IFVpbnQ4QXJyYXkgfCBzdHJpbmcsXG4gIGNpcGhlclRleHRIZXg6IHN0cmluZ1xuKSA9PiB7XG4gIGNvbnN0IGNpcGhlckJ5dGVzID0gZWNVdGlscy5oZXhUb0J5dGVzKGNpcGhlclRleHRIZXgpO1xuICBjb25zdCBtZXRhTGVuZ3RoID0gMTEzO1xuXG4gIGlmIChjaXBoZXJCeXRlcy5sZW5ndGggPCBtZXRhTGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNpcGhlciB0ZXh0LiBkYXRhIHRvbyBzbWFsbC4nKTtcbiAgfVxuXG4gIGlmICghKGNpcGhlckJ5dGVzWzBdID49IDIgJiYgY2lwaGVyQnl0ZXNbMF0gPD0gNCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY2lwaGVyIHRleHQuJyk7XG4gIH1cblxuICBjb25zdCBwcml2YXRlS2V5ID0gbm9ybWFsaXplU2VlZChwcml2YXRlRGVjcnlwdGlvbktleSk7XG4gIGNvbnN0IGVwaGVtUHVibGljS2V5ID0gY2lwaGVyQnl0ZXMuc2xpY2UoMCwgNjUpO1xuICBjb25zdCBjaXBoZXJUZXh0TGVuZ3RoID0gY2lwaGVyQnl0ZXMubGVuZ3RoIC0gbWV0YUxlbmd0aDtcbiAgY29uc3QgaXYgPSBjaXBoZXJCeXRlcy5zbGljZSg2NSwgNjUgKyAxNik7XG4gIGNvbnN0IGNpcGhlckFuZEl2ID0gY2lwaGVyQnl0ZXMuc2xpY2UoNjUsIDY1ICsgMTYgKyBjaXBoZXJUZXh0TGVuZ3RoKTtcbiAgY29uc3QgY2lwaGVyVGV4dCA9IGNpcGhlckFuZEl2LnNsaWNlKDE2KTtcbiAgY29uc3QgbXNnTWFjID0gY2lwaGVyQnl0ZXMuc2xpY2UoNjUgKyAxNiArIGNpcGhlclRleHRMZW5ndGgpO1xuICBjb25zdCBzaGFyZWRTZWNyZXRLZXkgPSBhd2FpdCBnZXRTaGFyZWRQcml2YXRlS2V5KHByaXZhdGVLZXksIGVwaGVtUHVibGljS2V5KTtcbiAgY29uc3QgZW5jcnlwdGlvbktleSA9IHNoYXJlZFNlY3JldEtleS5zbGljZSgwLCAxNik7XG4gIGNvbnN0IG1hY0tleSA9IHNoYTI1NihzaGFyZWRTZWNyZXRLZXkuc2xpY2UoMTYpKTtcbiAgY29uc3QgaG1hY0tub3duR29vZCA9IGF3YWl0IGVjVXRpbHMuaG1hY1NoYTI1NihtYWNLZXksIGNpcGhlckFuZEl2KTtcblxuICBpZiAoIWlzVmFsaWRIbWFjKG1zZ01hYywgaG1hY0tub3duR29vZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2luY29ycmVjdCBNQUMnKTtcbiAgfVxuXG4gIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IGdsb2JhbFRoaXMuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gICAgJ3JhdycsXG4gICAgZW5jcnlwdGlvbktleSxcbiAgICAnQUVTLUNUUicsXG4gICAgdHJ1ZSxcbiAgICBbJ2RlY3J5cHQnXVxuICApO1xuXG4gIGNvbnN0IGRlY3J5cHRlZEJ1ZmZlciA9IGF3YWl0IGdsb2JhbFRoaXMuY3J5cHRvLnN1YnRsZS5kZWNyeXB0KFxuICAgIHsgbmFtZTogJ0FFUy1DVFInLCBjb3VudGVyOiBpdiwgbGVuZ3RoOiAxMjggfSxcbiAgICBjcnlwdG9LZXksXG4gICAgY2lwaGVyVGV4dFxuICApO1xuXG4gIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGVjcnlwdGVkQnVmZmVyKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTaGFyZWRQcml2YXRlS2V5ID0gKFxuICBwcml2S2V5OiBVaW50OEFycmF5LFxuICBwdWJLZXk6IFVpbnQ4QXJyYXlcbikgPT4ge1xuICBjb25zdCBzaGFyZWRTZWNyZXQgPSBnZXRTaGFyZWRTZWNyZXQocHJpdktleSwgcHViS2V5KTtcblxuICByZXR1cm4ga2RmKHNoYXJlZFNlY3JldCwgMzIpO1xufTtcblxuZXhwb3J0IGNvbnN0IGRlY29kZVB1YmxpY0tleSA9IGFzeW5jIChwdWJsaWNLZXlCYXNlNThDaGVjazogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGRlY29kZWQgPSBhd2FpdCBiczU4UHVibGljS2V5VG9CeXRlcyhwdWJsaWNLZXlCYXNlNThDaGVjayk7XG4gIGNvbnN0IHdpdGhQcmVmaXhSZW1vdmVkID0gZGVjb2RlZC5zbGljZSgzKTtcbiAgY29uc3Qgc2VuZGVyUHViS2V5SGV4ID0gZWNVdGlscy5ieXRlc1RvSGV4KHdpdGhQcmVmaXhSZW1vdmVkKTtcblxuICByZXR1cm4gUG9pbnQuZnJvbUhleChzZW5kZXJQdWJLZXlIZXgpLnRvUmF3Qnl0ZXMoZmFsc2UpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFNoYXJlZFNlY3JldCA9IChwcml2S2V5OiBVaW50OEFycmF5LCBwdWJLZXk6IFVpbnQ4QXJyYXkpID0+IHtcbiAgLy8gcGFzc2luZyB0cnVlIHRvIGNvbXByZXNzIHRoZSBwdWJsaWMga2V5LCBhbmQgdGhlbiBzbGljaW5nIG9mZiB0aGUgZmlyc3QgYnl0ZVxuICAvLyBtYXRjaGVzIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBkZXJpdmUgaW4gdGhlIGVsbGlwdGljIHBhY2thZ2UuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtc2VjcDI1NmsxL2lzc3Vlcy8yOCNpc3N1ZWNvbW1lbnQtOTQ2NTM4MDM3XG4gIHJldHVybiBub2JsZUdldFNoYXJlZFNlY3JldChwcml2S2V5LCBwdWJLZXksIHRydWUpLnNsaWNlKDEpO1xufTtcblxuLy8gdGFrZW4gZnJvbSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gaW4gdGhlIGRlc28gY2hhdCBhcHA6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGVzby1wcm90b2NvbC9hY2Nlc3MtZ3JvdXAtbWVzc2FnaW5nLWFwcC9ibG9iL2NkNWMyMzdmNWU1NzI5MTk2YWFjMGRhMTYxZDA4NTFiZGU3ODA5MmMvc3JjL3NlcnZpY2VzL2NyeXB0by11dGlscy5zZXJ2aWNlLnRzeCNMOTFcbmV4cG9ydCBjb25zdCBrZGYgPSAoc2VjcmV0OiBVaW50OEFycmF5LCBvdXRwdXRMZW5ndGg6IG51bWJlcikgPT4ge1xuICBsZXQgY3RyID0gMTtcbiAgbGV0IHdyaXR0ZW4gPSAwO1xuICBsZXQgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoKTtcblxuICB3aGlsZSAod3JpdHRlbiA8IG91dHB1dExlbmd0aCkge1xuICAgIGNvbnN0IGhhc2ggPSBzaGEyNTYoXG4gICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgIC4uLm5ldyBVaW50OEFycmF5KFtjdHIgPj4gMjQsIGN0ciA+PiAxNiwgY3RyID4+IDgsIGN0cl0pLFxuICAgICAgICAuLi5zZWNyZXQsXG4gICAgICBdKVxuICAgICk7XG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoWy4uLnJlc3VsdCwgLi4uaGFzaF0pO1xuICAgIHdyaXR0ZW4gKz0gMzI7XG4gICAgY3RyICs9IDE7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gVGhpcyBpcyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIGRlclRvSm9zZSBmdW5jdGlvbiBmcm9tXG4vLyBodHRwczovL2dpdGh1Yi5jb20vQnJpZ2h0c3BhY2Uvbm9kZS1lY2RzYS1zaWctZm9ybWF0dGVyL2Jsb2IvY2EyNWEyZmQ1YWU5ZGQ4NTAzNjA4MTYzMjkzNmU4MDJhNDdhMTI4OS9zcmMvZWNkc2Etc2lnLWZvcm1hdHRlci5qcyNMMzJcbi8vIFRoZSBvcmlnaW5hbCBwYWNrYWdlIGlzIG5vdCBicm93c2VyIGZyaWVuZGx5IGFuZCByZXF1aXJlcyBub2RlIHBvbHlmaWxscy4gV2Vcbi8vIGFsc28gZG9uJ3QgbmVlZCB0byBiZSBxdWl0ZSBhcyBkZWZlbnNpdmUgYXMgdGhlIG9yaWdpbmFsIHBhY2thZ2Ugc2luY2Ugd2Vcbi8vIGhhdmUgZnVsbCBjb250cm9sIG9mIHRoZSBpbnB1dC5cbmZ1bmN0aW9uIGRlclRvSm9zZUVuY29kaW5nKHNpZ25hdHVyZTogVWludDhBcnJheSkge1xuICBjb25zdCBwYXJhbUJ5dGVzID0gMzI7XG5cbiAgbGV0IG9mZnNldCA9IDM7XG4gIGNvbnN0IHJMZW5ndGggPSBzaWduYXR1cmVbb2Zmc2V0XTtcbiAgb2Zmc2V0ICs9IDE7XG4gIGNvbnN0IHJPZmZzZXQgPSBvZmZzZXQ7XG4gIG9mZnNldCArPSByTGVuZ3RoICsgMTtcbiAgY29uc3Qgc0xlbmd0aCA9IHNpZ25hdHVyZVtvZmZzZXRdO1xuICBvZmZzZXQgKz0gMTtcbiAgY29uc3Qgc09mZnNldCA9IG9mZnNldDtcbiAgb2Zmc2V0ICs9IHNMZW5ndGg7XG5cbiAgY29uc3QgclBhZGRpbmcgPSBwYXJhbUJ5dGVzIC0gckxlbmd0aDtcbiAgY29uc3Qgc1BhZGRpbmcgPSBwYXJhbUJ5dGVzIC0gc0xlbmd0aDtcblxuICBjb25zdCBvdXRQdXQgPSBuZXcgVWludDhBcnJheShyUGFkZGluZyArIHJMZW5ndGggKyBzUGFkZGluZyArIHNMZW5ndGgpO1xuXG4gIGZvciAob2Zmc2V0ID0gMDsgb2Zmc2V0IDwgclBhZGRpbmc7ICsrb2Zmc2V0KSB7XG4gICAgb3V0UHV0W29mZnNldF0gPSAwO1xuICB9XG5cbiAgb3V0UHV0LnNldChcbiAgICBzaWduYXR1cmUuc2xpY2Uock9mZnNldCArIE1hdGgubWF4KC1yUGFkZGluZywgMCksIHJPZmZzZXQgKyByTGVuZ3RoKSxcbiAgICBvZmZzZXRcbiAgKTtcblxuICBvZmZzZXQgPSBwYXJhbUJ5dGVzO1xuXG4gIGZvciAoY29uc3QgbyA9IG9mZnNldDsgb2Zmc2V0IDwgbyArIHNQYWRkaW5nOyArK29mZnNldCkge1xuICAgIG91dFB1dFtvZmZzZXRdID0gMDtcbiAgfVxuXG4gIG91dFB1dC5zZXQoXG4gICAgc2lnbmF0dXJlLnNsaWNlKHNPZmZzZXQgKyBNYXRoLm1heCgtc1BhZGRpbmcsIDApLCBzT2Zmc2V0ICsgc0xlbmd0aCksXG4gICAgb2Zmc2V0XG4gICk7XG5cbiAgY29uc3Qgb3V0cHV0Q2hhcnMgPSBvdXRQdXQucmVkdWNlKFxuICAgIChkYXRhLCBieXRlKSA9PiBkYXRhICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSxcbiAgICAnJ1xuICApO1xuXG4gIHJldHVybiB1cmxTYWZlQmFzZTY0KG91dHB1dENoYXJzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZUFjY2Vzc0dyb3VwS2V5UGFpcihcbiAgcHJpdmF0ZUtleUhleDogc3RyaW5nLFxuICBncm91cEtleU5hbWU6IHN0cmluZ1xuKTogS2V5UGFpciB7XG4gIGNvbnN0IHNlY3JldEhhc2ggPSBzaGEyNTZYMihwcml2YXRlS2V5SGV4KTtcbiAgY29uc3Qga2V5TmFtZUhhc2ggPSBzaGEyNTZYMihuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZ3JvdXBLZXlOYW1lKSk7XG4gIGNvbnN0IHByaXZhdGVLZXkgPSBzaGEyNTZYMihuZXcgVWludDhBcnJheShbLi4uc2VjcmV0SGFzaCwgLi4ua2V5TmFtZUhhc2hdKSk7XG5cbiAgcmV0dXJuIGtleWdlbihwcml2YXRlS2V5KTtcbn1cbiJdfQ==
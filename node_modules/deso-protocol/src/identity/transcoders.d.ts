import 'reflect-metadata';
import { TransactionNonce } from './transaction-transcoders.js';
export declare class BinaryRecord {
    static fromBytes(bytes: Uint8Array): [BinaryRecord, Uint8Array];
    toBytes(): Uint8Array;
}
export interface TranscoderMetadata<T = any> {
    name: string;
    transcoder: Transcoder<T>;
}
export declare function Transcode<T>(transcoder: Transcoder<T>): (target: any, name: string | symbol) => void;
export interface Transcoder<T> {
    read: (bytes: Uint8Array) => [T, Uint8Array];
    write: (object: T) => Uint8Array;
}
export interface Serializable {
    toBytes: () => Uint8Array;
}
export interface Deserializable<T> {
    fromBytes: (bytes: Uint8Array) => [T, Uint8Array];
}
export declare const Uvarint64: Transcoder<number>;
export declare const Boolean: Transcoder<boolean>;
export declare const Uint8: Transcoder<number>;
export declare const FixedBuffer: (size: number) => Transcoder<Uint8Array>;
export declare const VarBuffer: Transcoder<Uint8Array>;
export declare const TransactionNonceTranscoder: Transcoder<TransactionNonce | null>;
export declare function Optional<T>(transcoder: Transcoder<T>): Transcoder<T | null>;
export declare const ChunkBuffer: (width: number) => Transcoder<Uint8Array[]>;
export declare const ArrayOf: <T extends Serializable, C extends Deserializable<T> & (new () => T)>(klass: C) => Transcoder<T[]>;
export declare const Record: <T extends Serializable, C extends Deserializable<T> & (new () => T)>(klass: C) => Transcoder<T>;
export declare const instanceToType: <T extends Serializable, C extends Deserializable<T> & (new () => T)>(object: T, klassMap: {
    [index: string]: C;
}) => number;
export declare const Enum: <T extends Serializable, C extends Deserializable<T> & (new () => T)>(klassMap: {
    [index: string]: C;
}) => Transcoder<T>;

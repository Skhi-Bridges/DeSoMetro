import { TransactionMetadataBasicTransfer, TransactionMetadataCreatorCoin, TransactionMetadataCreatorCoinTransfer, TransactionOutput, bs58PublicKeyToCompressedBytes, identity, } from '../identity/index.js';
import { constructBalanceModelTx, getTxWithFeeNanos, handleSignAndSubmit, isMaybeDeSoPublicKey, sumTransactionFees, } from '../internal.js';
import { guardTxPermission } from './utils.js';
/**
 * https://docs.deso.org/deso-backend/construct-transactions/financial-transactions-api#send-deso
 */
export const sendDeso = async (params, options) => {
    const txWithFee = getTxWithFeeNanos(params.SenderPublicKeyBase58Check, new TransactionMetadataBasicTransfer(), {
        Outputs: buildSendDeSoOutputs({
            ...params,
            // NOTE: this is a bit of an odd hack, but bc we are only using this to
            // estimate the fee, we can overwrite the recipient to be the sender to
            // ensure the value is a valid public key that can be converted to
            // bytes. The reason we cannot make an api call to get the true public
            // key is because it could cause the derived key re-approval popup to
            // get blocked by browser popup blockers.
            RecipientPublicKeyOrUsername: params.SenderPublicKeyBase58Check,
        }),
        ExtraData: params.ExtraData,
        MinFeeRateNanosPerKB: params.MinFeeRateNanosPerKB,
        TransactionFees: params.TransactionFees,
    });
    if (options?.checkPermissions !== false) {
        await guardTxPermission({
            GlobalDESOLimit: params.AmountNanos +
                txWithFee.feeNanos +
                sumTransactionFees(params.TransactionFees),
            TransactionCountLimitMap: {
                BASIC_TRANSFER: options?.txLimitCount ??
                    identity.transactionSpendingLimitOptions.TransactionCountLimitMap
                        ?.BASIC_TRANSFER ??
                    1,
            },
        });
    }
    return handleSignAndSubmit('api/v0/send-deso', params, {
        ...options,
        constructionFunction: constructSendDeSoTransaction,
    });
};
const buildSendDeSoOutputs = (params) => {
    const transactionOutput = new TransactionOutput();
    transactionOutput.amountNanos = params.AmountNanos;
    transactionOutput.publicKey = bs58PublicKeyToCompressedBytes(
    // FIXME: this will throw an error if the recipient is a username. We need
    // to either fetch the public key and overwrite the username with it or
    // throw a more helpful error to consumers explaining that we require the
    // public key instead of the username.
    params.RecipientPublicKeyOrUsername);
    return [transactionOutput];
};
export const constructSendDeSoTransaction = (params) => {
    if (!isMaybeDeSoPublicKey(params.RecipientPublicKeyOrUsername)) {
        throw new Error('must provide public key, not user name for local construction');
    }
    return constructBalanceModelTx(params.SenderPublicKeyBase58Check, new TransactionMetadataBasicTransfer(), {
        Outputs: buildSendDeSoOutputs(params),
        ExtraData: params.ExtraData,
        MinFeeRateNanosPerKB: params.MinFeeRateNanosPerKB,
        TransactionFees: params.TransactionFees,
        Nonce: params.Nonce,
    });
};
export const buyCreatorCoin = async (params, options) => {
    const txWithFee = getTxWithFeeNanos(params.UpdaterPublicKeyBase58Check, buildBuyCreatorCoinMetadata(params), {
        ExtraData: params.ExtraData,
        MinFeeRateNanosPerKB: params.MinFeeRateNanosPerKB,
        TransactionFees: params.TransactionFees,
    });
    if (options?.checkPermissions !== false) {
        await guardTxPermission({
            GlobalDESOLimit: params.DeSoToSellNanos +
                txWithFee.feeNanos +
                sumTransactionFees(params.TransactionFees),
            CreatorCoinOperationLimitMap: {
                [params.CreatorPublicKeyBase58Check]: {
                    buy: options?.txLimitCount ?? 1,
                },
            },
        });
    }
    return handleSignAndSubmit('api/v0/buy-or-sell-creator-coin', {
        ...params,
        OperationType: 'buy',
    }, options);
};
export const sellCreatorCoin = async (params, options) => {
    const txWithFee = getTxWithFeeNanos(params.UpdaterPublicKeyBase58Check, buildSellCreatorCoinMetadata(params), {
        ExtraData: params.ExtraData,
        MinFeeRateNanosPerKB: params.MinFeeRateNanosPerKB,
        TransactionFees: params.TransactionFees,
    });
    if (options?.checkPermissions !== false) {
        await guardTxPermission({
            GlobalDESOLimit: txWithFee.feeNanos + sumTransactionFees(params.TransactionFees),
            CreatorCoinOperationLimitMap: {
                [params.CreatorPublicKeyBase58Check]: {
                    sell: options?.txLimitCount ?? 1,
                },
            },
        });
    }
    return handleSignAndSubmit('api/v0/buy-or-sell-creator-coin', {
        ...params,
        OperationType: 'sell',
    }, options);
};
export const transferCreatorCoin = async (params, options) => {
    const txWithFee = getTxWithFeeNanos(params.SenderPublicKeyBase58Check, buildTransferCreatorCoinMetadata(params), {
        ExtraData: params.ExtraData,
        MinFeeRateNanosPerKB: params.MinFeeRateNanosPerKB,
        TransactionFees: params.TransactionFees,
    });
    if (options?.checkPermissions !== false) {
        await guardTxPermission({
            GlobalDESOLimit: txWithFee.feeNanos + sumTransactionFees(params.TransactionFees),
            CreatorCoinOperationLimitMap: {
                [params.CreatorPublicKeyBase58Check]: {
                    transfer: options?.txLimitCount ?? 1,
                },
            },
        });
    }
    return handleSignAndSubmit('api/v0/transfer-creator-coin', params, {
        ...options,
        constructionFunction: constructTransferCreatorCoinTransaction,
    });
};
const buildTransferCreatorCoinMetadata = (params) => {
    const metadata = new TransactionMetadataCreatorCoinTransfer();
    metadata.creatorCoinToTransferNanos = params.CreatorCoinToTransferNanos;
    metadata.profilePublicKey = bs58PublicKeyToCompressedBytes(params.CreatorPublicKeyBase58Check);
    metadata.receiverPublicKey = bs58PublicKeyToCompressedBytes(params.ReceiverUsernameOrPublicKeyBase58Check);
    return metadata;
};
const constructTransferCreatorCoinTransaction = (params) => {
    if (!isMaybeDeSoPublicKey(params.ReceiverUsernameOrPublicKeyBase58Check)) {
        return Promise.reject('must provide public key, not user name for local construction');
    }
    return constructBalanceModelTx(params.SenderPublicKeyBase58Check, buildTransferCreatorCoinMetadata(params), {
        ExtraData: params.ExtraData,
        MinFeeRateNanosPerKB: params.MinFeeRateNanosPerKB,
        TransactionFees: params.TransactionFees,
    });
};
const buildBuyCreatorCoinMetadata = (params) => {
    // NOTE: This is not exactly accurate and gives an upper bound estimate for
    // minCreatorCoinExpectedNanos. It should not but used for actual tx
    // construction, but it is useful for estimating tx fees.
    const metadata = new TransactionMetadataCreatorCoin();
    metadata.profilePublicKey = bs58PublicKeyToCompressedBytes(params.CreatorPublicKeyBase58Check);
    metadata.operationType = 0;
    metadata.desoToSellNanos = params.DeSoToSellNanos;
    metadata.minCreatorCoinExpectedNanos =
        params.MinCreatorCoinExpectedNanos ?? Number.MAX_SAFE_INTEGER;
    return metadata;
};
const buildSellCreatorCoinMetadata = (params) => {
    // NOTE: This is not exactly accurate and gives an upper bound estimate for
    // minDeSoExpectedNanos. It should not but used for actual tx construction,
    // but it is useful for estimating tx fees.
    const metadata = new TransactionMetadataCreatorCoin();
    metadata.profilePublicKey = bs58PublicKeyToCompressedBytes(params.CreatorPublicKeyBase58Check);
    metadata.operationType = 1;
    metadata.creatorCoinToSellNanos = params.CreatorCoinToSellNanos;
    metadata.minDeSoExpectedNanos =
        params.MinDeSoExpectedNanos ?? Number.MAX_SAFE_INTEGER;
    return metadata;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmluYW5jaWFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3RyYW5zYWN0aW9ucy9maW5hbmNpYWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBV0EsT0FBTyxFQUNMLGdDQUFnQyxFQUNoQyw4QkFBOEIsRUFDOUIsc0NBQXNDLEVBQ3RDLGlCQUFpQixFQUNqQiw4QkFBOEIsRUFDOUIsUUFBUSxHQUNULE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsbUJBQW1CLEVBQ25CLG9CQUFvQixFQUNwQixrQkFBa0IsR0FDbkIsTUFBTSxnQkFBZ0IsQ0FBQztBQUV4QixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFFL0M7O0dBRUc7QUFDSCxNQUFNLENBQUMsTUFBTSxRQUFRLEdBQUcsS0FBSyxFQUMzQixNQUE4RCxFQUM5RCxPQUEwQixFQUcxQixFQUFFO0lBQ0YsTUFBTSxTQUFTLEdBQUcsaUJBQWlCLENBQ2pDLE1BQU0sQ0FBQywwQkFBMEIsRUFDakMsSUFBSSxnQ0FBZ0MsRUFBRSxFQUN0QztRQUNFLE9BQU8sRUFBRSxvQkFBb0IsQ0FBQztZQUM1QixHQUFHLE1BQU07WUFDVCx1RUFBdUU7WUFDdkUsdUVBQXVFO1lBQ3ZFLGtFQUFrRTtZQUNsRSxzRUFBc0U7WUFDdEUscUVBQXFFO1lBQ3JFLHlDQUF5QztZQUN6Qyw0QkFBNEIsRUFBRSxNQUFNLENBQUMsMEJBQTBCO1NBQ2hFLENBQUM7UUFDRixTQUFTLEVBQUUsTUFBTSxDQUFDLFNBQVM7UUFDM0Isb0JBQW9CLEVBQUUsTUFBTSxDQUFDLG9CQUFvQjtRQUNqRCxlQUFlLEVBQUUsTUFBTSxDQUFDLGVBQWU7S0FDeEMsQ0FDRixDQUFDO0lBRUYsSUFBSSxPQUFPLEVBQUUsZ0JBQWdCLEtBQUssS0FBSyxFQUFFO1FBQ3ZDLE1BQU0saUJBQWlCLENBQUM7WUFDdEIsZUFBZSxFQUNiLE1BQU0sQ0FBQyxXQUFXO2dCQUNsQixTQUFTLENBQUMsUUFBUTtnQkFDbEIsa0JBQWtCLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQztZQUM1Qyx3QkFBd0IsRUFBRTtnQkFDeEIsY0FBYyxFQUNaLE9BQU8sRUFBRSxZQUFZO29CQUNyQixRQUFRLENBQUMsK0JBQStCLENBQUMsd0JBQXdCO3dCQUMvRCxFQUFFLGNBQWM7b0JBQ2xCLENBQUM7YUFDSjtTQUNGLENBQUMsQ0FBQztLQUNKO0lBRUQsT0FBTyxtQkFBbUIsQ0FBQyxrQkFBa0IsRUFBRSxNQUFNLEVBQUU7UUFDckQsR0FBRyxPQUFPO1FBQ1Ysb0JBQW9CLEVBQUUsNEJBQTRCO0tBQ25ELENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQztBQUVGLE1BQU0sb0JBQW9CLEdBQUcsQ0FDM0IsTUFBOEQsRUFDOUQsRUFBRTtJQUNGLE1BQU0saUJBQWlCLEdBQUcsSUFBSSxpQkFBaUIsRUFBRSxDQUFDO0lBQ2xELGlCQUFpQixDQUFDLFdBQVcsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDO0lBQ25ELGlCQUFpQixDQUFDLFNBQVMsR0FBRyw4QkFBOEI7SUFDMUQsMEVBQTBFO0lBQzFFLHVFQUF1RTtJQUN2RSx5RUFBeUU7SUFDekUsc0NBQXNDO0lBQ3RDLE1BQU0sQ0FBQyw0QkFBNEIsQ0FDcEMsQ0FBQztJQUNGLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBQzdCLENBQUMsQ0FBQztBQUVGLE1BQU0sQ0FBQyxNQUFNLDRCQUE0QixHQUFHLENBQzFDLE1BQThELEVBQ3JCLEVBQUU7SUFDM0MsSUFBSSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyw0QkFBNEIsQ0FBQyxFQUFFO1FBQzlELE1BQU0sSUFBSSxLQUFLLENBQ2IsK0RBQStELENBQ2hFLENBQUM7S0FDSDtJQUVELE9BQU8sdUJBQXVCLENBQzVCLE1BQU0sQ0FBQywwQkFBMEIsRUFDakMsSUFBSSxnQ0FBZ0MsRUFBRSxFQUN0QztRQUNFLE9BQU8sRUFBRSxvQkFBb0IsQ0FBQyxNQUFNLENBQUM7UUFDckMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxTQUFTO1FBQzNCLG9CQUFvQixFQUFFLE1BQU0sQ0FBQyxvQkFBb0I7UUFDakQsZUFBZSxFQUFFLE1BQU0sQ0FBQyxlQUFlO1FBQ3ZDLEtBQUssRUFBRSxNQUFNLENBQUMsS0FBSztLQUNwQixDQUNGLENBQUM7QUFDSixDQUFDLENBQUM7QUFrQkYsTUFBTSxDQUFDLE1BQU0sY0FBYyxHQUFHLEtBQUssRUFDakMsTUFBbUMsRUFDbkMsT0FBMEIsRUFLMUIsRUFBRTtJQUNGLE1BQU0sU0FBUyxHQUFHLGlCQUFpQixDQUNqQyxNQUFNLENBQUMsMkJBQTJCLEVBQ2xDLDJCQUEyQixDQUFDLE1BQU0sQ0FBQyxFQUNuQztRQUNFLFNBQVMsRUFBRSxNQUFNLENBQUMsU0FBUztRQUMzQixvQkFBb0IsRUFBRSxNQUFNLENBQUMsb0JBQW9CO1FBQ2pELGVBQWUsRUFBRSxNQUFNLENBQUMsZUFBZTtLQUN4QyxDQUNGLENBQUM7SUFFRixJQUFJLE9BQU8sRUFBRSxnQkFBZ0IsS0FBSyxLQUFLLEVBQUU7UUFDdkMsTUFBTSxpQkFBaUIsQ0FBQztZQUN0QixlQUFlLEVBQ2IsTUFBTSxDQUFDLGVBQWU7Z0JBQ3RCLFNBQVMsQ0FBQyxRQUFRO2dCQUNsQixrQkFBa0IsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDO1lBQzVDLDRCQUE0QixFQUFFO2dCQUM1QixDQUFDLE1BQU0sQ0FBQywyQkFBMkIsQ0FBQyxFQUFFO29CQUNwQyxHQUFHLEVBQUUsT0FBTyxFQUFFLFlBQVksSUFBSSxDQUFDO2lCQUNoQzthQUNGO1NBQ0YsQ0FBQyxDQUFDO0tBQ0o7SUFFRCxPQUFPLG1CQUFtQixDQUN4QixpQ0FBaUMsRUFDakM7UUFDRSxHQUFHLE1BQU07UUFDVCxhQUFhLEVBQUUsS0FBSztLQUNyQixFQUNELE9BQU8sQ0FDUixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBa0JGLE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBRyxLQUFLLEVBQ2xDLE1BQW9DLEVBQ3BDLE9BQTBCLEVBSzFCLEVBQUU7SUFDRixNQUFNLFNBQVMsR0FBRyxpQkFBaUIsQ0FDakMsTUFBTSxDQUFDLDJCQUEyQixFQUNsQyw0QkFBNEIsQ0FBQyxNQUFNLENBQUMsRUFDcEM7UUFDRSxTQUFTLEVBQUUsTUFBTSxDQUFDLFNBQVM7UUFDM0Isb0JBQW9CLEVBQUUsTUFBTSxDQUFDLG9CQUFvQjtRQUNqRCxlQUFlLEVBQUUsTUFBTSxDQUFDLGVBQWU7S0FDeEMsQ0FDRixDQUFDO0lBRUYsSUFBSSxPQUFPLEVBQUUsZ0JBQWdCLEtBQUssS0FBSyxFQUFFO1FBQ3ZDLE1BQU0saUJBQWlCLENBQUM7WUFDdEIsZUFBZSxFQUNiLFNBQVMsQ0FBQyxRQUFRLEdBQUcsa0JBQWtCLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQztZQUNqRSw0QkFBNEIsRUFBRTtnQkFDNUIsQ0FBQyxNQUFNLENBQUMsMkJBQTJCLENBQUMsRUFBRTtvQkFDcEMsSUFBSSxFQUFFLE9BQU8sRUFBRSxZQUFZLElBQUksQ0FBQztpQkFDakM7YUFDRjtTQUNGLENBQUMsQ0FBQztLQUNKO0lBRUQsT0FBTyxtQkFBbUIsQ0FDeEIsaUNBQWlDLEVBQ2pDO1FBQ0UsR0FBRyxNQUFNO1FBQ1QsYUFBYSxFQUFFLE1BQU07S0FDdEIsRUFDRCxPQUFPLENBQ1IsQ0FBQztBQUNKLENBQUMsQ0FBQztBQWVGLE1BQU0sQ0FBQyxNQUFNLG1CQUFtQixHQUFHLEtBQUssRUFDdEMsTUFBd0MsRUFDeEMsT0FBMEIsRUFDdUMsRUFBRTtJQUNuRSxNQUFNLFNBQVMsR0FBRyxpQkFBaUIsQ0FDakMsTUFBTSxDQUFDLDBCQUEwQixFQUNqQyxnQ0FBZ0MsQ0FBQyxNQUFNLENBQUMsRUFDeEM7UUFDRSxTQUFTLEVBQUUsTUFBTSxDQUFDLFNBQVM7UUFDM0Isb0JBQW9CLEVBQUUsTUFBTSxDQUFDLG9CQUFvQjtRQUNqRCxlQUFlLEVBQUUsTUFBTSxDQUFDLGVBQWU7S0FDeEMsQ0FDRixDQUFDO0lBRUYsSUFBSSxPQUFPLEVBQUUsZ0JBQWdCLEtBQUssS0FBSyxFQUFFO1FBQ3ZDLE1BQU0saUJBQWlCLENBQUM7WUFDdEIsZUFBZSxFQUNiLFNBQVMsQ0FBQyxRQUFRLEdBQUcsa0JBQWtCLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQztZQUNqRSw0QkFBNEIsRUFBRTtnQkFDNUIsQ0FBQyxNQUFNLENBQUMsMkJBQTJCLENBQUMsRUFBRTtvQkFDcEMsUUFBUSxFQUFFLE9BQU8sRUFBRSxZQUFZLElBQUksQ0FBQztpQkFDckM7YUFDRjtTQUNGLENBQUMsQ0FBQztLQUNKO0lBRUQsT0FBTyxtQkFBbUIsQ0FBQyw4QkFBOEIsRUFBRSxNQUFNLEVBQUU7UUFDakUsR0FBRyxPQUFPO1FBQ1Ysb0JBQW9CLEVBQUUsdUNBQXVDO0tBQzlELENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQztBQUVGLE1BQU0sZ0NBQWdDLEdBQUcsQ0FDdkMsTUFBd0MsRUFDeEMsRUFBRTtJQUNGLE1BQU0sUUFBUSxHQUFHLElBQUksc0NBQXNDLEVBQUUsQ0FBQztJQUM5RCxRQUFRLENBQUMsMEJBQTBCLEdBQUcsTUFBTSxDQUFDLDBCQUEwQixDQUFDO0lBQ3hFLFFBQVEsQ0FBQyxnQkFBZ0IsR0FBRyw4QkFBOEIsQ0FDeEQsTUFBTSxDQUFDLDJCQUEyQixDQUNuQyxDQUFDO0lBQ0YsUUFBUSxDQUFDLGlCQUFpQixHQUFHLDhCQUE4QixDQUN6RCxNQUFNLENBQUMsc0NBQXNDLENBQzlDLENBQUM7SUFFRixPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDLENBQUM7QUFFRixNQUFNLHVDQUF1QyxHQUFHLENBQzlDLE1BQXdDLEVBQ0MsRUFBRTtJQUMzQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsTUFBTSxDQUFDLHNDQUFzQyxDQUFDLEVBQUU7UUFDeEUsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUNuQiwrREFBK0QsQ0FDaEUsQ0FBQztLQUNIO0lBQ0QsT0FBTyx1QkFBdUIsQ0FDNUIsTUFBTSxDQUFDLDBCQUEwQixFQUNqQyxnQ0FBZ0MsQ0FBQyxNQUFNLENBQUMsRUFDeEM7UUFDRSxTQUFTLEVBQUUsTUFBTSxDQUFDLFNBQVM7UUFDM0Isb0JBQW9CLEVBQUUsTUFBTSxDQUFDLG9CQUFvQjtRQUNqRCxlQUFlLEVBQUUsTUFBTSxDQUFDLGVBQWU7S0FDeEMsQ0FDRixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBRUYsTUFBTSwyQkFBMkIsR0FBRyxDQUFDLE1BQW1DLEVBQUUsRUFBRTtJQUMxRSwyRUFBMkU7SUFDM0Usb0VBQW9FO0lBQ3BFLHlEQUF5RDtJQUN6RCxNQUFNLFFBQVEsR0FBRyxJQUFJLDhCQUE4QixFQUFFLENBQUM7SUFDdEQsUUFBUSxDQUFDLGdCQUFnQixHQUFHLDhCQUE4QixDQUN4RCxNQUFNLENBQUMsMkJBQTJCLENBQ25DLENBQUM7SUFDRixRQUFRLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztJQUMzQixRQUFRLENBQUMsZUFBZSxHQUFHLE1BQU0sQ0FBQyxlQUFlLENBQUM7SUFDbEQsUUFBUSxDQUFDLDJCQUEyQjtRQUNsQyxNQUFNLENBQUMsMkJBQTJCLElBQUksTUFBTSxDQUFDLGdCQUFnQixDQUFDO0lBRWhFLE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUMsQ0FBQztBQUVGLE1BQU0sNEJBQTRCLEdBQUcsQ0FBQyxNQUFvQyxFQUFFLEVBQUU7SUFDNUUsMkVBQTJFO0lBQzNFLDJFQUEyRTtJQUMzRSwyQ0FBMkM7SUFDM0MsTUFBTSxRQUFRLEdBQUcsSUFBSSw4QkFBOEIsRUFBRSxDQUFDO0lBQ3RELFFBQVEsQ0FBQyxnQkFBZ0IsR0FBRyw4QkFBOEIsQ0FDeEQsTUFBTSxDQUFDLDJCQUEyQixDQUNuQyxDQUFDO0lBQ0YsUUFBUSxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUM7SUFDM0IsUUFBUSxDQUFDLHNCQUFzQixHQUFHLE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQztJQUNoRSxRQUFRLENBQUMsb0JBQW9CO1FBQzNCLE1BQU0sQ0FBQyxvQkFBb0IsSUFBSSxNQUFNLENBQUMsZ0JBQWdCLENBQUM7SUFFekQsT0FBTyxRQUFRLENBQUM7QUFDbEIsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQnV5T3JTZWxsQ3JlYXRvckNvaW5SZXF1ZXN0LFxuICBCdXlPclNlbGxDcmVhdG9yQ29pblJlc3BvbnNlLFxuICBDb25zdHJ1Y3RlZFRyYW5zYWN0aW9uUmVzcG9uc2UsXG4gIFNlbmREZVNvUmVxdWVzdCxcbiAgU2VuZERlU29SZXNwb25zZSxcbiAgVHJhbnNmZXJDcmVhdG9yQ29pblJlcXVlc3QsXG4gIFRyYW5zZmVyQ3JlYXRvckNvaW5SZXNwb25zZSxcbiAgVHhSZXF1ZXN0V2l0aE9wdGlvbmFsRmVlc0FuZEV4dHJhRGF0YSxcbn0gZnJvbSAnLi4vYmFja2VuZC10eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgeyBQYXJ0aWFsV2l0aFJlcXVpcmVkRmllbGRzIH0gZnJvbSAnLi4vZGF0YS9pbmRleC5qcyc7XG5pbXBvcnQge1xuICBUcmFuc2FjdGlvbk1ldGFkYXRhQmFzaWNUcmFuc2ZlcixcbiAgVHJhbnNhY3Rpb25NZXRhZGF0YUNyZWF0b3JDb2luLFxuICBUcmFuc2FjdGlvbk1ldGFkYXRhQ3JlYXRvckNvaW5UcmFuc2ZlcixcbiAgVHJhbnNhY3Rpb25PdXRwdXQsXG4gIGJzNThQdWJsaWNLZXlUb0NvbXByZXNzZWRCeXRlcyxcbiAgaWRlbnRpdHksXG59IGZyb20gJy4uL2lkZW50aXR5L2luZGV4LmpzJztcbmltcG9ydCB7XG4gIGNvbnN0cnVjdEJhbGFuY2VNb2RlbFR4LFxuICBnZXRUeFdpdGhGZWVOYW5vcyxcbiAgaGFuZGxlU2lnbkFuZFN1Ym1pdCxcbiAgaXNNYXliZURlU29QdWJsaWNLZXksXG4gIHN1bVRyYW5zYWN0aW9uRmVlcyxcbn0gZnJvbSAnLi4vaW50ZXJuYWwuanMnO1xuaW1wb3J0IHsgQ29uc3RydWN0ZWRBbmRTdWJtaXR0ZWRUeCwgVHhSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzLmpzJztcbmltcG9ydCB7IGd1YXJkVHhQZXJtaXNzaW9uIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8qKlxuICogaHR0cHM6Ly9kb2NzLmRlc28ub3JnL2Rlc28tYmFja2VuZC9jb25zdHJ1Y3QtdHJhbnNhY3Rpb25zL2ZpbmFuY2lhbC10cmFuc2FjdGlvbnMtYXBpI3NlbmQtZGVzb1xuICovXG5leHBvcnQgY29uc3Qgc2VuZERlc28gPSBhc3luYyAoXG4gIHBhcmFtczogVHhSZXF1ZXN0V2l0aE9wdGlvbmFsRmVlc0FuZEV4dHJhRGF0YTxTZW5kRGVTb1JlcXVlc3Q+LFxuICBvcHRpb25zPzogVHhSZXF1ZXN0T3B0aW9uc1xuKTogUHJvbWlzZTxcbiAgQ29uc3RydWN0ZWRBbmRTdWJtaXR0ZWRUeDxTZW5kRGVTb1Jlc3BvbnNlIHwgQ29uc3RydWN0ZWRUcmFuc2FjdGlvblJlc3BvbnNlPlxuPiA9PiB7XG4gIGNvbnN0IHR4V2l0aEZlZSA9IGdldFR4V2l0aEZlZU5hbm9zKFxuICAgIHBhcmFtcy5TZW5kZXJQdWJsaWNLZXlCYXNlNThDaGVjayxcbiAgICBuZXcgVHJhbnNhY3Rpb25NZXRhZGF0YUJhc2ljVHJhbnNmZXIoKSxcbiAgICB7XG4gICAgICBPdXRwdXRzOiBidWlsZFNlbmREZVNvT3V0cHV0cyh7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgLy8gTk9URTogdGhpcyBpcyBhIGJpdCBvZiBhbiBvZGQgaGFjaywgYnV0IGJjIHdlIGFyZSBvbmx5IHVzaW5nIHRoaXMgdG9cbiAgICAgICAgLy8gZXN0aW1hdGUgdGhlIGZlZSwgd2UgY2FuIG92ZXJ3cml0ZSB0aGUgcmVjaXBpZW50IHRvIGJlIHRoZSBzZW5kZXIgdG9cbiAgICAgICAgLy8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIHB1YmxpYyBrZXkgdGhhdCBjYW4gYmUgY29udmVydGVkIHRvXG4gICAgICAgIC8vIGJ5dGVzLiBUaGUgcmVhc29uIHdlIGNhbm5vdCBtYWtlIGFuIGFwaSBjYWxsIHRvIGdldCB0aGUgdHJ1ZSBwdWJsaWNcbiAgICAgICAgLy8ga2V5IGlzIGJlY2F1c2UgaXQgY291bGQgY2F1c2UgdGhlIGRlcml2ZWQga2V5IHJlLWFwcHJvdmFsIHBvcHVwIHRvXG4gICAgICAgIC8vIGdldCBibG9ja2VkIGJ5IGJyb3dzZXIgcG9wdXAgYmxvY2tlcnMuXG4gICAgICAgIFJlY2lwaWVudFB1YmxpY0tleU9yVXNlcm5hbWU6IHBhcmFtcy5TZW5kZXJQdWJsaWNLZXlCYXNlNThDaGVjayxcbiAgICAgIH0pLFxuICAgICAgRXh0cmFEYXRhOiBwYXJhbXMuRXh0cmFEYXRhLFxuICAgICAgTWluRmVlUmF0ZU5hbm9zUGVyS0I6IHBhcmFtcy5NaW5GZWVSYXRlTmFub3NQZXJLQixcbiAgICAgIFRyYW5zYWN0aW9uRmVlczogcGFyYW1zLlRyYW5zYWN0aW9uRmVlcyxcbiAgICB9XG4gICk7XG5cbiAgaWYgKG9wdGlvbnM/LmNoZWNrUGVybWlzc2lvbnMgIT09IGZhbHNlKSB7XG4gICAgYXdhaXQgZ3VhcmRUeFBlcm1pc3Npb24oe1xuICAgICAgR2xvYmFsREVTT0xpbWl0OlxuICAgICAgICBwYXJhbXMuQW1vdW50TmFub3MgK1xuICAgICAgICB0eFdpdGhGZWUuZmVlTmFub3MgK1xuICAgICAgICBzdW1UcmFuc2FjdGlvbkZlZXMocGFyYW1zLlRyYW5zYWN0aW9uRmVlcyksXG4gICAgICBUcmFuc2FjdGlvbkNvdW50TGltaXRNYXA6IHtcbiAgICAgICAgQkFTSUNfVFJBTlNGRVI6XG4gICAgICAgICAgb3B0aW9ucz8udHhMaW1pdENvdW50ID8/XG4gICAgICAgICAgaWRlbnRpdHkudHJhbnNhY3Rpb25TcGVuZGluZ0xpbWl0T3B0aW9ucy5UcmFuc2FjdGlvbkNvdW50TGltaXRNYXBcbiAgICAgICAgICAgID8uQkFTSUNfVFJBTlNGRVIgPz9cbiAgICAgICAgICAxLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBoYW5kbGVTaWduQW5kU3VibWl0KCdhcGkvdjAvc2VuZC1kZXNvJywgcGFyYW1zLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBjb25zdHJ1Y3Rpb25GdW5jdGlvbjogY29uc3RydWN0U2VuZERlU29UcmFuc2FjdGlvbixcbiAgfSk7XG59O1xuXG5jb25zdCBidWlsZFNlbmREZVNvT3V0cHV0cyA9IChcbiAgcGFyYW1zOiBUeFJlcXVlc3RXaXRoT3B0aW9uYWxGZWVzQW5kRXh0cmFEYXRhPFNlbmREZVNvUmVxdWVzdD5cbikgPT4ge1xuICBjb25zdCB0cmFuc2FjdGlvbk91dHB1dCA9IG5ldyBUcmFuc2FjdGlvbk91dHB1dCgpO1xuICB0cmFuc2FjdGlvbk91dHB1dC5hbW91bnROYW5vcyA9IHBhcmFtcy5BbW91bnROYW5vcztcbiAgdHJhbnNhY3Rpb25PdXRwdXQucHVibGljS2V5ID0gYnM1OFB1YmxpY0tleVRvQ29tcHJlc3NlZEJ5dGVzKFxuICAgIC8vIEZJWE1FOiB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHJlY2lwaWVudCBpcyBhIHVzZXJuYW1lLiBXZSBuZWVkXG4gICAgLy8gdG8gZWl0aGVyIGZldGNoIHRoZSBwdWJsaWMga2V5IGFuZCBvdmVyd3JpdGUgdGhlIHVzZXJuYW1lIHdpdGggaXQgb3JcbiAgICAvLyB0aHJvdyBhIG1vcmUgaGVscGZ1bCBlcnJvciB0byBjb25zdW1lcnMgZXhwbGFpbmluZyB0aGF0IHdlIHJlcXVpcmUgdGhlXG4gICAgLy8gcHVibGljIGtleSBpbnN0ZWFkIG9mIHRoZSB1c2VybmFtZS5cbiAgICBwYXJhbXMuUmVjaXBpZW50UHVibGljS2V5T3JVc2VybmFtZVxuICApO1xuICByZXR1cm4gW3RyYW5zYWN0aW9uT3V0cHV0XTtcbn07XG5cbmV4cG9ydCBjb25zdCBjb25zdHJ1Y3RTZW5kRGVTb1RyYW5zYWN0aW9uID0gKFxuICBwYXJhbXM6IFR4UmVxdWVzdFdpdGhPcHRpb25hbEZlZXNBbmRFeHRyYURhdGE8U2VuZERlU29SZXF1ZXN0PlxuKTogUHJvbWlzZTxDb25zdHJ1Y3RlZFRyYW5zYWN0aW9uUmVzcG9uc2U+ID0+IHtcbiAgaWYgKCFpc01heWJlRGVTb1B1YmxpY0tleShwYXJhbXMuUmVjaXBpZW50UHVibGljS2V5T3JVc2VybmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnbXVzdCBwcm92aWRlIHB1YmxpYyBrZXksIG5vdCB1c2VyIG5hbWUgZm9yIGxvY2FsIGNvbnN0cnVjdGlvbidcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGNvbnN0cnVjdEJhbGFuY2VNb2RlbFR4KFxuICAgIHBhcmFtcy5TZW5kZXJQdWJsaWNLZXlCYXNlNThDaGVjayxcbiAgICBuZXcgVHJhbnNhY3Rpb25NZXRhZGF0YUJhc2ljVHJhbnNmZXIoKSxcbiAgICB7XG4gICAgICBPdXRwdXRzOiBidWlsZFNlbmREZVNvT3V0cHV0cyhwYXJhbXMpLFxuICAgICAgRXh0cmFEYXRhOiBwYXJhbXMuRXh0cmFEYXRhLFxuICAgICAgTWluRmVlUmF0ZU5hbm9zUGVyS0I6IHBhcmFtcy5NaW5GZWVSYXRlTmFub3NQZXJLQixcbiAgICAgIFRyYW5zYWN0aW9uRmVlczogcGFyYW1zLlRyYW5zYWN0aW9uRmVlcyxcbiAgICAgIE5vbmNlOiBwYXJhbXMuTm9uY2UsXG4gICAgfVxuICApO1xufTtcblxuLy8gVE9ETzogQlVZIGNyZWF0b3IgY29pbnMgaXMgaGFyZC4gTmVlZCB0byBtb3ZlIHNvbWVcbi8vIGJpZyBmbG9hdCBtYXRoIGludG8ganMuXG4vKipcbiAqIGh0dHBzOi8vZG9jcy5kZXNvLm9yZy9kZXNvLWJhY2tlbmQvY29uc3RydWN0LXRyYW5zYWN0aW9ucy9maW5hbmNpYWwtdHJhbnNhY3Rpb25zLWFwaSNidXktb3Itc2VsbC1jcmVhdG9yLWNvaW5cbiAqL1xuZXhwb3J0IHR5cGUgQnV5Q3JlYXRvckNvaW5SZXF1ZXN0UGFyYW1zID0gVHhSZXF1ZXN0V2l0aE9wdGlvbmFsRmVlc0FuZEV4dHJhRGF0YTxcbiAgUGFydGlhbFdpdGhSZXF1aXJlZEZpZWxkczxcbiAgICBPbWl0PFxuICAgICAgQnV5T3JTZWxsQ3JlYXRvckNvaW5SZXF1ZXN0LFxuICAgICAgJ0NyZWF0b3JDb2luVG9TZWxsTmFub3MnIHwgJ09wZXJhdGlvblR5cGUnXG4gICAgPixcbiAgICB8ICdVcGRhdGVyUHVibGljS2V5QmFzZTU4Q2hlY2snXG4gICAgfCAnQ3JlYXRvclB1YmxpY0tleUJhc2U1OENoZWNrJ1xuICAgIHwgJ0RlU29Ub1NlbGxOYW5vcydcbiAgPlxuPjtcbmV4cG9ydCBjb25zdCBidXlDcmVhdG9yQ29pbiA9IGFzeW5jIChcbiAgcGFyYW1zOiBCdXlDcmVhdG9yQ29pblJlcXVlc3RQYXJhbXMsXG4gIG9wdGlvbnM/OiBUeFJlcXVlc3RPcHRpb25zXG4pOiBQcm9taXNlPFxuICBDb25zdHJ1Y3RlZEFuZFN1Ym1pdHRlZFR4PFxuICAgIEJ1eU9yU2VsbENyZWF0b3JDb2luUmVzcG9uc2UgfCBDb25zdHJ1Y3RlZFRyYW5zYWN0aW9uUmVzcG9uc2VcbiAgPlxuPiA9PiB7XG4gIGNvbnN0IHR4V2l0aEZlZSA9IGdldFR4V2l0aEZlZU5hbm9zKFxuICAgIHBhcmFtcy5VcGRhdGVyUHVibGljS2V5QmFzZTU4Q2hlY2ssXG4gICAgYnVpbGRCdXlDcmVhdG9yQ29pbk1ldGFkYXRhKHBhcmFtcyksXG4gICAge1xuICAgICAgRXh0cmFEYXRhOiBwYXJhbXMuRXh0cmFEYXRhLFxuICAgICAgTWluRmVlUmF0ZU5hbm9zUGVyS0I6IHBhcmFtcy5NaW5GZWVSYXRlTmFub3NQZXJLQixcbiAgICAgIFRyYW5zYWN0aW9uRmVlczogcGFyYW1zLlRyYW5zYWN0aW9uRmVlcyxcbiAgICB9XG4gICk7XG5cbiAgaWYgKG9wdGlvbnM/LmNoZWNrUGVybWlzc2lvbnMgIT09IGZhbHNlKSB7XG4gICAgYXdhaXQgZ3VhcmRUeFBlcm1pc3Npb24oe1xuICAgICAgR2xvYmFsREVTT0xpbWl0OlxuICAgICAgICBwYXJhbXMuRGVTb1RvU2VsbE5hbm9zICtcbiAgICAgICAgdHhXaXRoRmVlLmZlZU5hbm9zICtcbiAgICAgICAgc3VtVHJhbnNhY3Rpb25GZWVzKHBhcmFtcy5UcmFuc2FjdGlvbkZlZXMpLFxuICAgICAgQ3JlYXRvckNvaW5PcGVyYXRpb25MaW1pdE1hcDoge1xuICAgICAgICBbcGFyYW1zLkNyZWF0b3JQdWJsaWNLZXlCYXNlNThDaGVja106IHtcbiAgICAgICAgICBidXk6IG9wdGlvbnM/LnR4TGltaXRDb3VudCA/PyAxLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBoYW5kbGVTaWduQW5kU3VibWl0KFxuICAgICdhcGkvdjAvYnV5LW9yLXNlbGwtY3JlYXRvci1jb2luJyxcbiAgICB7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBPcGVyYXRpb25UeXBlOiAnYnV5JyxcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbn07XG5cbi8vIFRPRE86IFNFTEwgY3JlYXRvciBjb2lucyBpcyBoYXJkLiBOZWVkIHRvIG1vdmUgc29tZVxuLy8gYmlnIGZsb2F0IG1hdGggaW50byBqcy5cbi8qKlxuICogaHR0cHM6Ly9kb2NzLmRlc28ub3JnL2Rlc28tYmFja2VuZC9jb25zdHJ1Y3QtdHJhbnNhY3Rpb25zL2ZpbmFuY2lhbC10cmFuc2FjdGlvbnMtYXBpI2J1eS1vci1zZWxsLWNyZWF0b3ItY29pblxuICovXG5cbmV4cG9ydCB0eXBlIFNlbGxDcmVhdG9yQ29pblJlcXVlc3RQYXJhbXMgPVxuICBUeFJlcXVlc3RXaXRoT3B0aW9uYWxGZWVzQW5kRXh0cmFEYXRhPFxuICAgIFBhcnRpYWxXaXRoUmVxdWlyZWRGaWVsZHM8XG4gICAgICBPbWl0PEJ1eU9yU2VsbENyZWF0b3JDb2luUmVxdWVzdCwgJ0Rlc29Ub1NlbGxOYW5vcycgfCAnT3BlcmF0aW9uVHlwZSc+LFxuICAgICAgfCAnVXBkYXRlclB1YmxpY0tleUJhc2U1OENoZWNrJ1xuICAgICAgfCAnQ3JlYXRvclB1YmxpY0tleUJhc2U1OENoZWNrJ1xuICAgICAgfCAnQ3JlYXRvckNvaW5Ub1NlbGxOYW5vcydcbiAgICA+XG4gID47XG5cbmV4cG9ydCBjb25zdCBzZWxsQ3JlYXRvckNvaW4gPSBhc3luYyAoXG4gIHBhcmFtczogU2VsbENyZWF0b3JDb2luUmVxdWVzdFBhcmFtcyxcbiAgb3B0aW9ucz86IFR4UmVxdWVzdE9wdGlvbnNcbik6IFByb21pc2U8XG4gIENvbnN0cnVjdGVkQW5kU3VibWl0dGVkVHg8XG4gICAgQnV5T3JTZWxsQ3JlYXRvckNvaW5SZXNwb25zZSB8IENvbnN0cnVjdGVkVHJhbnNhY3Rpb25SZXNwb25zZVxuICA+XG4+ID0+IHtcbiAgY29uc3QgdHhXaXRoRmVlID0gZ2V0VHhXaXRoRmVlTmFub3MoXG4gICAgcGFyYW1zLlVwZGF0ZXJQdWJsaWNLZXlCYXNlNThDaGVjayxcbiAgICBidWlsZFNlbGxDcmVhdG9yQ29pbk1ldGFkYXRhKHBhcmFtcyksXG4gICAge1xuICAgICAgRXh0cmFEYXRhOiBwYXJhbXMuRXh0cmFEYXRhLFxuICAgICAgTWluRmVlUmF0ZU5hbm9zUGVyS0I6IHBhcmFtcy5NaW5GZWVSYXRlTmFub3NQZXJLQixcbiAgICAgIFRyYW5zYWN0aW9uRmVlczogcGFyYW1zLlRyYW5zYWN0aW9uRmVlcyxcbiAgICB9XG4gICk7XG5cbiAgaWYgKG9wdGlvbnM/LmNoZWNrUGVybWlzc2lvbnMgIT09IGZhbHNlKSB7XG4gICAgYXdhaXQgZ3VhcmRUeFBlcm1pc3Npb24oe1xuICAgICAgR2xvYmFsREVTT0xpbWl0OlxuICAgICAgICB0eFdpdGhGZWUuZmVlTmFub3MgKyBzdW1UcmFuc2FjdGlvbkZlZXMocGFyYW1zLlRyYW5zYWN0aW9uRmVlcyksXG4gICAgICBDcmVhdG9yQ29pbk9wZXJhdGlvbkxpbWl0TWFwOiB7XG4gICAgICAgIFtwYXJhbXMuQ3JlYXRvclB1YmxpY0tleUJhc2U1OENoZWNrXToge1xuICAgICAgICAgIHNlbGw6IG9wdGlvbnM/LnR4TGltaXRDb3VudCA/PyAxLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBoYW5kbGVTaWduQW5kU3VibWl0KFxuICAgICdhcGkvdjAvYnV5LW9yLXNlbGwtY3JlYXRvci1jb2luJyxcbiAgICB7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBPcGVyYXRpb25UeXBlOiAnc2VsbCcsXG4gICAgfSxcbiAgICBvcHRpb25zXG4gICk7XG59O1xuXG4vKipcbiAqIGh0dHBzOi8vZG9jcy5kZXNvLm9yZy9kZXNvLWJhY2tlbmQvY29uc3RydWN0LXRyYW5zYWN0aW9ucy9maW5hbmNpYWwtdHJhbnNhY3Rpb25zLWFwaSN0cmFuc2Zlci1jcmVhdG9yLWNvaW5cbiAqL1xuZXhwb3J0IHR5cGUgVHJhbnNmZXJDcmVhdG9yQ29pblJlcXVlc3RQYXJhbXMgPVxuICBUeFJlcXVlc3RXaXRoT3B0aW9uYWxGZWVzQW5kRXh0cmFEYXRhPFxuICAgIFBhcnRpYWxXaXRoUmVxdWlyZWRGaWVsZHM8XG4gICAgICBUcmFuc2ZlckNyZWF0b3JDb2luUmVxdWVzdCxcbiAgICAgIHwgJ1NlbmRlclB1YmxpY0tleUJhc2U1OENoZWNrJ1xuICAgICAgfCAnQ3JlYXRvclB1YmxpY0tleUJhc2U1OENoZWNrJ1xuICAgICAgfCAnUmVjZWl2ZXJVc2VybmFtZU9yUHVibGljS2V5QmFzZTU4Q2hlY2snXG4gICAgICB8ICdDcmVhdG9yQ29pblRvVHJhbnNmZXJOYW5vcydcbiAgICA+XG4gID47XG5leHBvcnQgY29uc3QgdHJhbnNmZXJDcmVhdG9yQ29pbiA9IGFzeW5jIChcbiAgcGFyYW1zOiBUcmFuc2ZlckNyZWF0b3JDb2luUmVxdWVzdFBhcmFtcyxcbiAgb3B0aW9ucz86IFR4UmVxdWVzdE9wdGlvbnNcbik6IFByb21pc2U8Q29uc3RydWN0ZWRBbmRTdWJtaXR0ZWRUeDxUcmFuc2ZlckNyZWF0b3JDb2luUmVzcG9uc2U+PiA9PiB7XG4gIGNvbnN0IHR4V2l0aEZlZSA9IGdldFR4V2l0aEZlZU5hbm9zKFxuICAgIHBhcmFtcy5TZW5kZXJQdWJsaWNLZXlCYXNlNThDaGVjayxcbiAgICBidWlsZFRyYW5zZmVyQ3JlYXRvckNvaW5NZXRhZGF0YShwYXJhbXMpLFxuICAgIHtcbiAgICAgIEV4dHJhRGF0YTogcGFyYW1zLkV4dHJhRGF0YSxcbiAgICAgIE1pbkZlZVJhdGVOYW5vc1BlcktCOiBwYXJhbXMuTWluRmVlUmF0ZU5hbm9zUGVyS0IsXG4gICAgICBUcmFuc2FjdGlvbkZlZXM6IHBhcmFtcy5UcmFuc2FjdGlvbkZlZXMsXG4gICAgfVxuICApO1xuXG4gIGlmIChvcHRpb25zPy5jaGVja1Blcm1pc3Npb25zICE9PSBmYWxzZSkge1xuICAgIGF3YWl0IGd1YXJkVHhQZXJtaXNzaW9uKHtcbiAgICAgIEdsb2JhbERFU09MaW1pdDpcbiAgICAgICAgdHhXaXRoRmVlLmZlZU5hbm9zICsgc3VtVHJhbnNhY3Rpb25GZWVzKHBhcmFtcy5UcmFuc2FjdGlvbkZlZXMpLFxuICAgICAgQ3JlYXRvckNvaW5PcGVyYXRpb25MaW1pdE1hcDoge1xuICAgICAgICBbcGFyYW1zLkNyZWF0b3JQdWJsaWNLZXlCYXNlNThDaGVja106IHtcbiAgICAgICAgICB0cmFuc2Zlcjogb3B0aW9ucz8udHhMaW1pdENvdW50ID8/IDEsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZVNpZ25BbmRTdWJtaXQoJ2FwaS92MC90cmFuc2Zlci1jcmVhdG9yLWNvaW4nLCBwYXJhbXMsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGNvbnN0cnVjdGlvbkZ1bmN0aW9uOiBjb25zdHJ1Y3RUcmFuc2ZlckNyZWF0b3JDb2luVHJhbnNhY3Rpb24sXG4gIH0pO1xufTtcblxuY29uc3QgYnVpbGRUcmFuc2ZlckNyZWF0b3JDb2luTWV0YWRhdGEgPSAoXG4gIHBhcmFtczogVHJhbnNmZXJDcmVhdG9yQ29pblJlcXVlc3RQYXJhbXNcbikgPT4ge1xuICBjb25zdCBtZXRhZGF0YSA9IG5ldyBUcmFuc2FjdGlvbk1ldGFkYXRhQ3JlYXRvckNvaW5UcmFuc2ZlcigpO1xuICBtZXRhZGF0YS5jcmVhdG9yQ29pblRvVHJhbnNmZXJOYW5vcyA9IHBhcmFtcy5DcmVhdG9yQ29pblRvVHJhbnNmZXJOYW5vcztcbiAgbWV0YWRhdGEucHJvZmlsZVB1YmxpY0tleSA9IGJzNThQdWJsaWNLZXlUb0NvbXByZXNzZWRCeXRlcyhcbiAgICBwYXJhbXMuQ3JlYXRvclB1YmxpY0tleUJhc2U1OENoZWNrXG4gICk7XG4gIG1ldGFkYXRhLnJlY2VpdmVyUHVibGljS2V5ID0gYnM1OFB1YmxpY0tleVRvQ29tcHJlc3NlZEJ5dGVzKFxuICAgIHBhcmFtcy5SZWNlaXZlclVzZXJuYW1lT3JQdWJsaWNLZXlCYXNlNThDaGVja1xuICApO1xuXG4gIHJldHVybiBtZXRhZGF0YTtcbn07XG5cbmNvbnN0IGNvbnN0cnVjdFRyYW5zZmVyQ3JlYXRvckNvaW5UcmFuc2FjdGlvbiA9IChcbiAgcGFyYW1zOiBUcmFuc2ZlckNyZWF0b3JDb2luUmVxdWVzdFBhcmFtc1xuKTogUHJvbWlzZTxDb25zdHJ1Y3RlZFRyYW5zYWN0aW9uUmVzcG9uc2U+ID0+IHtcbiAgaWYgKCFpc01heWJlRGVTb1B1YmxpY0tleShwYXJhbXMuUmVjZWl2ZXJVc2VybmFtZU9yUHVibGljS2V5QmFzZTU4Q2hlY2spKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgJ211c3QgcHJvdmlkZSBwdWJsaWMga2V5LCBub3QgdXNlciBuYW1lIGZvciBsb2NhbCBjb25zdHJ1Y3Rpb24nXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29uc3RydWN0QmFsYW5jZU1vZGVsVHgoXG4gICAgcGFyYW1zLlNlbmRlclB1YmxpY0tleUJhc2U1OENoZWNrLFxuICAgIGJ1aWxkVHJhbnNmZXJDcmVhdG9yQ29pbk1ldGFkYXRhKHBhcmFtcyksXG4gICAge1xuICAgICAgRXh0cmFEYXRhOiBwYXJhbXMuRXh0cmFEYXRhLFxuICAgICAgTWluRmVlUmF0ZU5hbm9zUGVyS0I6IHBhcmFtcy5NaW5GZWVSYXRlTmFub3NQZXJLQixcbiAgICAgIFRyYW5zYWN0aW9uRmVlczogcGFyYW1zLlRyYW5zYWN0aW9uRmVlcyxcbiAgICB9XG4gICk7XG59O1xuXG5jb25zdCBidWlsZEJ1eUNyZWF0b3JDb2luTWV0YWRhdGEgPSAocGFyYW1zOiBCdXlDcmVhdG9yQ29pblJlcXVlc3RQYXJhbXMpID0+IHtcbiAgLy8gTk9URTogVGhpcyBpcyBub3QgZXhhY3RseSBhY2N1cmF0ZSBhbmQgZ2l2ZXMgYW4gdXBwZXIgYm91bmQgZXN0aW1hdGUgZm9yXG4gIC8vIG1pbkNyZWF0b3JDb2luRXhwZWN0ZWROYW5vcy4gSXQgc2hvdWxkIG5vdCBidXQgdXNlZCBmb3IgYWN0dWFsIHR4XG4gIC8vIGNvbnN0cnVjdGlvbiwgYnV0IGl0IGlzIHVzZWZ1bCBmb3IgZXN0aW1hdGluZyB0eCBmZWVzLlxuICBjb25zdCBtZXRhZGF0YSA9IG5ldyBUcmFuc2FjdGlvbk1ldGFkYXRhQ3JlYXRvckNvaW4oKTtcbiAgbWV0YWRhdGEucHJvZmlsZVB1YmxpY0tleSA9IGJzNThQdWJsaWNLZXlUb0NvbXByZXNzZWRCeXRlcyhcbiAgICBwYXJhbXMuQ3JlYXRvclB1YmxpY0tleUJhc2U1OENoZWNrXG4gICk7XG4gIG1ldGFkYXRhLm9wZXJhdGlvblR5cGUgPSAwO1xuICBtZXRhZGF0YS5kZXNvVG9TZWxsTmFub3MgPSBwYXJhbXMuRGVTb1RvU2VsbE5hbm9zO1xuICBtZXRhZGF0YS5taW5DcmVhdG9yQ29pbkV4cGVjdGVkTmFub3MgPVxuICAgIHBhcmFtcy5NaW5DcmVhdG9yQ29pbkV4cGVjdGVkTmFub3MgPz8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cbiAgcmV0dXJuIG1ldGFkYXRhO1xufTtcblxuY29uc3QgYnVpbGRTZWxsQ3JlYXRvckNvaW5NZXRhZGF0YSA9IChwYXJhbXM6IFNlbGxDcmVhdG9yQ29pblJlcXVlc3RQYXJhbXMpID0+IHtcbiAgLy8gTk9URTogVGhpcyBpcyBub3QgZXhhY3RseSBhY2N1cmF0ZSBhbmQgZ2l2ZXMgYW4gdXBwZXIgYm91bmQgZXN0aW1hdGUgZm9yXG4gIC8vIG1pbkRlU29FeHBlY3RlZE5hbm9zLiBJdCBzaG91bGQgbm90IGJ1dCB1c2VkIGZvciBhY3R1YWwgdHggY29uc3RydWN0aW9uLFxuICAvLyBidXQgaXQgaXMgdXNlZnVsIGZvciBlc3RpbWF0aW5nIHR4IGZlZXMuXG4gIGNvbnN0IG1ldGFkYXRhID0gbmV3IFRyYW5zYWN0aW9uTWV0YWRhdGFDcmVhdG9yQ29pbigpO1xuICBtZXRhZGF0YS5wcm9maWxlUHVibGljS2V5ID0gYnM1OFB1YmxpY0tleVRvQ29tcHJlc3NlZEJ5dGVzKFxuICAgIHBhcmFtcy5DcmVhdG9yUHVibGljS2V5QmFzZTU4Q2hlY2tcbiAgKTtcbiAgbWV0YWRhdGEub3BlcmF0aW9uVHlwZSA9IDE7XG4gIG1ldGFkYXRhLmNyZWF0b3JDb2luVG9TZWxsTmFub3MgPSBwYXJhbXMuQ3JlYXRvckNvaW5Ub1NlbGxOYW5vcztcbiAgbWV0YWRhdGEubWluRGVTb0V4cGVjdGVkTmFub3MgPVxuICAgIHBhcmFtcy5NaW5EZVNvRXhwZWN0ZWROYW5vcyA/PyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblxuICByZXR1cm4gbWV0YWRhdGE7XG59O1xuIl19
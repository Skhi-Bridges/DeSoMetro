var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Identity_instances, _Identity_window, _Identity_api, _Identity_identityURI, _Identity_network, _Identity_nodeURI, _Identity_identityPopupWindow, _Identity_redirectURI, _Identity_pendingWindowRequest, _Identity_defaultTransactionSpendingLimit, _Identity_appName, _Identity_jwtAlgorithm, _Identity_defaultGroupName, _Identity_boundPostMessageListener, _Identity_subscribers, _Identity_didConfigure, _Identity_isBrowser, _Identity_identityPresenter, _Identity_storageProvider, _Identity_showSkip, _Identity_isAutoDeriveLogin, _Identity_defaultNumDaysBeforeExpiration, _Identity_getState, _Identity_getActivePublicKey, _Identity_getUsers, _Identity_getCurrentUser, _Identity_queryETHRPC, _Identity_getETHTransactionsSignedByAddress, _Identity_authorizeDerivedKey, _Identity_setActiveUser, _Identity_getErrorType, _Identity_authorizePrimaryDerivedKey, _Identity_handlePostMessage, _Identity_handleIdentityResponse, _Identity_handleLoginMethod, _Identity_purgeUserDataForPublicKey, _Identity_handleDeriveMethod, _Identity_updateUser, _Identity_buildQueryParams, _Identity_openIdentityPopup, _Identity_launchIdentity, _Identity_getErrorInstance, _Identity_decryptGroupChat, _Identity_decryptDM;
import { keccak_256 } from '@noble/hashes/sha3';
import { Point, utils as ecUtils } from '@noble/secp256k1';
import { ethers } from 'ethers';
import { ChatType, } from '../backend-types/index.js';
import { DEFAULT_IDENTITY_URI, DEFAULT_NODE_URI, DEFAULT_PERMISSIONS as DEFAULT_TRANSACTION_SPENDING_LIMIT, DESO_NETWORK_TO_ETH_NETWORK, IDENTITY_SERVICE_VALUE, LOCAL_STORAGE_KEYS, } from './constants.js';
import { bs58PublicKeyToBytes, decrypt, decryptChatMessage, deriveAccessGroupKeyPair, encryptChatMessage, getSignedJWT, keygen, publicKeyToBase58Check, signTx, } from './crypto-utils.js';
import { generateDerivedKeyPayload } from './derived-key-utils.js';
import { ERROR_TYPES } from './error-types.js';
import { buildTransactionSpendingLimitResponse, compareTransactionSpendingLimits, } from './permissions-utils.js';
import { parseQueryParams } from './query-param-utils.js';
import { NOTIFICATION_EVENTS, } from './types.js';
export class Identity {
    /**
     * The configured nodeURI used for any network calls. Making this accessible
     * behind a getter ensures it is read-only and can only be set via the
     * configure call.
     */
    get nodeURI() {
        return __classPrivateFieldGet(this, _Identity_nodeURI, "f");
    }
    /**
     * The configured transaction spending limit values provided by the initial
     * configure call.  These can be used to determine the default tx limit count
     * to use if a derived key needs to be re-authorized.
     */
    get transactionSpendingLimitOptions() {
        return __classPrivateFieldGet(this, _Identity_defaultTransactionSpendingLimit, "f");
    }
    constructor(windowProvider, apiProvider) {
        _Identity_instances.add(this);
        /**
         * @private
         */
        _Identity_window.set(this, void 0);
        /**
         * @private
         */
        _Identity_api.set(this, void 0);
        /**
         * @private
         */
        _Identity_identityURI.set(this, DEFAULT_IDENTITY_URI);
        /**
         * @private
         */
        _Identity_network.set(this, 'mainnet');
        /**
         * @private
         */
        _Identity_nodeURI.set(this, DEFAULT_NODE_URI);
        /**
         * @private
         */
        _Identity_identityPopupWindow.set(this, void 0);
        /**
         * @private
         */
        _Identity_redirectURI.set(this, void 0);
        /**
         * @private
         */
        _Identity_pendingWindowRequest.set(this, void 0);
        /**
         * @private
         */
        _Identity_defaultTransactionSpendingLimit.set(this, DEFAULT_TRANSACTION_SPENDING_LIMIT);
        /**
         * @private
         */
        _Identity_appName.set(this, '');
        /**
         * @private
         */
        _Identity_jwtAlgorithm.set(this, 'ES256');
        /**
         * @private
         */
        _Identity_defaultGroupName.set(this, 'default-key');
        /**
         * @private
         */
        _Identity_boundPostMessageListener.set(this, void 0);
        /**
         * @private
         */
        _Identity_subscribers.set(this, []);
        /**
         * @private
         */
        _Identity_didConfigure.set(this, false);
        /**
         * @private
         */
        _Identity_isBrowser.set(this, void 0);
        /**
         * @private
         */
        _Identity_identityPresenter.set(this, void 0);
        /**
         * @private
         */
        _Identity_storageProvider.set(this, void 0);
        /**
         * @private
         */
        _Identity_showSkip.set(this, false);
        /**
         * @private
         */
        _Identity_isAutoDeriveLogin.set(this, false);
        /**
         * Defaults to 10 years. These login keys should essentially never expire
         * unless a user explicitly de-authorizes them.
         * @private
         */
        _Identity_defaultNumDaysBeforeExpiration.set(this, 3650);
        __classPrivateFieldSet(this, _Identity_window, windowProvider, "f");
        __classPrivateFieldSet(this, _Identity_api, apiProvider, "f");
        __classPrivateFieldSet(this, _Identity_isBrowser, typeof windowProvider.location !== 'undefined', "f");
        __classPrivateFieldSet(this, _Identity_storageProvider, globalThis.localStorage, "f");
        if (__classPrivateFieldGet(this, _Identity_isBrowser, "f") && __classPrivateFieldGet(this, _Identity_window, "f").location.search) {
            this.handleRedirectURI(__classPrivateFieldGet(this, _Identity_window, "f").location.search);
        }
    }
    /**
     * Configures the identity instance. This should be called before any other
     * method calls, ideally before any app code is run.  The most important
     * configuration options are `spendingLimitOptions` and `appName`.
     * `spendingLimitOptions` is used to determine the default permissions that a
     * user will be asked to approve when logging into an app. `appName` is used
     * to identity derived keys issued by an app.
     *
     * See more about the spending limit options object here
     * https://docs.deso.org/for-developers/backend/blockchain-data/basics/data-types#transactionspendinglimitresponse
     *
     * And See an exhaustive list of transaction types here:
     * https://github.com/deso-protocol/core/blob/a836e4d2e92f59f7570c7a00f82a3107ec80dd02/lib/network.go#L244
     *
     * @example
     * ```typescript
     * import { identity } from '@deso/identity';
     *
     * identity.configure({
     *   spendingLimitOptions: {
     *     // NOTE: this value is in Deso nanos, 1000000000 nanos (or 1e9) = 1 Deso
     *     GlobalDESOLimit: 1 * 1e9 // 1 Deso
     *     // Map of transaction type to the number of times this derived key is
     *     // allowed to perform this operation on behalf of the owner public key
     *     TransactionCountLimitMap: {
     *       BASIC_TRANSFER: 2, // 2 basic transfer transactions are authorized
     *       SUBMIT_POST: 'UNLIMITED', // unlimited submit post transactions are authorized
     *     },
     *   }
     * });
     * ```
     */
    configure({ identityURI = DEFAULT_IDENTITY_URI, network = 'mainnet', nodeURI = 'https://node.deso.org', spendingLimitOptions = DEFAULT_TRANSACTION_SPENDING_LIMIT, redirectURI, jwtAlgorithm = 'ES256', appName = '', storageProvider, identityPresenter, showSkip, }) {
        __classPrivateFieldSet(this, _Identity_identityURI, identityURI, "f");
        __classPrivateFieldSet(this, _Identity_network, network, "f");
        __classPrivateFieldSet(this, _Identity_nodeURI, nodeURI, "f");
        __classPrivateFieldSet(this, _Identity_redirectURI, redirectURI, "f");
        __classPrivateFieldSet(this, _Identity_jwtAlgorithm, jwtAlgorithm, "f");
        __classPrivateFieldSet(this, _Identity_appName, appName, "f");
        __classPrivateFieldSet(this, _Identity_identityPresenter, identityPresenter, "f");
        __classPrivateFieldSet(this, _Identity_showSkip, !!showSkip, "f");
        if (storageProvider) {
            __classPrivateFieldSet(this, _Identity_storageProvider, storageProvider, "f");
        }
        if (!__classPrivateFieldGet(this, _Identity_didConfigure, "f")) {
            __classPrivateFieldSet(this, _Identity_defaultTransactionSpendingLimit, buildTransactionSpendingLimitResponse(spendingLimitOptions), "f");
            if (__classPrivateFieldGet(this, _Identity_storageProvider, "f")) {
                // If we don't have a storage provider it means we are likely running in
                // a node environment (SSR, etc). In this case we will skip
                // refreshDerivedKeyPermissions since it relies on the storage provider.
                // Once the code executes in a UI environment, the storage provider
                // should be available and we can refresh the derived key permissions.
                this.refreshDerivedKeyPermissions();
            }
        }
        __classPrivateFieldSet(this, _Identity_didConfigure, true, "f");
    }
    /**
     * Allows listening to changes to identity state. The subscriber will be
     * called with the new state any time a user logs in, logs out, approves a
     * derived key, etc. Apps can use this to sync their state with the identity
     * instance such that their application reacts to changes and re-renders
     * accordingly.
     *
     * NOTE: This method could be very chatty. Depending on the needs of your
     * application, you may want to implement some caching or memoization to
     * reduce any unnecessary re-renders or network calls.
     *
     * @example
     * ```typescript
     * identity.subscribe(({ event, currentUser, alternateUsers }) => {
     *   if (event === NOTIFICATION_EVENTS.AUTHORIZE_DERIVED_KEY_START) {
     *     // show a loading indicator while the underlying network call to authorize the derived key is made.
     *   }
     *
     *   if (event === NOTIFICATION_EVENTS.LOGIN_END) {
     *      // do something with currentUser
     *   }
     *
     *   // see and exhaustive list of events here: https://github.com/deso-protocol/deso-workspace/blob/a3c02742a342610bb6af8f2b1396d5430931cf41/libs/identity/src/lib/types.ts#L182
     * });
     * ```
     *
     * @param subscriber this is a callback that will be called with the current
     * state and the event that triggered the change.
     */
    async subscribe(subscriber) {
        __classPrivateFieldGet(this, _Identity_subscribers, "f").push(subscriber);
        const state = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getState).call(this);
        __classPrivateFieldGet(this, _Identity_subscribers, "f").forEach((s) => s({ event: NOTIFICATION_EVENTS.SUBSCRIBE, ...state }));
    }
    /**
     * Remove a subscriber so it no longer gets called when identity state changes.
     */
    unsubscribe(subscriber) {
        __classPrivateFieldSet(this, _Identity_subscribers, __classPrivateFieldGet(this, _Identity_subscribers, "f").filter((s) => s !== subscriber), "f");
    }
    /**
     * Returns the current underlying state of the identity instance. In general,
     * you should use the `subscribe` method to listen to changes to observe and
     * react to the state over time, but if you need a snapshot of the current
     * state you can use this method. Can be useful for debugging or setting up
     * initial state in your app.
     */
    snapshot() {
        return __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getState).call(this);
    }
    /**
     * Starts a login flow. This will open a new window and prompt the user to
     * select an existing account or create a new account. If there is an error
     * during the login flow, the promise will reject with an error which you can
     * catch and handle in your app by showing some error feedback in the UI.
     *
     * @example
     * ```typescript
     * import { identity, ERROR_TYPES } from '@deso/identity';
     *
     *
     * await identity.login().catch((err) => {
     *   if (err.type === ERROR_TYPES.NO_MONEY) {
     *     // handle no money error
     *   } else {
     *     // handle other errors
     *   }
     * });
     * ```
     *
     * @returns returns a promise that resolves to the identity login
     * payload, or rejects if there was an error.
     */
    async login({ getFreeDeso = true, 
    // NOTE: derivedKeyLogin is the default and recommended login flow. We only
    // allow disabling it for simple "gated logins" where the app wants to gate
    // access to the app behind a login, but doesn't need to issue a derived key
    // for executing transactions on behalf of the user.
    derivedKeyLogin = true, } = {}) {
        if (!__classPrivateFieldGet(this, _Identity_storageProvider, "f")) {
            throw new Error('No storage provider available. Did you forget to configure a custom storageProvider?');
        }
        const event = NOTIFICATION_EVENTS.LOGIN_START;
        const state = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getState).call(this);
        __classPrivateFieldGet(this, _Identity_subscribers, "f").forEach((s) => s({ event, ...state }));
        // This is to support "gated logins"
        // https://github.com/deso-protocol/deso-js/issues/1
        if (!derivedKeyLogin) {
            return new Promise((resolve, reject) => {
                __classPrivateFieldSet(this, _Identity_pendingWindowRequest, { resolve, reject, event }, "f");
                __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_launchIdentity).call(this, 'log-in', {
                    accessLevelRequest: 2,
                    getFreeDeso,
                    showSkip: __classPrivateFieldGet(this, _Identity_showSkip, "f"),
                });
            });
        }
        let derivedPublicKey;
        const loginKeyPair = await __classPrivateFieldGet(this, _Identity_storageProvider, "f").getItem(LOCAL_STORAGE_KEYS.loginKeyPair);
        if (loginKeyPair) {
            derivedPublicKey = JSON.parse(loginKeyPair).publicKey;
        }
        else {
            const keys = keygen();
            derivedPublicKey = publicKeyToBase58Check(keys.public, {
                network: __classPrivateFieldGet(this, _Identity_network, "f"),
            });
            await __classPrivateFieldGet(this, _Identity_storageProvider, "f").setItem(LOCAL_STORAGE_KEYS.loginKeyPair, JSON.stringify({
                publicKey: derivedPublicKey,
                seedHex: keys.seedHex,
            }));
        }
        return await new Promise((resolve, reject) => {
            __classPrivateFieldSet(this, _Identity_pendingWindowRequest, { resolve, reject, event }, "f");
            const authenticatedUserKeys = [];
            if (state.currentUser?.primaryDerivedKey) {
                authenticatedUserKeys.push(state.currentUser?.publicKey);
            }
            const alternateUsers = state.alternateUsers ?? {};
            Object.keys(alternateUsers).forEach((key) => {
                if (alternateUsers[key]?.primaryDerivedKey) {
                    authenticatedUserKeys.push(key);
                }
            });
            const identityParams = {
                derive: true,
                derivedPublicKey,
                transactionSpendingLimitResponse: __classPrivateFieldGet(this, _Identity_defaultTransactionSpendingLimit, "f"),
                expirationDays: __classPrivateFieldGet(this, _Identity_defaultNumDaysBeforeExpiration, "f"),
                showSkip: __classPrivateFieldGet(this, _Identity_showSkip, "f"),
                ...(authenticatedUserKeys.length && {
                    authenticatedUsers: authenticatedUserKeys.join(','),
                }),
            };
            if (getFreeDeso) {
                identityParams.getFreeDeso = true;
            }
            __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_launchIdentity).call(this, 'derive', identityParams);
        });
    }
    /**
     * @param ownerSeedHex This is the seed hex of the owner key. This must be provided by the app.
     * @param options.derivedSeedHex This is optional and primarily only used for testing. If not provided, a new random derived key will be generated.
     */
    async loginWithAutoDerive(ownerSeedHex, { derivedSeedHex } = {}) {
        const event = NOTIFICATION_EVENTS.LOGIN_START;
        const state = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getState).call(this);
        __classPrivateFieldGet(this, _Identity_subscribers, "f").forEach((s) => s({ event, ...state }));
        const ownerKeys = keygen(ownerSeedHex);
        const derivedKeys = keygen(derivedSeedHex);
        const derivedPublicKeyBase58 = publicKeyToBase58Check(derivedKeys.public, {
            network: __classPrivateFieldGet(this, _Identity_network, "f"),
        });
        // When the derived payload is handled, we look at local storage to see if
        // this is a login derived key, so we need to set this before we handle the response.
        await __classPrivateFieldGet(this, _Identity_storageProvider, "f")?.setItem(LOCAL_STORAGE_KEYS.loginKeyPair, JSON.stringify({
            publicKey: derivedPublicKeyBase58,
            seedHex: derivedKeys.seedHex,
        }));
        const payload = await generateDerivedKeyPayload(ownerKeys, derivedKeys, __classPrivateFieldGet(this, _Identity_defaultTransactionSpendingLimit, "f"), __classPrivateFieldGet(this, _Identity_defaultNumDaysBeforeExpiration, "f"), __classPrivateFieldGet(this, _Identity_network, "f"));
        return new Promise((resolve, reject) => {
            __classPrivateFieldSet(this, _Identity_pendingWindowRequest, { resolve, reject, event }, "f");
            // NOTE: We set this flag so that when the identity response is handled,
            // we know to let the login flow continue even if the user has no money to
            // authorize the key. It's up to the app to handle how the user gets
            // money, after which they can re-attempt to authorize the key.
            __classPrivateFieldSet(this, _Identity_isAutoDeriveLogin, true, "f");
            __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_handleIdentityResponse).call(this, {
                service: 'identity',
                method: 'derive',
                payload,
            });
        });
    }
    /**
     * Starts a logout flow. This will open a new window and prompt the user to
     * confirm they want to logout. Similar to the login flow, if there is an error
     * the returned promise will reject with an error which you can catch and handle.
     *
     * @example
     * ```typescript
     * import { identity } from '@deso/identity';
     *
     *
     * await identity.logout().catch((err) => {
     *   // handle errors
     * });
     * ```
     *
     * @returns returns a promise that resolves to undefined, or rejects if there
     * was an error.
     */
    async logout() {
        const event = NOTIFICATION_EVENTS.LOGOUT_START;
        const state = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getState).call(this);
        __classPrivateFieldGet(this, _Identity_subscribers, "f").forEach((s) => s({ event, ...state }));
        return new Promise((resolve, reject) => {
            const activePublicKey = __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getActivePublicKey).call(this);
            const launchIdentity = (activePublicKey) => {
                __classPrivateFieldSet(this, _Identity_pendingWindowRequest, { resolve, reject, event }, "f");
                if (!activePublicKey) {
                    __classPrivateFieldGet(this, _Identity_pendingWindowRequest, "f").reject(new Error('cannot logout without an active public key'));
                }
                else {
                    __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_launchIdentity).call(this, 'logout', { publicKey: activePublicKey });
                }
            };
            // NOTE: in the case of a browser context, we are using synchronous local
            // storage, We cannot introduce any async operations because it may
            // trigger popup blockers, which is why we need to branch the logic like
            // this.
            if (typeof activePublicKey === 'string' || activePublicKey === null) {
                launchIdentity(activePublicKey);
            }
            else {
                activePublicKey?.then(launchIdentity);
            }
        });
    }
    /**
     * Signs a transaction hex using the derived key issued to the currently
     * active user when they logged into an application. The `TransactionHex`
     * parameter should come from a transaction object returned from a transaction
     * construction endpoint, such as the `submit-post` endpoint of the DeSo
     * backend api.
     *
     * We return a signed transaction hex value that can be used to submit a
     * transaction to the network for confirmation. This method is used internally
     * by the signAndSubmit method, which is a convenience method to sign and
     * submit a transaction in a single step. It can also be used as a standalone
     * method if you want to sign a transaction and submit it yourself.
     *
     *
     * @example
     * ```typescript
     * const signedTxHex = await identity.signTx(txHex);
     * ```
     */
    async signTx(TransactionHex) {
        const { primaryDerivedKey } = (await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getCurrentUser).call(this)) ?? {};
        if (!primaryDerivedKey?.derivedSeedHex) {
            // This *should* never happen, but just in case we throw here to surface any bugs.
            throw new Error('Cannot sign transaction without a derived seed hex');
        }
        return await signTx(TransactionHex, primaryDerivedKey.derivedSeedHex, {
            isDerivedKey: true,
        });
    }
    /**
     * Submits a signed transaction to the network for confirmation. NOTE: you
     * must sign a transaction before submitting it. This method is used
     * internally by the `signAndSubmit` method, which is a convenience method to
     * sign and submit a transaction in a single step.
     *
     * @example
     * ```typescript
     * const submittedTx = await identity.submitTx(signedTxHex);
     * ```
     */
    async submitTx(TransactionHex) {
        const res = await __classPrivateFieldGet(this, _Identity_api, "f").post(`${__classPrivateFieldGet(this, _Identity_nodeURI, "f")}/api/v0/submit-transaction`, {
            TransactionHex,
        });
        this.refreshDerivedKeyPermissions();
        return res;
    }
    /**
     * This is a convenience method to sign and submit a transaction in a single
     * step. It receives a transaction object and signs it using the derived key
     * issued to the currently logged in user. This can be chained with
     * transaction construction promises that return a transaction object such as
     * a promise that wraps the call to the `submit-post` endpoint of the DeSo
     * backend api.
     *
     * @example
     * ```typescript
     * const transactionObject = await myApiClient.post('https://node.deso.org/api/v0/submit-post', { ...data });
     *
     * await identity.signAndSubmit(transactionObject);
     * ```
     */
    async signAndSubmit(tx) {
        return await this.submitTx(await this.signTx(tx.TransactionHex));
    }
    /**
     * @deprecated Use signAndSubmit instead. Since we don't support unauthorized
     * keys anymore, this is no longer necessary. It's only purpose was to
     * authorize a derived key if it wasn't already authorized and retry the
     * transaction.
     *
     * @param constructTx generic function for constructing a transaction. Should
     * return a promise that resolves to a transaction object.
     * @returns
     */
    async signAndSubmitTx(constructTx) {
        try {
            const tx = await constructTx();
            return await this.submitTx(await this.signTx(tx.TransactionHex));
        }
        catch (e) {
            // if the derived key is not authorized, authorize it and try again
            if (e?.message?.includes('RuleErrorDerivedKeyNotAuthorized')) {
                const { primaryDerivedKey } = (await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getCurrentUser).call(this)) ?? {};
                if (primaryDerivedKey == null) {
                    throw new Error('Cannot authorize derived key without a logged in user');
                }
                // if the derived key is not authorized
                // we try to authorize it and retry
                await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_authorizePrimaryDerivedKey).call(this, primaryDerivedKey.publicKeyBase58Check);
                // reconstruct the original transaction and try again
                // this will throw if the previous authorization failed
                const tx = await constructTx();
                return await this.submitTx(await this.signTx(tx.TransactionHex));
            }
            // just rethrow unexpected errors
            throw e;
        }
    }
    /**
     * Encrypt an arbitrary string using the recipient's
     * public key.
     *
     * @example
     * ```typescript
     * const message = "Hi, this is my first encrypted message!";
     *
     * const cipherText = await identity.encryptMessage(
     *   recipientPublicKeyBase58Check,
     *   message
     * );
     * ```
     */
    async encryptMessage(recipientPublicKeyBase58Check, messagePlainText) {
        const { primaryDerivedKey } = (await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getCurrentUser).call(this)) ?? {};
        if (!primaryDerivedKey?.messagingPrivateKey) {
            // This *should* never happen, but just in case we throw here to surface any bugs.
            throw new Error('Cannot encrypt message without a private messaging key');
        }
        return await encryptChatMessage(primaryDerivedKey.messagingPrivateKey, recipientPublicKeyBase58Check, messagePlainText);
    }
    /**
     * @param message This is a message object returned any of the messages
     * endpoints of the DeSo backend api, could be a DM or a Group message.
     * @param groups This is an array of group chats the user belongs to. This is
     * required to decrypt group messages.
     * @returns
     */
    async decryptMessage(message, groups) {
        const { primaryDerivedKey, publicKey: userPublicKeyBase58Check } = (await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getCurrentUser).call(this)) ?? {};
        if (!(primaryDerivedKey?.messagingPrivateKey && userPublicKeyBase58Check)) {
            // This *should* never happen, but just in case we throw here to surface any bugs.
            throw new Error('Cannot decrypt messages without a logged in user');
        }
        const isSender = message.SenderInfo.OwnerPublicKeyBase58Check ===
            userPublicKeyBase58Check &&
            (message.SenderInfo.AccessGroupKeyName === __classPrivateFieldGet(this, _Identity_defaultGroupName, "f") ||
                !message.SenderInfo.AccessGroupKeyName);
        let DecryptedMessage = '';
        let errorMsg = '';
        switch (message.ChatType) {
            case ChatType.DM:
                if (message.MessageInfo?.ExtraData?.unencrypted) {
                    DecryptedMessage = unencryptedHexToPlainText(message.MessageInfo.EncryptedText);
                }
                else {
                    try {
                        DecryptedMessage = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_decryptDM).call(this, userPublicKeyBase58Check, primaryDerivedKey.messagingPrivateKey, message, isSender);
                    }
                    catch (e) {
                        errorMsg = e?.toString() ?? 'Could not decrypt direct message';
                    }
                }
                break;
            case ChatType.GROUPCHAT:
                try {
                    DecryptedMessage = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_decryptGroupChat).call(this, groups, message);
                }
                catch (e) {
                    errorMsg = e?.toString() ?? 'Could not decrypt group message';
                }
                break;
            default:
                // If we add new chat types, we need to add explicit support for them.
                throw new Error(`unsupported chat type: ${message.ChatType}`);
        }
        return {
            ...message,
            ...{ DecryptedMessage, IsSender: isSender, error: errorMsg },
        };
    }
    /**
     * Decrypts the encrypted access group private key that we will need to use to decrypt group messages.
     *
     * @param encryptedKeyHex
     * @returns returns a promise that resolves t the decrypted key pair.
     */
    async decryptAccessGroupKeyPair(encryptedKeyHex) {
        const { primaryDerivedKey } = (await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getCurrentUser).call(this)) ?? {};
        if (!primaryDerivedKey?.messagingPrivateKey) {
            // This *should* never happen, but just in case we throw here to surface any bugs.
            throw new Error('Cannot encrypt message without a private messaging key');
        }
        const decryptedPrivateKeyHex = await decrypt(primaryDerivedKey.messagingPrivateKey, encryptedKeyHex);
        return keygen(decryptedPrivateKeyHex);
    }
    /**
     * Generate a key pair for an access group. This is used to encrypt and
     * decrypt group messages.
     *
     * @param groupName the plaintext name of the group chat
     * @param options.messagingPrivateKey the optional messaging private key
     * @returns a promise that resolves to the new key info.
     */
    async accessGroupStandardDerivation(groupName) {
        const { primaryDerivedKey } = (await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getCurrentUser).call(this)) ?? {};
        if (!primaryDerivedKey?.messagingPrivateKey) {
            // This *should* never happen, but just in case we throw here to surface any bugs.
            throw new Error('Cannot derive access group without a messaging key');
        }
        const keys = deriveAccessGroupKeyPair(primaryDerivedKey?.messagingPrivateKey, groupName);
        const publicKeyBase58Check = publicKeyToBase58Check(keys.public, {
            network: __classPrivateFieldGet(this, _Identity_network, "f"),
        });
        return {
            AccessGroupPrivateKeyHex: keys.seedHex,
            AccessGroupPublicKeyBase58Check: publicKeyBase58Check,
            AccessGroupKeyName: groupName,
        };
    }
    /**
     * Get a jwt token signed by the derived key issued to the currently active user. This can be used to pass to
     * authenticated endpoints on the DeSo backend api or to create authenticated endpoints on your own backend.
     * Typically this will be used to construct an Authorization header or pass as a parameter in a post body.
     *
     * @example
     * ```typescript
     * const token = await identity.jwt();
     *
     * const authHeaders = {
     *   Authorization: `Bearer ${token}`,
     * }
     *
     * myApiClient.post('https://myapi.com/some-authenticated-endpoint', { ...data }, { headers: authHeaders });
     * ```
     */
    async jwt() {
        const { primaryDerivedKey } = (await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getCurrentUser).call(this)) ?? {};
        if (!primaryDerivedKey?.derivedSeedHex) {
            // This *should* never happen, but just in case we throw here to surface any bugs.
            throw new Error('Cannot sign jwt without a derived seed hex');
        }
        return await getSignedJWT(primaryDerivedKey.derivedSeedHex, __classPrivateFieldGet(this, _Identity_jwtAlgorithm, "f"), {
            derivedPublicKeyBase58Check: primaryDerivedKey.derivedPublicKeyBase58Check,
            expiration: 60 * 10,
        });
    }
    /**
     * This method will open a new identity window with a options for getting deso
     * by verifying a phone number or buying/transferring deso anonymously for the
     * currently logged in user. NOTE: A user must already be logged in to use
     * this method.
     *
     * @example
     * ```typescript
     * await identity.getDeso();
     * ```
     */
    async getDeso() {
        const event = NOTIFICATION_EVENTS.GET_FREE_DESO_START;
        const state = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getState).call(this);
        __classPrivateFieldGet(this, _Identity_subscribers, "f").forEach((s) => s({ event, ...state }));
        return await new Promise((resolve, reject) => {
            const activePublicKey = __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getActivePublicKey).call(this);
            const launchIdentity = (activePublicKey) => {
                __classPrivateFieldSet(this, _Identity_pendingWindowRequest, { resolve, reject, event }, "f");
                if (!activePublicKey) {
                    __classPrivateFieldGet(this, _Identity_pendingWindowRequest, "f").reject(new Error('Cannot get free deso without a logged in user'));
                    return;
                }
                __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_launchIdentity).call(this, 'get-deso', {
                    publicKey: activePublicKey,
                    getFreeDeso: true,
                    showSkip: __classPrivateFieldGet(this, _Identity_showSkip, "f"),
                });
            };
            // NOTE: in the case of a browser context, we are using synchronous local
            // storage, We cannot introduce any async operations because it may
            // trigger popup blockers, which is why we need to branch the logic like
            // this.
            if (typeof activePublicKey === 'string' || activePublicKey === null) {
                launchIdentity(activePublicKey);
            }
            else {
                activePublicKey?.then(launchIdentity);
            }
        });
    }
    /**
     * This method is very similar to getDeso, but it will only present the option
     * for verifying a phone number to get deso. Also requires a user to be logged in.
     *
     * @example
     * ```typescript
     * await identity.verifyPhoneNumber();
     * ```
     */
    async verifyPhoneNumber() {
        const event = NOTIFICATION_EVENTS.VERIFY_PHONE_NUMBER_START;
        const state = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getState).call(this);
        __classPrivateFieldGet(this, _Identity_subscribers, "f").forEach((s) => s({ event, ...state }));
        return await new Promise((resolve, reject) => {
            const activePublicKey = __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getActivePublicKey).call(this);
            const launchIdentity = (activePublicKey) => {
                __classPrivateFieldSet(this, _Identity_pendingWindowRequest, { resolve, reject, event }, "f");
                if (!activePublicKey) {
                    __classPrivateFieldGet(this, _Identity_pendingWindowRequest, "f").reject(new Error('Cannon verify phone number without an active user'));
                }
                __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_launchIdentity).call(this, 'verify-phone-number', {
                    public_key: activePublicKey,
                    showSkip: __classPrivateFieldGet(this, _Identity_showSkip, "f"),
                });
            };
            // NOTE: in the case of a browser context, we are using synchronous local
            // storage, We cannot introduce any async operations because it may
            // trigger popup blockers, which is why we need to branch the logic like
            // this.
            if (typeof activePublicKey === 'string' || activePublicKey === null) {
                launchIdentity(activePublicKey);
            }
            else {
                activePublicKey?.then(launchIdentity);
            }
        });
    }
    /**
     * This method will set the currently active user. This is useful for changing
     * accounts when a user has logged into an application with multiple accounts.
     * NOTE: This method will not trigger a login event, but, rather, it will do a
     * lookup on all the users that have already been logged in to find the user
     * with the matching public key.  If the key is not found, it will throw an
     * error. The users that are available to be set as active are provided via
     * the `alternateUsers` property on the state object.
     *
     * @example
     * ```typescript
     * identity.setActiveUser(someLoggedInPublicKey);
     * ```
     */
    setActiveUser(publicKey) {
        const maybePromise = __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_setActiveUser).call(this, publicKey);
        if (typeof maybePromise?.then === 'function') {
            // we're in async storage mode
            return maybePromise.then(() => {
                const snapshotPromise = this.snapshot();
                return snapshotPromise.then((state) => {
                    this.refreshDerivedKeyPermissions();
                    __classPrivateFieldGet(this, _Identity_subscribers, "f").forEach((s) => s({
                        event: NOTIFICATION_EVENTS.CHANGE_ACTIVE_USER,
                        ...state,
                    }));
                });
            });
        }
        // sync storage
        const state = __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getState).call(this);
        this.refreshDerivedKeyPermissions();
        __classPrivateFieldGet(this, _Identity_subscribers, "f").forEach((s) => s({
            event: NOTIFICATION_EVENTS.CHANGE_ACTIVE_USER,
            ...state,
        }));
        return undefined;
    }
    /**
     * Reloads the derived key permissions for the active user. NOTE: In general
     * consumers should not need to call this directly, but it is exposed for
     * advanced use cases. We call this internally any time derived key
     * permissions are updated, a transaction is submitted, or the logged in user
     * changes.
     * @returns void
     */
    async refreshDerivedKeyPermissions() {
        const { primaryDerivedKey } = (await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getCurrentUser).call(this)) ?? {};
        if (primaryDerivedKey == null ||
            primaryDerivedKey.derivedKeyRegistered === false) {
            // if we don't have a logged in user, we just bail
            return;
        }
        try {
            const resp = await __classPrivateFieldGet(this, _Identity_api, "f").get(`${__classPrivateFieldGet(this, _Identity_nodeURI, "f")}/api/v0/get-single-derived-key/${primaryDerivedKey.publicKeyBase58Check}/${primaryDerivedKey.derivedPublicKeyBase58Check}`);
            await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_updateUser).call(this, primaryDerivedKey.publicKeyBase58Check, {
                primaryDerivedKey: {
                    ...primaryDerivedKey,
                    transactionSpendingLimits: resp.DerivedKey?.TransactionSpendingLimit ?? null,
                    IsValid: !!resp.DerivedKey?.IsValid,
                },
            });
        }
        catch (e) {
            // TODO: handle this better?
            if (__classPrivateFieldGet(this, _Identity_window, "f").location.hostname === 'localhost') {
                console.error(e);
            }
        }
    }
    /**
     * Use this in a browser context where localStorage is used as the storage
     * provider, and it is necessary to check permissions synchronously to prevent
     * issues with pop up blockers. If a user's derived key has the permissions to
     * perform a given action or batch of actions. The permissions are passed in
     * as an object with the same shape as the
     * `TransactionSpendingLimitResponseOptions` type, which is the same as the
     * `spendingLimitOptions` passed to the configure method.
     *
     *
     * @example
     * Here we check if the user has the permissions to submit at least 1 post.
     *
     * ```typescript
     * const hasPermissions = identity.hasPermissions({
     *   TransactionCountLimitMap: {
     *     SUBMIT_POST: 1,
     *    },
     * });
     * ```
     */
    hasPermissions(permissionsToCheck) {
        if (Object.keys(permissionsToCheck).length === 0) {
            throw new Error('You must pass at least one permission to check');
        }
        const users = __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getUsers).call(this);
        const checkPermissions = (users, activeKey) => {
            if (!(users && activeKey)) {
                return false;
            }
            const activeUser = users[activeKey];
            const { primaryDerivedKey } = activeUser ?? {};
            // If the key is expired, unauthorized, or has no money we can't do anything with it
            if (!primaryDerivedKey?.IsValid ||
                primaryDerivedKey?.derivedKeyRegistered === false) {
                return false;
            }
            // if the key has no spending limits, we can't do anything with it
            if (!primaryDerivedKey?.transactionSpendingLimits) {
                return false;
            }
            return compareTransactionSpendingLimits(permissionsToCheck, primaryDerivedKey.transactionSpendingLimits);
        };
        if (typeof users?.then === 'function') {
            // async mode
            return Promise.all([users, __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getActivePublicKey).call(this)]).then(([users, activeKey]) => checkPermissions(users, activeKey));
        }
        else {
            // sync mode
            const activeKey = __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getActivePublicKey).call(this);
            return checkPermissions(users, activeKey);
        }
    }
    /**
     * This method will request permissions from the user to perform an action or
     * batch of actions. It will open an identity window and prompt the user to
     * approve the permissions requested. It also takes a
     * `TransactionSpendingLimitResponseOptions` object.
     *
     * @example
     *
     * ```typescript
     * await identity.requestPermissions({
     *   TransactionCountLimitMap: {
     *     SUBMIT_POST: 'UNLIMITED',
     *    },
     * });
     * ```
     */
    async requestPermissions(transactionSpendingLimitResponse) {
        const { primaryDerivedKey } = (await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getCurrentUser).call(this)) ?? {};
        if (primaryDerivedKey == null) {
            throw new Error('Cannot request permissions without a logged in user');
        }
        const { publicKeyBase58Check, derivedPublicKeyBase58Check } = primaryDerivedKey;
        return await this.derive(transactionSpendingLimitResponse, {
            ownerPublicKey: publicKeyBase58Check,
            derivedPublicKey: derivedPublicKeyBase58Check,
            expirationDays: __classPrivateFieldGet(this, _Identity_defaultNumDaysBeforeExpiration, "f"),
        });
    }
    /**
     * This method will issue a derive request to identity which can be used to
     * either create a new derived key or to update an existing derived key.  It
     * will open an identity window and prompt the user to approve the action for
     * the derived key. It optionally take an existing derived key and/or an owner
     * public key. If the owner key is not provided, the user will first be asked
     * to login or create an account. Otherwise the user will be prompted with the
     * derived key approval window immediately. If a derived key is not provided,
     * a new one will be created.
     *
     * @example
     *
     * ```typescript
     * await identity.derive({
     *   TransactionCountLimitMap: {
     *     SUBMIT_POST: 'UNLIMITED',
     *    },
     * }, {
     * });
     * ```
     */
    async derive(transactionSpendingLimitResponse, options) {
        const event = NOTIFICATION_EVENTS.REQUEST_PERMISSIONS_START;
        const state = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getState).call(this);
        __classPrivateFieldGet(this, _Identity_subscribers, "f").forEach((s) => s({ event, ...state }));
        return await new Promise((resolve, reject) => {
            __classPrivateFieldSet(this, _Identity_pendingWindowRequest, { resolve, reject, event }, "f");
            const params = {
                derive: true,
                ...(!!options?.derivedPublicKey && {
                    derivedPublicKey: options.derivedPublicKey,
                }),
                ...(!!options?.expirationDays && {
                    expirationDays: options.expirationDays,
                }),
                ...(!!options?.deleteKey && {
                    deleteKey: options.deleteKey,
                }),
                ...(!!options?.ownerPublicKey && { publicKey: options.ownerPublicKey }),
                transactionSpendingLimitResponse: buildTransactionSpendingLimitResponse(transactionSpendingLimitResponse),
                showSkip: __classPrivateFieldGet(this, _Identity_showSkip, "f"),
            };
            __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_launchIdentity).call(this, 'derive', params);
        });
    }
    desoAddressToEthereumAddress(address) {
        const desoPKBytes = bs58PublicKeyToBytes(address).slice(1);
        const ethPKHex = ecUtils.bytesToHex(keccak_256(desoPKBytes)).slice(24);
        // EIP-55 requires a checksum. Reference implementation: https://eips.ethereum.org/EIPS/eip-55
        const checksum = ecUtils.bytesToHex(keccak_256(ethPKHex));
        return Array.from(ethPKHex).reduce((ethAddress, char, index) => ethAddress +
            (parseInt(checksum[index], 16) >= 8 ? char.toUpperCase() : char), '0x');
    }
    // TODO: make sure this works and write a test for it...
    async ethereumAddressToDesoAddress(address) {
        if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
            throw new Error('Invalid Ethereum address');
        }
        const transactions = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getETHTransactionsSignedByAddress).call(this, address);
        if (transactions.length === 0) {
            throw new Error(`ETH address must sign at least one transaction in order to recover its public key: ${address}`);
        }
        const ethNet = DESO_NETWORK_TO_ETH_NETWORK[__classPrivateFieldGet(this, _Identity_network, "f")];
        let ethereumPublicKey = '';
        for (const { hash } of transactions) {
            try {
                const resp = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_queryETHRPC).call(this, {
                    Method: 'eth_getTransactionByHash',
                    Params: [hash],
                    UseNetwork: ethNet,
                });
                const txn = resp.result;
                const signature = ethers.utils.joinSignature({
                    r: txn.r,
                    s: txn.s,
                    v: parseInt(txn.v, 16),
                });
                // Special thanks for this answer on ethereum.stackexchange.com: https://ethereum.stackexchange.com/a/126308
                let txnData;
                // TODO: figure out how to handle AccessList (type 1) transactions.
                switch (parseInt(txn.type, 16)) {
                    case 0:
                        txnData = {
                            gasPrice: txn.gasPrice,
                            gasLimit: txn.gas,
                            value: txn.value,
                            nonce: parseInt(txn.nonce, 16),
                            data: txn.input,
                            chainId: parseInt(txn.chainId ? txn.chainId : ethNet === 'goerli' ? '0x5' : '0x1', 16),
                            to: txn.to,
                        };
                        break;
                    case 2:
                        txnData = {
                            gasLimit: txn.gas,
                            value: txn.value,
                            nonce: parseInt(txn.nonce, 16),
                            data: txn.input,
                            chainId: parseInt(txn.chainId ? txn.chainId : ethNet === 'goerli' ? '0x5' : '0x1', 16),
                            to: txn.to,
                            type: 2,
                            maxFeePerGas: txn.maxFeePerGas,
                            maxPriorityFeePerGas: txn.maxPriorityFeePerGas,
                        };
                        break;
                    default:
                        throw new Error('Unsupported txn type');
                }
                const rstxn = await ethers.utils.resolveProperties(txnData);
                const raw = ethers.utils.serializeTransaction(rstxn); // returns RLP encoded transactionHash
                const msgHash = ethers.utils.keccak256(raw); // as specified by ECDSA
                const msgBytes = ethers.utils.arrayify(msgHash); // create binary hash
                const recoveredPubKey = ethers.utils.recoverPublicKey(msgBytes, signature);
                const recoveredAddress = ethers.utils.computeAddress(recoveredPubKey);
                if (recoveredAddress.toLowerCase() !== address.toLowerCase()) {
                    throw new Error(`recovered address ${recoveredAddress} does not match expected address ${address}`);
                }
                ethereumPublicKey = recoveredPubKey.slice(2);
                // break out of the loop for the first successful recovery
                break;
            }
            catch (e) {
                // log the error but keep looking
                console.error(`error recovering public key from txn: ${hash}`, e);
            }
        }
        if (!ethereumPublicKey) {
            throw new Error(`failed to recover public key for eth address: ${address}`);
        }
        const compressedEthKey = Point.fromHex(ethereumPublicKey).toRawBytes(true);
        return publicKeyToBase58Check(compressedEthKey, { network: __classPrivateFieldGet(this, _Identity_network, "f") });
    }
    /**
     * Method to handle the redirect URI from the identity service. Typically this
     * would be useful in a mobile context where the user is redirected back to
     * the app after completing the identity flow.
     */
    handleRedirectURI(redirectURI) {
        // Check if the URL contains identity query params at startup
        const query = redirectURI.split('?')[1];
        const queryParams = new URLSearchParams(query);
        if (queryParams.get('service') === IDENTITY_SERVICE_VALUE) {
            const initialResponse = parseQueryParams(queryParams);
            // Strip the identity query params from the URL. replaceState removes it from browser history
            __classPrivateFieldGet(this, _Identity_window, "f").history?.replaceState({}, '', __classPrivateFieldGet(this, _Identity_window, "f").location.pathname);
            __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_handleIdentityResponse).call(this, initialResponse);
        }
        setTimeout(() => {
            if (!__classPrivateFieldGet(this, _Identity_didConfigure, "f")) {
                this.refreshDerivedKeyPermissions();
            }
        }, 50);
    }
}
_Identity_window = new WeakMap(), _Identity_api = new WeakMap(), _Identity_identityURI = new WeakMap(), _Identity_network = new WeakMap(), _Identity_nodeURI = new WeakMap(), _Identity_identityPopupWindow = new WeakMap(), _Identity_redirectURI = new WeakMap(), _Identity_pendingWindowRequest = new WeakMap(), _Identity_defaultTransactionSpendingLimit = new WeakMap(), _Identity_appName = new WeakMap(), _Identity_jwtAlgorithm = new WeakMap(), _Identity_defaultGroupName = new WeakMap(), _Identity_boundPostMessageListener = new WeakMap(), _Identity_subscribers = new WeakMap(), _Identity_didConfigure = new WeakMap(), _Identity_isBrowser = new WeakMap(), _Identity_identityPresenter = new WeakMap(), _Identity_storageProvider = new WeakMap(), _Identity_showSkip = new WeakMap(), _Identity_isAutoDeriveLogin = new WeakMap(), _Identity_defaultNumDaysBeforeExpiration = new WeakMap(), _Identity_instances = new WeakSet(), _Identity_getState = function _Identity_getState() {
    const users = __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getUsers).call(this);
    const constructState = (users, activePublicKey) => {
        const currentUser = activePublicKey && users && (users[activePublicKey] ?? null);
        const alternateUsers = users &&
            Object.keys(users).reduce((res, publicKey) => {
                if (publicKey !== activePublicKey) {
                    res[publicKey] = users?.[publicKey];
                }
                return res;
            }, {});
        return {
            currentUser,
            alternateUsers: Object.keys(alternateUsers ?? {})?.length
                ? alternateUsers
                : null,
        };
    };
    if (typeof users?.then === 'function') {
        // we're in async mode
        return Promise.all([users, __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getActivePublicKey).call(this)]).then((args) => constructState(...args));
    }
    else {
        // we're in sync mode
        const activePublicKey = __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getActivePublicKey).call(this);
        return constructState(users, activePublicKey);
    }
}, _Identity_getActivePublicKey = function _Identity_getActivePublicKey() {
    if (!__classPrivateFieldGet(this, _Identity_storageProvider, "f")) {
        throw new Error('No storage provider available.');
    }
    const activePublicKey = __classPrivateFieldGet(this, _Identity_storageProvider, "f").getItem(LOCAL_STORAGE_KEYS.activePublicKey);
    if (typeof activePublicKey === 'string' || activePublicKey === null) {
        return activePublicKey;
    }
    return activePublicKey;
}, _Identity_getUsers = function _Identity_getUsers() {
    if (!__classPrivateFieldGet(this, _Identity_storageProvider, "f")) {
        throw new Error('No storage provider available.');
    }
    const storedUsers = __classPrivateFieldGet(this, _Identity_storageProvider, "f").getItem(LOCAL_STORAGE_KEYS.identityUsers);
    if (typeof storedUsers === 'string' || storedUsers === null) {
        return storedUsers && JSON.parse(storedUsers);
    }
    return storedUsers.then((users) => users && JSON.parse(users));
}, _Identity_getCurrentUser = function _Identity_getCurrentUser() {
    const activePublicKey = __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getActivePublicKey).call(this);
    if (typeof activePublicKey === 'string' || activePublicKey === null) {
        if (!activePublicKey)
            return null;
        // we know we're dealing with sync storage
        const users = __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getUsers).call(this);
        const currentUser = users?.[activePublicKey] ?? null;
        return currentUser;
    }
    // we assume we're dealing with async storage if we make it here
    return Promise.all([activePublicKey, __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getUsers).call(this)]).then(([publicKey, users]) => {
        if (!publicKey)
            return null;
        return users?.[publicKey] ?? null;
    });
}, _Identity_queryETHRPC = async function _Identity_queryETHRPC(params) {
    return await __classPrivateFieldGet(this, _Identity_api, "f").post(`${__classPrivateFieldGet(this, _Identity_nodeURI, "f")}/api/v0/query-eth-rpc`, params);
}, _Identity_getETHTransactionsSignedByAddress = async function _Identity_getETHTransactionsSignedByAddress(address) {
    if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
        throw new Error('Invalid Ethereum address');
    }
    const resp = (await __classPrivateFieldGet(this, _Identity_api, "f").get(`${__classPrivateFieldGet(this, _Identity_nodeURI, "f")}/api/v0/get-eth-transactions-for-eth-address/${address}?eth_network=${DESO_NETWORK_TO_ETH_NETWORK[__classPrivateFieldGet(this, _Identity_network, "f")]}`));
    if (resp.status !== '1' || !resp.message.startsWith('OK')) {
        throw new Error(`Error fetching ETH transactions for address ${address}: ${resp.message}`);
    }
    return resp.result.filter((tx) => tx.from.toLowerCase() === address.toLowerCase());
}, _Identity_authorizeDerivedKey = 
/**
 * @private
 */
async function _Identity_authorizeDerivedKey(params) {
    return await __classPrivateFieldGet(this, _Identity_api, "f").post(`${__classPrivateFieldGet(this, _Identity_nodeURI, "f")}/api/v0/authorize-derived-key`, params);
}, _Identity_setActiveUser = function _Identity_setActiveUser(publicKey) {
    const users = __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getUsers).call(this);
    const updateActiveKey = (users, newActivePublicKey) => {
        if (!(newActivePublicKey && users?.[newActivePublicKey])) {
            throw new Error(`No user found for public key. Stored users: ${JSON.stringify(users ?? {})}`);
        }
        if (!__classPrivateFieldGet(this, _Identity_storageProvider, "f")) {
            throw new Error('No storage provider available. Did you forget to configure a storageProvider?');
        }
        return __classPrivateFieldGet(this, _Identity_storageProvider, "f").setItem(LOCAL_STORAGE_KEYS.activePublicKey, newActivePublicKey);
    };
    if (typeof users?.then === 'function') {
        return users.then((users) => updateActiveKey(users, publicKey));
    }
    else {
        return updateActiveKey(users, publicKey);
    }
}, _Identity_getErrorType = function _Identity_getErrorType(e) {
    if (e?.message?.indexOf('Total input 0 is not sufficient to cover the spend amount') >= 0) {
        return ERROR_TYPES.NO_MONEY;
    }
    return undefined;
}, _Identity_authorizePrimaryDerivedKey = 
/**
 * @private
 */
async function _Identity_authorizePrimaryDerivedKey(ownerPublicKey) {
    const state1 = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getState).call(this);
    __classPrivateFieldGet(this, _Identity_subscribers, "f").forEach((s) => s({
        event: NOTIFICATION_EVENTS.AUTHORIZE_DERIVED_KEY_START,
        ...state1,
    }));
    const users = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getUsers).call(this);
    const primaryDerivedKey = users?.[ownerPublicKey]?.primaryDerivedKey;
    if (primaryDerivedKey == null) {
        throw new Error(`No primary derived key found for user ${ownerPublicKey}`);
    }
    const trimmedAppName = __classPrivateFieldGet(this, _Identity_appName, "f").trim();
    const Memo = trimmedAppName.length > 0
        ? trimmedAppName
        : __classPrivateFieldGet(this, _Identity_window, "f").location?.hostname ?? 'unknown';
    const resp = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_authorizeDerivedKey).call(this, {
        OwnerPublicKeyBase58Check: primaryDerivedKey.publicKeyBase58Check,
        DerivedPublicKeyBase58Check: primaryDerivedKey.derivedPublicKeyBase58Check,
        ExpirationBlock: primaryDerivedKey.expirationBlock,
        AccessSignature: primaryDerivedKey.accessSignature,
        DeleteKey: false,
        DerivedKeySignature: false,
        MinFeeRateNanosPerKB: 1000,
        TransactionSpendingLimitHex: primaryDerivedKey.transactionSpendingLimitHex,
        Memo,
        AppName: __classPrivateFieldGet(this, _Identity_appName, "f"),
        TransactionFees: [],
        ExtraData: {},
    });
    const signedTx = await this.signTx(resp.TransactionHex);
    const result = await this.submitTx(signedTx);
    const state2 = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getState).call(this);
    __classPrivateFieldGet(this, _Identity_subscribers, "f").forEach((s) => s({
        event: NOTIFICATION_EVENTS.AUTHORIZE_DERIVED_KEY_END,
        ...state2,
    }));
    return result;
}, _Identity_handlePostMessage = function _Identity_handlePostMessage(ev) {
    if (ev.origin !== __classPrivateFieldGet(this, _Identity_identityURI, "f") ||
        ev.data.service !== IDENTITY_SERVICE_VALUE ||
        ev.source === null) {
        return;
    }
    if (ev.data.method === 'initialize') {
        ev.source.postMessage({
            id: ev.data.id,
            service: IDENTITY_SERVICE_VALUE,
            payload: {
                appName: __classPrivateFieldGet(this, _Identity_appName, "f"),
            },
        }, __classPrivateFieldGet(this, _Identity_identityURI, "f"));
    }
    else {
        __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_handleIdentityResponse).call(this, ev.data);
        __classPrivateFieldGet(this, _Identity_identityPopupWindow, "f")?.close();
        if (__classPrivateFieldGet(this, _Identity_boundPostMessageListener, "f") != null) {
            __classPrivateFieldGet(this, _Identity_window, "f").removeEventListener('message', __classPrivateFieldGet(this, _Identity_boundPostMessageListener, "f"));
        }
        __classPrivateFieldSet(this, _Identity_boundPostMessageListener, undefined, "f");
    }
}, _Identity_handleIdentityResponse = function _Identity_handleIdentityResponse({ method, payload = {} }) {
    switch (method) {
        case 'derive':
            __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_handleDeriveMethod).call(this, payload)
                .then(async (res) => {
                const state = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getState).call(this);
                __classPrivateFieldGet(this, _Identity_subscribers, "f").forEach((s) => s({
                    event: __classPrivateFieldGet(this, _Identity_pendingWindowRequest, "f")?.event ===
                        NOTIFICATION_EVENTS.LOGIN_START
                        ? NOTIFICATION_EVENTS.LOGIN_END
                        : NOTIFICATION_EVENTS.REQUEST_PERMISSIONS_END,
                    ...state,
                }));
                __classPrivateFieldGet(this, _Identity_pendingWindowRequest, "f")?.resolve(res);
            })
                .catch(async (e) => {
                // if we're in a login flow just don't let the user log in if we
                // can't authorize their derived key.  we've already stored the user
                // in local storage before attempting to authorize, so we remove
                // their data.
                const currentUser = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getCurrentUser).call(this);
                const showSkipAndNoMoney = (__classPrivateFieldGet(this, _Identity_showSkip, "f") || __classPrivateFieldGet(this, _Identity_isAutoDeriveLogin, "f")) &&
                    e.message.indexOf('RuleErrorInsufficientBalance') >= 0;
                if (showSkipAndNoMoney && currentUser != null) {
                    await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_updateUser).call(this, currentUser.publicKey, {
                        primaryDerivedKey: {
                            ...currentUser.primaryDerivedKey,
                            ...payload,
                            derivedKeyRegistered: false,
                        },
                    });
                    await __classPrivateFieldGet(this, _Identity_storageProvider, "f").setItem(LOCAL_STORAGE_KEYS.activePublicKey, currentUser.publicKey);
                }
                else if (__classPrivateFieldGet(this, _Identity_pendingWindowRequest, "f")?.event ===
                    NOTIFICATION_EVENTS.LOGIN_START &&
                    currentUser != null) {
                    __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_purgeUserDataForPublicKey).call(this, currentUser.publicKey);
                    if (!__classPrivateFieldGet(this, _Identity_storageProvider, "f")) {
                        throw new Error('No storage provider available.');
                    }
                    await __classPrivateFieldGet(this, _Identity_storageProvider, "f").removeItem(LOCAL_STORAGE_KEYS.activePublicKey);
                }
                const state = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getState).call(this);
                __classPrivateFieldGet(this, _Identity_subscribers, "f").forEach((s) => s({
                    event: NOTIFICATION_EVENTS.AUTHORIZE_DERIVED_KEY_FAIL,
                    ...state,
                }));
                // propagate the error to the external caller
                __classPrivateFieldGet(this, _Identity_pendingWindowRequest, "f")?.reject(__classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getErrorInstance).call(this, e));
            });
            break;
        case 'login':
            __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_handleLoginMethod).call(this, payload).catch((e) => {
                // propagate any error to the external caller
                __classPrivateFieldGet(this, _Identity_pendingWindowRequest, "f")?.reject(__classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getErrorInstance).call(this, e));
            });
            break;
        default:
            throw new Error(`Unknown method: ${method}`);
    }
}, _Identity_handleLoginMethod = 
/**
 * @private
 */
async function _Identity_handleLoginMethod(payload) {
    const activePublicKey = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getActivePublicKey).call(this);
    // NOTE: this is a bit counterintuitive, but a missing publicKeyAdded
    // identifies this as a logout (even though the method is 'login').
    if (!payload.publicKeyAdded) {
        if (!activePublicKey) {
            throw new Error('No active public key found');
        }
        if (!__classPrivateFieldGet(this, _Identity_storageProvider, "f")) {
            throw new Error('No storage provider available.');
        }
        await __classPrivateFieldGet(this, _Identity_storageProvider, "f").removeItem(LOCAL_STORAGE_KEYS.activePublicKey);
        await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_purgeUserDataForPublicKey).call(this, activePublicKey);
        const state = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getState).call(this);
        __classPrivateFieldGet(this, _Identity_subscribers, "f").forEach((s) => s({
            event: NOTIFICATION_EVENTS.LOGOUT_END,
            ...state,
        }));
        __classPrivateFieldGet(this, _Identity_pendingWindowRequest, "f")?.resolve(payload);
    }
    else if (payload.publicKeyAdded &&
        !payload.signedUp &&
        payload.publicKeyAdded === activePublicKey) {
        let endEvent;
        const startEvent = __classPrivateFieldGet(this, _Identity_pendingWindowRequest, "f")?.event;
        if (startEvent === NOTIFICATION_EVENTS.GET_FREE_DESO_START) {
            endEvent = NOTIFICATION_EVENTS.GET_FREE_DESO_END;
        }
        else if (startEvent === NOTIFICATION_EVENTS.VERIFY_PHONE_NUMBER_START) {
            endEvent = NOTIFICATION_EVENTS.VERIFY_PHONE_NUMBER_END;
        }
        else if (startEvent === NOTIFICATION_EVENTS.LOGIN_START) {
            endEvent = NOTIFICATION_EVENTS.LOGIN_END;
        }
        else {
            throw new Error(`unexpected identity event: ${startEvent}`);
        }
        __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_authorizePrimaryDerivedKey).call(this, payload.publicKeyAdded)
            .then(async () => {
            __classPrivateFieldGet(this, _Identity_pendingWindowRequest, "f")?.resolve(payload);
            const state = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getState).call(this);
            __classPrivateFieldGet(this, _Identity_subscribers, "f").forEach((s) => s({ event: endEvent, ...state }));
        })
            .catch(async (e) => {
            const state = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getState).call(this);
            __classPrivateFieldGet(this, _Identity_subscribers, "f").forEach((s) => s({
                event: NOTIFICATION_EVENTS.AUTHORIZE_DERIVED_KEY_FAIL,
                ...state,
            }));
            __classPrivateFieldGet(this, _Identity_pendingWindowRequest, "f")?.reject(__classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getErrorInstance).call(this, e));
        });
        // This condition identifies the legacy non derived key login flow.
        // We default to derived key login, but the legacy flow can be enabled
        // to support simple gated content: https://github.com/deso-protocol/deso-js/issues/1
    }
    else if (payload.publicKeyAdded) {
        await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_updateUser).call(this, payload.publicKeyAdded, payload.users[payload.publicKeyAdded]);
        __classPrivateFieldGet(this, _Identity_pendingWindowRequest, "f")?.resolve(payload);
        await __classPrivateFieldGet(this, _Identity_storageProvider, "f").setItem(LOCAL_STORAGE_KEYS.activePublicKey, payload.publicKeyAdded);
        const state = await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getState).call(this);
        __classPrivateFieldGet(this, _Identity_subscribers, "f").forEach((s) => s({ event: NOTIFICATION_EVENTS.LOGIN_END, ...state }));
    }
    else {
        // not sure how we would get here, but lets log it just in case we haven't actually
        // handled all the cases.
        console.warn('unhandled identity login payload', payload);
    }
}, _Identity_purgeUserDataForPublicKey = 
/**
 * @private
 */
async function _Identity_purgeUserDataForPublicKey(publicKey) {
    if (!__classPrivateFieldGet(this, _Identity_storageProvider, "f")) {
        throw new Error('No storage provider is available.');
    }
    const users = await __classPrivateFieldGet(this, _Identity_storageProvider, "f").getItem(LOCAL_STORAGE_KEYS.identityUsers);
    if (users) {
        const usersObj = JSON.parse(users);
        delete usersObj[publicKey];
        if (Object.keys(usersObj).length === 0) {
            await __classPrivateFieldGet(this, _Identity_storageProvider, "f").removeItem(LOCAL_STORAGE_KEYS.identityUsers);
        }
        else {
            await __classPrivateFieldGet(this, _Identity_storageProvider, "f").setItem(LOCAL_STORAGE_KEYS.identityUsers, JSON.stringify(usersObj));
        }
    }
}, _Identity_handleDeriveMethod = 
/**
 * @private
 */
async function _Identity_handleDeriveMethod(payload) {
    const { primaryDerivedKey } = (await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getCurrentUser).call(this)) ?? {};
    // NOTE: If we generated the keys and provided the derived public key,
    // identity will respond with an empty string in the derivedSeedHex field.
    // We don't want to inadvertently overwrite our derived seed hex with the
    // empty string, so we delete the field if it's empty.
    if (payload.derivedSeedHex === '') {
        delete payload.derivedSeedHex;
    }
    if (!__classPrivateFieldGet(this, _Identity_storageProvider, "f")) {
        throw new Error('No storage provider is available.');
    }
    // we may or may not have a login key pair in localStorage. If we do, it means we
    // initiated a login flow.
    const maybeLoginKeyPair = await __classPrivateFieldGet(this, _Identity_storageProvider, "f").getItem(LOCAL_STORAGE_KEYS.loginKeyPair);
    // in the case of a login, we always clean up the login key pair from localStorage.
    await __classPrivateFieldGet(this, _Identity_storageProvider, "f").removeItem(LOCAL_STORAGE_KEYS.loginKeyPair);
    // This means we're doing a derived key permissions upgrade for the current user (not a login).
    if (primaryDerivedKey != null &&
        primaryDerivedKey.publicKeyBase58Check === payload.publicKeyBase58Check &&
        primaryDerivedKey.derivedPublicKeyBase58Check ===
            payload.derivedPublicKeyBase58Check) {
        await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_updateUser).call(this, payload.publicKeyBase58Check, {
            primaryDerivedKey: { ...primaryDerivedKey, ...payload },
        });
        return await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_authorizePrimaryDerivedKey).call(this, payload.publicKeyBase58Check).then(async () => {
            const { primaryDerivedKey } = (await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getCurrentUser).call(this)) ?? {};
            await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_updateUser).call(this, payload.publicKeyBase58Check, {
                primaryDerivedKey: {
                    ...primaryDerivedKey,
                    derivedKeyRegistered: true,
                },
            });
            return payload;
        });
    }
    const [users, activePublicKey] = await Promise.all([
        __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getUsers).call(this),
        __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getActivePublicKey).call(this),
    ]);
    // This means we're just switching to a user we already have in localStorage, we use the stored user bc they
    // may already have an authorized derived key that we can use.
    if (users?.[payload.publicKeyBase58Check] != null &&
        payload.publicKeyBase58Check !== activePublicKey) {
        await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_setActiveUser).call(this, payload.publicKeyBase58Check);
        // if the logged in user changes, we try to refresh the derived key permissions in the background
        // and just return the payload immediately.
        this.refreshDerivedKeyPermissions();
        return payload;
        // This means we're logging in a user we haven't seen yet
    }
    else if (maybeLoginKeyPair) {
        const { seedHex } = JSON.parse(maybeLoginKeyPair);
        await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_updateUser).call(this, payload.publicKeyBase58Check, {
            primaryDerivedKey: {
                ...primaryDerivedKey,
                ...payload,
                derivedSeedHex: seedHex,
            },
        });
        await __classPrivateFieldGet(this, _Identity_storageProvider, "f").setItem(LOCAL_STORAGE_KEYS.activePublicKey, payload.publicKeyBase58Check);
        return await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_authorizePrimaryDerivedKey).call(this, payload.publicKeyBase58Check).then(async () => {
            const { primaryDerivedKey } = (await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getCurrentUser).call(this)) ?? {};
            await __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_updateUser).call(this, payload.publicKeyBase58Check, {
                primaryDerivedKey: {
                    ...primaryDerivedKey,
                    derivedSeedHex: seedHex,
                    derivedKeyRegistered: true,
                },
            });
            return {
                ...payload,
                publicKeyAdded: payload.publicKeyBase58Check,
            };
        });
    }
    // For all other derive flows, we just return the payload directly.
    return payload;
}, _Identity_updateUser = 
/**
 * @private
 */
async function _Identity_updateUser(masterPublicKey, attributes = {}) {
    if (!__classPrivateFieldGet(this, _Identity_storageProvider, "f")) {
        throw new Error('No storage provider is available.');
    }
    const users = await __classPrivateFieldGet(this, _Identity_storageProvider, "f").getItem(LOCAL_STORAGE_KEYS.identityUsers);
    if (users) {
        const usersObj = JSON.parse(users);
        if (!usersObj[masterPublicKey]) {
            usersObj[masterPublicKey] = {
                publicKey: masterPublicKey,
                ...attributes,
            };
        }
        else {
            usersObj[masterPublicKey] = {
                publicKey: masterPublicKey,
                ...usersObj[masterPublicKey],
                ...attributes,
            };
        }
        await __classPrivateFieldGet(this, _Identity_storageProvider, "f").setItem(LOCAL_STORAGE_KEYS.identityUsers, JSON.stringify(usersObj));
    }
    else {
        await __classPrivateFieldGet(this, _Identity_storageProvider, "f").setItem(LOCAL_STORAGE_KEYS.identityUsers, JSON.stringify({
            [masterPublicKey]: { publicKey: masterPublicKey, ...attributes },
        }));
    }
}, _Identity_buildQueryParams = function _Identity_buildQueryParams(paramsPojo) {
    const qps = new URLSearchParams(Object.entries(paramsPojo).reduce((acc, [k, v]) => {
        acc[k] =
            typeof v === 'object' && v !== null
                ? encodeURIComponent(JSON.stringify(v))
                : v;
        return acc;
    }, {}));
    if (__classPrivateFieldGet(this, _Identity_network, "f") === 'testnet') {
        qps.append('testnet', 'true');
    }
    if (__classPrivateFieldGet(this, _Identity_redirectURI, "f")) {
        qps.append('redirect_uri', __classPrivateFieldGet(this, _Identity_redirectURI, "f"));
    }
    // TODO: We can remove this feature flag once this becomes the default
    // behavior in the identity service.
    qps.append('subAccounts', 'true');
    return qps;
}, _Identity_openIdentityPopup = function _Identity_openIdentityPopup(url) {
    if (__classPrivateFieldGet(this, _Identity_identityPopupWindow, "f") != null) {
        __classPrivateFieldGet(this, _Identity_identityPopupWindow, "f").close();
    }
    const h = 1000;
    const w = 800;
    const y = __classPrivateFieldGet(this, _Identity_window, "f").outerHeight / 2 + __classPrivateFieldGet(this, _Identity_window, "f").screenY - h / 2;
    const x = __classPrivateFieldGet(this, _Identity_window, "f").outerWidth / 2 + __classPrivateFieldGet(this, _Identity_window, "f").screenX - w / 2;
    __classPrivateFieldSet(this, _Identity_identityPopupWindow, __classPrivateFieldGet(this, _Identity_window, "f").open(url, undefined, `toolbar=no, width=${w}, height=${h}, top=${y}, left=${x}`), "f");
}, _Identity_launchIdentity = function _Identity_launchIdentity(path, params) {
    const qps = __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_buildQueryParams).call(this, params);
    const url = `${__classPrivateFieldGet(this, _Identity_identityURI, "f")}/${path.replace(/^\//, '')}?${qps}`;
    // If we have a custom presenter, use that instead of the default browser APIs.
    // This would typically be used for mobile apps.
    if (typeof __classPrivateFieldGet(this, _Identity_identityPresenter, "f") === 'function') {
        __classPrivateFieldGet(this, _Identity_identityPresenter, "f").call(this, url);
        return;
    }
    if (typeof __classPrivateFieldGet(this, _Identity_window, "f").open !== 'function') {
        throw new Error('No identity presenter is available. Did you forget to configure a custom identityPresenter?');
    }
    if (qps.get('redirect_uri')) {
        __classPrivateFieldGet(this, _Identity_window, "f").location.href = url;
    }
    else {
        // if we had a previously attached listener, remove it and create a new one.
        if (__classPrivateFieldGet(this, _Identity_boundPostMessageListener, "f") != null) {
            __classPrivateFieldGet(this, _Identity_window, "f").removeEventListener('message', __classPrivateFieldGet(this, _Identity_boundPostMessageListener, "f"));
        }
        __classPrivateFieldSet(this, _Identity_boundPostMessageListener, __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_handlePostMessage).bind(this), "f");
        __classPrivateFieldGet(this, _Identity_window, "f").addEventListener('message', __classPrivateFieldGet(this, _Identity_boundPostMessageListener, "f"));
        __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_openIdentityPopup).call(this, url);
    }
}, _Identity_getErrorInstance = function _Identity_getErrorInstance(e) {
    const errorType = __classPrivateFieldGet(this, _Identity_instances, "m", _Identity_getErrorType).call(this, e);
    if (!errorType)
        return e;
    return new DeSoCoreError(e.message, errorType, e);
}, _Identity_decryptGroupChat = 
/**
 *
 * @private
 */
async function _Identity_decryptGroupChat(groups, message) {
    // ASSUMPTION: if it's a group chat, then the RECIPIENT has the group key name we need?
    const accessGroup = groups.find((g) => {
        return (g.AccessGroupKeyName === message.RecipientInfo.AccessGroupKeyName &&
            g.AccessGroupOwnerPublicKeyBase58Check ===
                message.RecipientInfo.OwnerPublicKeyBase58Check &&
            g.AccessGroupMemberEntryResponse);
    });
    if (!accessGroup?.AccessGroupMemberEntryResponse?.EncryptedKey) {
        throw new Error('access group key not found for group message');
    }
    const decryptedKeys = await this.decryptAccessGroupKeyPair(accessGroup.AccessGroupMemberEntryResponse.EncryptedKey);
    return await decryptChatMessage(decryptedKeys.seedHex, message.SenderInfo.AccessGroupPublicKeyBase58Check, message.MessageInfo.EncryptedText);
}, _Identity_decryptDM = 
/**
 * @private
 */
async function _Identity_decryptDM(userPublicKeyBase58Check, privateKeyHex, message, isSender) {
    const accessGroupInfo = isSender
        ? message.SenderInfo
        : message.RecipientInfo;
    if (message?.MessageInfo?.ExtraData &&
        message.MessageInfo.ExtraData.unencrypted) {
        return unencryptedHexToPlainText(message.MessageInfo.EncryptedText);
    }
    else {
        const isRecipient = message.RecipientInfo.OwnerPublicKeyBase58Check ===
            userPublicKeyBase58Check &&
            message.RecipientInfo.AccessGroupKeyName ===
                accessGroupInfo.AccessGroupKeyName;
        const publicDecryptionKey = isRecipient
            ? message.SenderInfo.AccessGroupPublicKeyBase58Check
            : message.RecipientInfo.AccessGroupPublicKeyBase58Check;
        return await decryptChatMessage(privateKeyHex, publicDecryptionKey, message.MessageInfo.EncryptedText);
    }
};
class DeSoCoreError extends Error {
    constructor(message, type, originalError = {}) {
        super(message);
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.assign(this, originalError);
        this.type = type;
        this.name = 'DeSoCoreError';
    }
}
const unencryptedHexToPlainText = (hex) => {
    const bytes = ecUtils.hexToBytes(hex);
    const textDecoder = new TextDecoder();
    return textDecoder.decode(bytes);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWRlbnRpdHkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvaWRlbnRpdHkvaWRlbnRpdHkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxJQUFJLE9BQU8sRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQzNELE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDaEMsT0FBTyxFQUdMLFFBQVEsR0FRVCxNQUFNLDJCQUEyQixDQUFDO0FBQ25DLE9BQU8sRUFDTCxvQkFBb0IsRUFDcEIsZ0JBQWdCLEVBQ2hCLG1CQUFtQixJQUFJLGtDQUFrQyxFQUN6RCwyQkFBMkIsRUFDM0Isc0JBQXNCLEVBQ3RCLGtCQUFrQixHQUNuQixNQUFNLGdCQUFnQixDQUFDO0FBQ3hCLE9BQU8sRUFDTCxvQkFBb0IsRUFDcEIsT0FBTyxFQUNQLGtCQUFrQixFQUNsQix3QkFBd0IsRUFDeEIsa0JBQWtCLEVBQ2xCLFlBQVksRUFDWixNQUFNLEVBQ04sc0JBQXNCLEVBQ3RCLE1BQU0sR0FDUCxNQUFNLG1CQUFtQixDQUFDO0FBQzNCLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ25FLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUMvQyxPQUFPLEVBQ0wscUNBQXFDLEVBQ3JDLGdDQUFnQyxHQUNqQyxNQUFNLHdCQUF3QixDQUFDO0FBQ2hDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzFELE9BQU8sRUFNTCxtQkFBbUIsR0FhcEIsTUFBTSxZQUFZLENBQUM7QUFFcEIsTUFBTSxPQUFPLFFBQVE7SUFtT25COzs7O09BSUc7SUFDSCxJQUFJLE9BQU87UUFDVCxPQUFPLHVCQUFBLElBQUkseUJBQVMsQ0FB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QUFJLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDbkMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLElBQUksR0FBRyxlQUFlLENBQUM7SUFDOUIsQ0FBQztDQUNGO0FBRUQsTUFBTSx5QkFBeUIsR0FBRyxDQUFDLEdBQVcsRUFBRSxFQUFFO0lBQ2hELE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdEMsTUFBTSxXQUFXLEdBQUcsSUFBSSxXQUFXLEVBQUUsQ0FBQztJQUN0QyxPQUFPLFdBQVcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDbkMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrXzI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMyc7XG5pbXBvcnQgeyBQb2ludCwgdXRpbHMgYXMgZWNVdGlscyB9IGZyb20gJ0Bub2JsZS9zZWNwMjU2azEnO1xuaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7XG4gIEFjY2Vzc0dyb3VwRW50cnlSZXNwb25zZSxcbiAgQXV0aG9yaXplRGVyaXZlZEtleVJlcXVlc3QsXG4gIENoYXRUeXBlLFxuICBEZWNyeXB0ZWRNZXNzYWdlRW50cnlSZXNwb25zZSxcbiAgSW5mdXJhUmVzcG9uc2UsXG4gIE5ld01lc3NhZ2VFbnRyeVJlc3BvbnNlLFxuICBRdWVyeUVUSFJQQ1JlcXVlc3QsXG4gIFN1Ym1pdFRyYW5zYWN0aW9uUmVzcG9uc2UsXG4gIHR5cGUgSW5mdXJhVHgsXG4gIHR5cGUgVHJhbnNhY3Rpb25TcGVuZGluZ0xpbWl0UmVzcG9uc2UsXG59IGZyb20gJy4uL2JhY2tlbmQtdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHtcbiAgREVGQVVMVF9JREVOVElUWV9VUkksXG4gIERFRkFVTFRfTk9ERV9VUkksXG4gIERFRkFVTFRfUEVSTUlTU0lPTlMgYXMgREVGQVVMVF9UUkFOU0FDVElPTl9TUEVORElOR19MSU1JVCxcbiAgREVTT19ORVRXT1JLX1RPX0VUSF9ORVRXT1JLLFxuICBJREVOVElUWV9TRVJWSUNFX1ZBTFVFLFxuICBMT0NBTF9TVE9SQUdFX0tFWVMsXG59IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7XG4gIGJzNThQdWJsaWNLZXlUb0J5dGVzLFxuICBkZWNyeXB0LFxuICBkZWNyeXB0Q2hhdE1lc3NhZ2UsXG4gIGRlcml2ZUFjY2Vzc0dyb3VwS2V5UGFpcixcbiAgZW5jcnlwdENoYXRNZXNzYWdlLFxuICBnZXRTaWduZWRKV1QsXG4gIGtleWdlbixcbiAgcHVibGljS2V5VG9CYXNlNThDaGVjayxcbiAgc2lnblR4LFxufSBmcm9tICcuL2NyeXB0by11dGlscy5qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZURlcml2ZWRLZXlQYXlsb2FkIH0gZnJvbSAnLi9kZXJpdmVkLWtleS11dGlscy5qcyc7XG5pbXBvcnQgeyBFUlJPUl9UWVBFUyB9IGZyb20gJy4vZXJyb3ItdHlwZXMuanMnO1xuaW1wb3J0IHtcbiAgYnVpbGRUcmFuc2FjdGlvblNwZW5kaW5nTGltaXRSZXNwb25zZSxcbiAgY29tcGFyZVRyYW5zYWN0aW9uU3BlbmRpbmdMaW1pdHMsXG59IGZyb20gJy4vcGVybWlzc2lvbnMtdXRpbHMuanMnO1xuaW1wb3J0IHsgcGFyc2VRdWVyeVBhcmFtcyB9IGZyb20gJy4vcXVlcnktcGFyYW0tdXRpbHMuanMnO1xuaW1wb3J0IHtcbiAgQWNjZXNzR3JvdXBQcml2YXRlSW5mbyxcbiAgRXRoZXJzY2FuVHJhbnNhY3Rpb24sXG4gIElkZW50aXR5UmVzcG9uc2UsXG4gIElkZW50aXR5U3RhdGUsXG4gIExvZ2luT3B0aW9ucyxcbiAgTk9USUZJQ0FUSU9OX0VWRU5UUyxcbiAgU3RvcmFnZVByb3ZpZGVyLFxuICB0eXBlIEFQSVByb3ZpZGVyLFxuICB0eXBlIERlZmVycmVkLFxuICB0eXBlIEV0aGVyc2NhblRyYW5zYWN0aW9uc0J5QWRkcmVzc1Jlc3BvbnNlLFxuICB0eXBlIElkZW50aXR5Q29uZmlndXJhdGlvbixcbiAgdHlwZSBJZGVudGl0eURlcml2ZVBheWxvYWQsXG4gIHR5cGUgSWRlbnRpdHlMb2dpblBheWxvYWQsXG4gIHR5cGUgTmV0d29yayxcbiAgdHlwZSBTdG9yZWRVc2VyLFxuICB0eXBlIFN1YnNjcmliZXJOb3RpZmljYXRpb24sXG4gIHR5cGUgVHJhbnNhY3Rpb25TcGVuZGluZ0xpbWl0UmVzcG9uc2VPcHRpb25zLFxuICB0eXBlIGp3dEFsZ29yaXRobSxcbn0gZnJvbSAnLi90eXBlcy5qcyc7XG5cbmV4cG9ydCBjbGFzcyBJZGVudGl0eTxUIGV4dGVuZHMgU3RvcmFnZVByb3ZpZGVyPiB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgI3dpbmRvdzogdHlwZW9mIGdsb2JhbFRoaXM7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAjYXBpOiBBUElQcm92aWRlcjtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gICNpZGVudGl0eVVSSTogc3RyaW5nID0gREVGQVVMVF9JREVOVElUWV9VUkk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAjbmV0d29yazogTmV0d29yayA9ICdtYWlubmV0JztcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gICNub2RlVVJJOiBzdHJpbmcgPSBERUZBVUxUX05PREVfVVJJO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgI2lkZW50aXR5UG9wdXBXaW5kb3c/OiBXaW5kb3cgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgI3JlZGlyZWN0VVJJPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgI3BlbmRpbmdXaW5kb3dSZXF1ZXN0PzogRGVmZXJyZWQgJiB7IGV2ZW50OiBOT1RJRklDQVRJT05fRVZFTlRTIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAjZGVmYXVsdFRyYW5zYWN0aW9uU3BlbmRpbmdMaW1pdDogVHJhbnNhY3Rpb25TcGVuZGluZ0xpbWl0UmVzcG9uc2UgPVxuICAgIERFRkFVTFRfVFJBTlNBQ1RJT05fU1BFTkRJTkdfTElNSVQ7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAjYXBwTmFtZSA9ICcnO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgI2p3dEFsZ29yaXRobTogand0QWxnb3JpdGhtID0gJ0VTMjU2JztcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gICNkZWZhdWx0R3JvdXBOYW1lID0gJ2RlZmF1bHQta2V5JztcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gICNib3VuZFBvc3RNZXNzYWdlTGlzdGVuZXI/OiAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4gdm9pZDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gICNzdWJzY3JpYmVyczogKChub3RpZmljYXRpb246IFN1YnNjcmliZXJOb3RpZmljYXRpb24pID0+IHZvaWQpW10gPSBbXTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gICNkaWRDb25maWd1cmUgPSBmYWxzZTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gICNpc0Jyb3dzZXI6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAjaWRlbnRpdHlQcmVzZW50ZXI/OiAodXJsOiBzdHJpbmcpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAjc3RvcmFnZVByb3ZpZGVyOiBUO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgI3Nob3dTa2lwID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAjaXNBdXRvRGVyaXZlTG9naW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogRGVmYXVsdHMgdG8gMTAgeWVhcnMuIFRoZXNlIGxvZ2luIGtleXMgc2hvdWxkIGVzc2VudGlhbGx5IG5ldmVyIGV4cGlyZVxuICAgKiB1bmxlc3MgYSB1c2VyIGV4cGxpY2l0bHkgZGUtYXV0aG9yaXplcyB0aGVtLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgI2RlZmF1bHROdW1EYXlzQmVmb3JlRXhwaXJhdGlvbiA9IDM2NTA7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGludGVybmFsIHN0YXRlIG9mIGlkZW50aXR5LiBUaGlzIGlzIGEgY29tYmluYXRpb24gb2YgdGhlXG4gICAqIGN1cnJlbnQgdXNlciBhbmQgYWxsIG90aGVyIHVzZXJzIHN0b3JlZCBpbiBsb2NhbCBzdG9yYWdlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgI2dldFN0YXRlKCk6IFQgZXh0ZW5kcyBTdG9yYWdlID8gSWRlbnRpdHlTdGF0ZSA6IFByb21pc2U8SWRlbnRpdHlTdGF0ZT4ge1xuICAgIGNvbnN0IHVzZXJzID0gdGhpcy4jZ2V0VXNlcnMoKTtcbiAgICBjb25zdCBjb25zdHJ1Y3RTdGF0ZSA9IChcbiAgICAgIHVzZXJzOiBSZWNvcmQ8c3RyaW5nLCBTdG9yZWRVc2VyPiB8IG51bGwsXG4gICAgICBhY3RpdmVQdWJsaWNLZXk6IHN0cmluZyB8IG51bGxcbiAgICApID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRVc2VyID1cbiAgICAgICAgYWN0aXZlUHVibGljS2V5ICYmIHVzZXJzICYmICh1c2Vyc1thY3RpdmVQdWJsaWNLZXldID8/IG51bGwpO1xuICAgICAgY29uc3QgYWx0ZXJuYXRlVXNlcnMgPVxuICAgICAgICB1c2VycyAmJlxuICAgICAgICBPYmplY3Qua2V5cyh1c2VycykucmVkdWNlPFJlY29yZDxzdHJpbmcsIFN0b3JlZFVzZXI+PihcbiAgICAgICAgICAocmVzLCBwdWJsaWNLZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChwdWJsaWNLZXkgIT09IGFjdGl2ZVB1YmxpY0tleSkge1xuICAgICAgICAgICAgICByZXNbcHVibGljS2V5XSA9ICh1c2VycyBhcyBSZWNvcmQ8c3RyaW5nLCBTdG9yZWRVc2VyPik/LltcbiAgICAgICAgICAgICAgICBwdWJsaWNLZXlcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7fVxuICAgICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50VXNlcixcbiAgICAgICAgYWx0ZXJuYXRlVXNlcnM6IE9iamVjdC5rZXlzKGFsdGVybmF0ZVVzZXJzID8/IHt9KT8ubGVuZ3RoXG4gICAgICAgICAgPyBhbHRlcm5hdGVVc2Vyc1xuICAgICAgICAgIDogbnVsbCxcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgdXNlcnM/LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIHdlJ3JlIGluIGFzeW5jIG1vZGVcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbdXNlcnMsIHRoaXMuI2dldEFjdGl2ZVB1YmxpY0tleSgpXSkudGhlbigoYXJncykgPT5cbiAgICAgICAgY29uc3RydWN0U3RhdGUoLi4uYXJncylcbiAgICAgICkgYXMgVCBleHRlbmRzIFN0b3JhZ2UgPyBJZGVudGl0eVN0YXRlIDogUHJvbWlzZTxJZGVudGl0eVN0YXRlPjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2UncmUgaW4gc3luYyBtb2RlXG4gICAgICBjb25zdCBhY3RpdmVQdWJsaWNLZXkgPSB0aGlzLiNnZXRBY3RpdmVQdWJsaWNLZXkoKSBhcyBzdHJpbmcgfCBudWxsO1xuXG4gICAgICByZXR1cm4gY29uc3RydWN0U3RhdGUoXG4gICAgICAgIHVzZXJzIGFzIFJlY29yZDxzdHJpbmcsIFN0b3JlZFVzZXI+IHwgbnVsbCxcbiAgICAgICAgYWN0aXZlUHVibGljS2V5XG4gICAgICApIGFzIFQgZXh0ZW5kcyBTdG9yYWdlID8gSWRlbnRpdHlTdGF0ZSA6IFByb21pc2U8SWRlbnRpdHlTdGF0ZT47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAjZ2V0QWN0aXZlUHVibGljS2V5KCk6IFQgZXh0ZW5kcyBTdG9yYWdlXG4gICAgPyBzdHJpbmcgfCBudWxsXG4gICAgOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICBpZiAoIXRoaXMuI3N0b3JhZ2VQcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdG9yYWdlIHByb3ZpZGVyIGF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgY29uc3QgYWN0aXZlUHVibGljS2V5ID0gdGhpcy4jc3RvcmFnZVByb3ZpZGVyLmdldEl0ZW0oXG4gICAgICBMT0NBTF9TVE9SQUdFX0tFWVMuYWN0aXZlUHVibGljS2V5XG4gICAgKTtcblxuICAgIGlmICh0eXBlb2YgYWN0aXZlUHVibGljS2V5ID09PSAnc3RyaW5nJyB8fCBhY3RpdmVQdWJsaWNLZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBhY3RpdmVQdWJsaWNLZXkgYXMgYW55O1xuICAgIH1cblxuICAgIHJldHVybiBhY3RpdmVQdWJsaWNLZXkgYXMgYW55O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAjZ2V0VXNlcnMoKTogVCBleHRlbmRzIFN0b3JhZ2VcbiAgICA/IFJlY29yZDxzdHJpbmcsIFN0b3JlZFVzZXI+IHwgbnVsbFxuICAgIDogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBTdG9yZWRVc2VyPiB8IG51bGw+IHtcbiAgICBpZiAoIXRoaXMuI3N0b3JhZ2VQcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdG9yYWdlIHByb3ZpZGVyIGF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVkVXNlcnMgPSB0aGlzLiNzdG9yYWdlUHJvdmlkZXIuZ2V0SXRlbShcbiAgICAgIExPQ0FMX1NUT1JBR0VfS0VZUy5pZGVudGl0eVVzZXJzXG4gICAgKTtcblxuICAgIGlmICh0eXBlb2Ygc3RvcmVkVXNlcnMgPT09ICdzdHJpbmcnIHx8IHN0b3JlZFVzZXJzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc3RvcmVkVXNlcnMgJiYgSlNPTi5wYXJzZShzdG9yZWRVc2Vycyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0b3JlZFVzZXJzLnRoZW4oKHVzZXJzKSA9PiB1c2VycyAmJiBKU09OLnBhcnNlKHVzZXJzKSkgYXMgYW55O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAjZ2V0Q3VycmVudFVzZXIoKTogVCBleHRlbmRzIFN0b3JhZ2VcbiAgICA/IFN0b3JlZFVzZXIgfCBudWxsXG4gICAgOiBQcm9taXNlPFN0b3JlZFVzZXIgfCBudWxsPiB7XG4gICAgY29uc3QgYWN0aXZlUHVibGljS2V5ID0gdGhpcy4jZ2V0QWN0aXZlUHVibGljS2V5KCk7XG5cbiAgICBpZiAodHlwZW9mIGFjdGl2ZVB1YmxpY0tleSA9PT0gJ3N0cmluZycgfHwgYWN0aXZlUHVibGljS2V5ID09PSBudWxsKSB7XG4gICAgICBpZiAoIWFjdGl2ZVB1YmxpY0tleSkgcmV0dXJuIG51bGwgYXMgYW55O1xuXG4gICAgICAvLyB3ZSBrbm93IHdlJ3JlIGRlYWxpbmcgd2l0aCBzeW5jIHN0b3JhZ2VcbiAgICAgIGNvbnN0IHVzZXJzID0gdGhpcy4jZ2V0VXNlcnMoKSBhcyBSZWNvcmQ8c3RyaW5nLCBTdG9yZWRVc2VyPiB8IG51bGw7XG4gICAgICBjb25zdCBjdXJyZW50VXNlciA9XG4gICAgICAgICh1c2Vycz8uW2FjdGl2ZVB1YmxpY0tleSBhcyBzdHJpbmddIGFzIFN0b3JlZFVzZXIpID8/IG51bGw7XG4gICAgICByZXR1cm4gY3VycmVudFVzZXIgYXMgYW55O1xuICAgIH1cblxuICAgIC8vIHdlIGFzc3VtZSB3ZSdyZSBkZWFsaW5nIHdpdGggYXN5bmMgc3RvcmFnZSBpZiB3ZSBtYWtlIGl0IGhlcmVcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2FjdGl2ZVB1YmxpY0tleSwgdGhpcy4jZ2V0VXNlcnMoKV0pLnRoZW4oXG4gICAgICAoW3B1YmxpY0tleSwgdXNlcnNdKSA9PiB7XG4gICAgICAgIGlmICghcHVibGljS2V5KSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuICh1c2Vycz8uW3B1YmxpY0tleV0gYXMgU3RvcmVkVXNlcikgPz8gbnVsbDtcbiAgICAgIH1cbiAgICApIGFzIGFueTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY29uZmlndXJlZCBub2RlVVJJIHVzZWQgZm9yIGFueSBuZXR3b3JrIGNhbGxzLiBNYWtpbmcgdGhpcyBhY2Nlc3NpYmxlXG4gICAqIGJlaGluZCBhIGdldHRlciBlbnN1cmVzIGl0IGlzIHJlYWQtb25seSBhbmQgY2FuIG9ubHkgYmUgc2V0IHZpYSB0aGVcbiAgICogY29uZmlndXJlIGNhbGwuXG4gICAqL1xuICBnZXQgbm9kZVVSSSgpIHtcbiAgICByZXR1cm4gdGhpcy4jbm9kZVVSSTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY29uZmlndXJlZCB0cmFuc2FjdGlvbiBzcGVuZGluZyBsaW1pdCB2YWx1ZXMgcHJvdmlkZWQgYnkgdGhlIGluaXRpYWxcbiAgICogY29uZmlndXJlIGNhbGwuICBUaGVzZSBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgdHggbGltaXQgY291bnRcbiAgICogdG8gdXNlIGlmIGEgZGVyaXZlZCBrZXkgbmVlZHMgdG8gYmUgcmUtYXV0aG9yaXplZC5cbiAgICovXG4gIGdldCB0cmFuc2FjdGlvblNwZW5kaW5nTGltaXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNkZWZhdWx0VHJhbnNhY3Rpb25TcGVuZGluZ0xpbWl0O1xuICB9XG5cbiAgY29uc3RydWN0b3Iod2luZG93UHJvdmlkZXI6IHR5cGVvZiBnbG9iYWxUaGlzLCBhcGlQcm92aWRlcjogQVBJUHJvdmlkZXIpIHtcbiAgICB0aGlzLiN3aW5kb3cgPSB3aW5kb3dQcm92aWRlcjtcbiAgICB0aGlzLiNhcGkgPSBhcGlQcm92aWRlcjtcbiAgICB0aGlzLiNpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93UHJvdmlkZXIubG9jYXRpb24gIT09ICd1bmRlZmluZWQnO1xuICAgIHRoaXMuI3N0b3JhZ2VQcm92aWRlciA9IGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlIGFzIFQ7XG5cbiAgICBpZiAodGhpcy4jaXNCcm93c2VyICYmIHRoaXMuI3dpbmRvdy5sb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIHRoaXMuaGFuZGxlUmVkaXJlY3RVUkkodGhpcy4jd2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgdGhlIGlkZW50aXR5IGluc3RhbmNlLiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGFueSBvdGhlclxuICAgKiBtZXRob2QgY2FsbHMsIGlkZWFsbHkgYmVmb3JlIGFueSBhcHAgY29kZSBpcyBydW4uICBUaGUgbW9zdCBpbXBvcnRhbnRcbiAgICogY29uZmlndXJhdGlvbiBvcHRpb25zIGFyZSBgc3BlbmRpbmdMaW1pdE9wdGlvbnNgIGFuZCBgYXBwTmFtZWAuXG4gICAqIGBzcGVuZGluZ0xpbWl0T3B0aW9uc2AgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgcGVybWlzc2lvbnMgdGhhdCBhXG4gICAqIHVzZXIgd2lsbCBiZSBhc2tlZCB0byBhcHByb3ZlIHdoZW4gbG9nZ2luZyBpbnRvIGFuIGFwcC4gYGFwcE5hbWVgIGlzIHVzZWRcbiAgICogdG8gaWRlbnRpdHkgZGVyaXZlZCBrZXlzIGlzc3VlZCBieSBhbiBhcHAuXG4gICAqXG4gICAqIFNlZSBtb3JlIGFib3V0IHRoZSBzcGVuZGluZyBsaW1pdCBvcHRpb25zIG9iamVjdCBoZXJlXG4gICAqIGh0dHBzOi8vZG9jcy5kZXNvLm9yZy9mb3ItZGV2ZWxvcGVycy9iYWNrZW5kL2Jsb2NrY2hhaW4tZGF0YS9iYXNpY3MvZGF0YS10eXBlcyN0cmFuc2FjdGlvbnNwZW5kaW5nbGltaXRyZXNwb25zZVxuICAgKlxuICAgKiBBbmQgU2VlIGFuIGV4aGF1c3RpdmUgbGlzdCBvZiB0cmFuc2FjdGlvbiB0eXBlcyBoZXJlOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vZGVzby1wcm90b2NvbC9jb3JlL2Jsb2IvYTgzNmU0ZDJlOTJmNTlmNzU3MGM3YTAwZjgyYTMxMDdlYzgwZGQwMi9saWIvbmV0d29yay5nbyNMMjQ0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaW1wb3J0IHsgaWRlbnRpdHkgfSBmcm9tICdAZGVzby9pZGVudGl0eSc7XG4gICAqXG4gICAqIGlkZW50aXR5LmNvbmZpZ3VyZSh7XG4gICAqICAgc3BlbmRpbmdMaW1pdE9wdGlvbnM6IHtcbiAgICogICAgIC8vIE5PVEU6IHRoaXMgdmFsdWUgaXMgaW4gRGVzbyBuYW5vcywgMTAwMDAwMDAwMCBuYW5vcyAob3IgMWU5KSA9IDEgRGVzb1xuICAgKiAgICAgR2xvYmFsREVTT0xpbWl0OiAxICogMWU5IC8vIDEgRGVzb1xuICAgKiAgICAgLy8gTWFwIG9mIHRyYW5zYWN0aW9uIHR5cGUgdG8gdGhlIG51bWJlciBvZiB0aW1lcyB0aGlzIGRlcml2ZWQga2V5IGlzXG4gICAqICAgICAvLyBhbGxvd2VkIHRvIHBlcmZvcm0gdGhpcyBvcGVyYXRpb24gb24gYmVoYWxmIG9mIHRoZSBvd25lciBwdWJsaWMga2V5XG4gICAqICAgICBUcmFuc2FjdGlvbkNvdW50TGltaXRNYXA6IHtcbiAgICogICAgICAgQkFTSUNfVFJBTlNGRVI6IDIsIC8vIDIgYmFzaWMgdHJhbnNmZXIgdHJhbnNhY3Rpb25zIGFyZSBhdXRob3JpemVkXG4gICAqICAgICAgIFNVQk1JVF9QT1NUOiAnVU5MSU1JVEVEJywgLy8gdW5saW1pdGVkIHN1Ym1pdCBwb3N0IHRyYW5zYWN0aW9ucyBhcmUgYXV0aG9yaXplZFxuICAgKiAgICAgfSxcbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGNvbmZpZ3VyZSh7XG4gICAgaWRlbnRpdHlVUkkgPSBERUZBVUxUX0lERU5USVRZX1VSSSxcbiAgICBuZXR3b3JrID0gJ21haW5uZXQnLFxuICAgIG5vZGVVUkkgPSAnaHR0cHM6Ly9ub2RlLmRlc28ub3JnJyxcbiAgICBzcGVuZGluZ0xpbWl0T3B0aW9ucyA9IERFRkFVTFRfVFJBTlNBQ1RJT05fU1BFTkRJTkdfTElNSVQsXG4gICAgcmVkaXJlY3RVUkksXG4gICAgand0QWxnb3JpdGhtID0gJ0VTMjU2JyxcbiAgICBhcHBOYW1lID0gJycsXG4gICAgc3RvcmFnZVByb3ZpZGVyLFxuICAgIGlkZW50aXR5UHJlc2VudGVyLFxuICAgIHNob3dTa2lwLFxuICB9OiBJZGVudGl0eUNvbmZpZ3VyYXRpb24pIHtcbiAgICB0aGlzLiNpZGVudGl0eVVSSSA9IGlkZW50aXR5VVJJO1xuICAgIHRoaXMuI25ldHdvcmsgPSBuZXR3b3JrO1xuICAgIHRoaXMuI25vZGVVUkkgPSBub2RlVVJJO1xuICAgIHRoaXMuI3JlZGlyZWN0VVJJID0gcmVkaXJlY3RVUkk7XG4gICAgdGhpcy4jand0QWxnb3JpdGhtID0gand0QWxnb3JpdGhtO1xuICAgIHRoaXMuI2FwcE5hbWUgPSBhcHBOYW1lO1xuICAgIHRoaXMuI2lkZW50aXR5UHJlc2VudGVyID0gaWRlbnRpdHlQcmVzZW50ZXI7XG4gICAgdGhpcy4jc2hvd1NraXAgPSAhIXNob3dTa2lwO1xuXG4gICAgaWYgKHN0b3JhZ2VQcm92aWRlcikge1xuICAgICAgdGhpcy4jc3RvcmFnZVByb3ZpZGVyID0gc3RvcmFnZVByb3ZpZGVyIGFzIFQ7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLiNkaWRDb25maWd1cmUpIHtcbiAgICAgIHRoaXMuI2RlZmF1bHRUcmFuc2FjdGlvblNwZW5kaW5nTGltaXQgPVxuICAgICAgICBidWlsZFRyYW5zYWN0aW9uU3BlbmRpbmdMaW1pdFJlc3BvbnNlKHNwZW5kaW5nTGltaXRPcHRpb25zKTtcblxuICAgICAgaWYgKHRoaXMuI3N0b3JhZ2VQcm92aWRlcikge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgc3RvcmFnZSBwcm92aWRlciBpdCBtZWFucyB3ZSBhcmUgbGlrZWx5IHJ1bm5pbmcgaW5cbiAgICAgICAgLy8gYSBub2RlIGVudmlyb25tZW50IChTU1IsIGV0YykuIEluIHRoaXMgY2FzZSB3ZSB3aWxsIHNraXBcbiAgICAgICAgLy8gcmVmcmVzaERlcml2ZWRLZXlQZXJtaXNzaW9ucyBzaW5jZSBpdCByZWxpZXMgb24gdGhlIHN0b3JhZ2UgcHJvdmlkZXIuXG4gICAgICAgIC8vIE9uY2UgdGhlIGNvZGUgZXhlY3V0ZXMgaW4gYSBVSSBlbnZpcm9ubWVudCwgdGhlIHN0b3JhZ2UgcHJvdmlkZXJcbiAgICAgICAgLy8gc2hvdWxkIGJlIGF2YWlsYWJsZSBhbmQgd2UgY2FuIHJlZnJlc2ggdGhlIGRlcml2ZWQga2V5IHBlcm1pc3Npb25zLlxuICAgICAgICB0aGlzLnJlZnJlc2hEZXJpdmVkS2V5UGVybWlzc2lvbnMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLiNkaWRDb25maWd1cmUgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyBsaXN0ZW5pbmcgdG8gY2hhbmdlcyB0byBpZGVudGl0eSBzdGF0ZS4gVGhlIHN1YnNjcmliZXIgd2lsbCBiZVxuICAgKiBjYWxsZWQgd2l0aCB0aGUgbmV3IHN0YXRlIGFueSB0aW1lIGEgdXNlciBsb2dzIGluLCBsb2dzIG91dCwgYXBwcm92ZXMgYVxuICAgKiBkZXJpdmVkIGtleSwgZXRjLiBBcHBzIGNhbiB1c2UgdGhpcyB0byBzeW5jIHRoZWlyIHN0YXRlIHdpdGggdGhlIGlkZW50aXR5XG4gICAqIGluc3RhbmNlIHN1Y2ggdGhhdCB0aGVpciBhcHBsaWNhdGlvbiByZWFjdHMgdG8gY2hhbmdlcyBhbmQgcmUtcmVuZGVyc1xuICAgKiBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogTk9URTogVGhpcyBtZXRob2QgY291bGQgYmUgdmVyeSBjaGF0dHkuIERlcGVuZGluZyBvbiB0aGUgbmVlZHMgb2YgeW91clxuICAgKiBhcHBsaWNhdGlvbiwgeW91IG1heSB3YW50IHRvIGltcGxlbWVudCBzb21lIGNhY2hpbmcgb3IgbWVtb2l6YXRpb24gdG9cbiAgICogcmVkdWNlIGFueSB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzIG9yIG5ldHdvcmsgY2FsbHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaWRlbnRpdHkuc3Vic2NyaWJlKCh7IGV2ZW50LCBjdXJyZW50VXNlciwgYWx0ZXJuYXRlVXNlcnMgfSkgPT4ge1xuICAgKiAgIGlmIChldmVudCA9PT0gTk9USUZJQ0FUSU9OX0VWRU5UUy5BVVRIT1JJWkVfREVSSVZFRF9LRVlfU1RBUlQpIHtcbiAgICogICAgIC8vIHNob3cgYSBsb2FkaW5nIGluZGljYXRvciB3aGlsZSB0aGUgdW5kZXJseWluZyBuZXR3b3JrIGNhbGwgdG8gYXV0aG9yaXplIHRoZSBkZXJpdmVkIGtleSBpcyBtYWRlLlxuICAgKiAgIH1cbiAgICpcbiAgICogICBpZiAoZXZlbnQgPT09IE5PVElGSUNBVElPTl9FVkVOVFMuTE9HSU5fRU5EKSB7XG4gICAqICAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggY3VycmVudFVzZXJcbiAgICogICB9XG4gICAqXG4gICAqICAgLy8gc2VlIGFuZCBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlbnRzIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kZXNvLXByb3RvY29sL2Rlc28td29ya3NwYWNlL2Jsb2IvYTNjMDI3NDJhMzQyNjEwYmI2YWY4ZjJiMTM5NmQ1NDMwOTMxY2Y0MS9saWJzL2lkZW50aXR5L3NyYy9saWIvdHlwZXMudHMjTDE4MlxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBzdWJzY3JpYmVyIHRoaXMgaXMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGN1cnJlbnRcbiAgICogc3RhdGUgYW5kIHRoZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgY2hhbmdlLlxuICAgKi9cbiAgYXN5bmMgc3Vic2NyaWJlKHN1YnNjcmliZXI6IChub3RpZmljYXRpb246IFN1YnNjcmliZXJOb3RpZmljYXRpb24pID0+IHZvaWQpIHtcbiAgICB0aGlzLiNzdWJzY3JpYmVycy5wdXNoKHN1YnNjcmliZXIpO1xuICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgdGhpcy4jZ2V0U3RhdGUoKTtcbiAgICB0aGlzLiNzdWJzY3JpYmVycy5mb3JFYWNoKChzKSA9PlxuICAgICAgcyh7IGV2ZW50OiBOT1RJRklDQVRJT05fRVZFTlRTLlNVQlNDUklCRSwgLi4uc3RhdGUgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHN1YnNjcmliZXIgc28gaXQgbm8gbG9uZ2VyIGdldHMgY2FsbGVkIHdoZW4gaWRlbnRpdHkgc3RhdGUgY2hhbmdlcy5cbiAgICovXG4gIHVuc3Vic2NyaWJlKHN1YnNjcmliZXI6IChub3RpZmljYXRpb246IFN1YnNjcmliZXJOb3RpZmljYXRpb24pID0+IHZvaWQpIHtcbiAgICB0aGlzLiNzdWJzY3JpYmVycyA9IHRoaXMuI3N1YnNjcmliZXJzLmZpbHRlcigocykgPT4gcyAhPT0gc3Vic2NyaWJlcik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB1bmRlcmx5aW5nIHN0YXRlIG9mIHRoZSBpZGVudGl0eSBpbnN0YW5jZS4gSW4gZ2VuZXJhbCxcbiAgICogeW91IHNob3VsZCB1c2UgdGhlIGBzdWJzY3JpYmVgIG1ldGhvZCB0byBsaXN0ZW4gdG8gY2hhbmdlcyB0byBvYnNlcnZlIGFuZFxuICAgKiByZWFjdCB0byB0aGUgc3RhdGUgb3ZlciB0aW1lLCBidXQgaWYgeW91IG5lZWQgYSBzbmFwc2hvdCBvZiB0aGUgY3VycmVudFxuICAgKiBzdGF0ZSB5b3UgY2FuIHVzZSB0aGlzIG1ldGhvZC4gQ2FuIGJlIHVzZWZ1bCBmb3IgZGVidWdnaW5nIG9yIHNldHRpbmcgdXBcbiAgICogaW5pdGlhbCBzdGF0ZSBpbiB5b3VyIGFwcC5cbiAgICovXG4gIHNuYXBzaG90KCk6IFQgZXh0ZW5kcyBTdG9yYWdlID8gSWRlbnRpdHlTdGF0ZSA6IFByb21pc2U8SWRlbnRpdHlTdGF0ZT4ge1xuICAgIHJldHVybiB0aGlzLiNnZXRTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBhIGxvZ2luIGZsb3cuIFRoaXMgd2lsbCBvcGVuIGEgbmV3IHdpbmRvdyBhbmQgcHJvbXB0IHRoZSB1c2VyIHRvXG4gICAqIHNlbGVjdCBhbiBleGlzdGluZyBhY2NvdW50IG9yIGNyZWF0ZSBhIG5ldyBhY2NvdW50LiBJZiB0aGVyZSBpcyBhbiBlcnJvclxuICAgKiBkdXJpbmcgdGhlIGxvZ2luIGZsb3csIHRoZSBwcm9taXNlIHdpbGwgcmVqZWN0IHdpdGggYW4gZXJyb3Igd2hpY2ggeW91IGNhblxuICAgKiBjYXRjaCBhbmQgaGFuZGxlIGluIHlvdXIgYXBwIGJ5IHNob3dpbmcgc29tZSBlcnJvciBmZWVkYmFjayBpbiB0aGUgVUkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaW1wb3J0IHsgaWRlbnRpdHksIEVSUk9SX1RZUEVTIH0gZnJvbSAnQGRlc28vaWRlbnRpdHknO1xuICAgKlxuICAgKlxuICAgKiBhd2FpdCBpZGVudGl0eS5sb2dpbigpLmNhdGNoKChlcnIpID0+IHtcbiAgICogICBpZiAoZXJyLnR5cGUgPT09IEVSUk9SX1RZUEVTLk5PX01PTkVZKSB7XG4gICAqICAgICAvLyBoYW5kbGUgbm8gbW9uZXkgZXJyb3JcbiAgICogICB9IGVsc2Uge1xuICAgKiAgICAgLy8gaGFuZGxlIG90aGVyIGVycm9yc1xuICAgKiAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJucyByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBpZGVudGl0eSBsb2dpblxuICAgKiBwYXlsb2FkLCBvciByZWplY3RzIGlmIHRoZXJlIHdhcyBhbiBlcnJvci5cbiAgICovXG4gIGFzeW5jIGxvZ2luKHtcbiAgICBnZXRGcmVlRGVzbyA9IHRydWUsXG4gICAgLy8gTk9URTogZGVyaXZlZEtleUxvZ2luIGlzIHRoZSBkZWZhdWx0IGFuZCByZWNvbW1lbmRlZCBsb2dpbiBmbG93LiBXZSBvbmx5XG4gICAgLy8gYWxsb3cgZGlzYWJsaW5nIGl0IGZvciBzaW1wbGUgXCJnYXRlZCBsb2dpbnNcIiB3aGVyZSB0aGUgYXBwIHdhbnRzIHRvIGdhdGVcbiAgICAvLyBhY2Nlc3MgdG8gdGhlIGFwcCBiZWhpbmQgYSBsb2dpbiwgYnV0IGRvZXNuJ3QgbmVlZCB0byBpc3N1ZSBhIGRlcml2ZWQga2V5XG4gICAgLy8gZm9yIGV4ZWN1dGluZyB0cmFuc2FjdGlvbnMgb24gYmVoYWxmIG9mIHRoZSB1c2VyLlxuICAgIGRlcml2ZWRLZXlMb2dpbiA9IHRydWUsXG4gIH06IExvZ2luT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxJZGVudGl0eURlcml2ZVBheWxvYWQ+IHtcbiAgICBpZiAoIXRoaXMuI3N0b3JhZ2VQcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnTm8gc3RvcmFnZSBwcm92aWRlciBhdmFpbGFibGUuIERpZCB5b3UgZm9yZ2V0IHRvIGNvbmZpZ3VyZSBhIGN1c3RvbSBzdG9yYWdlUHJvdmlkZXI/J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBldmVudCA9IE5PVElGSUNBVElPTl9FVkVOVFMuTE9HSU5fU1RBUlQ7XG4gICAgY29uc3Qgc3RhdGUgPSBhd2FpdCB0aGlzLiNnZXRTdGF0ZSgpO1xuICAgIHRoaXMuI3N1YnNjcmliZXJzLmZvckVhY2goKHMpID0+IHMoeyBldmVudCwgLi4uc3RhdGUgfSkpO1xuXG4gICAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IFwiZ2F0ZWQgbG9naW5zXCJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGVzby1wcm90b2NvbC9kZXNvLWpzL2lzc3Vlcy8xXG4gICAgaWYgKCFkZXJpdmVkS2V5TG9naW4pIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdXaW5kb3dSZXF1ZXN0ID0geyByZXNvbHZlLCByZWplY3QsIGV2ZW50IH07XG4gICAgICAgIHRoaXMuI2xhdW5jaElkZW50aXR5KCdsb2ctaW4nLCB7XG4gICAgICAgICAgYWNjZXNzTGV2ZWxSZXF1ZXN0OiAyLFxuICAgICAgICAgIGdldEZyZWVEZXNvLFxuICAgICAgICAgIHNob3dTa2lwOiB0aGlzLiNzaG93U2tpcCxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgZGVyaXZlZFB1YmxpY0tleTogc3RyaW5nO1xuICAgIGNvbnN0IGxvZ2luS2V5UGFpciA9IGF3YWl0IHRoaXMuI3N0b3JhZ2VQcm92aWRlci5nZXRJdGVtKFxuICAgICAgTE9DQUxfU1RPUkFHRV9LRVlTLmxvZ2luS2V5UGFpclxuICAgICk7XG5cbiAgICBpZiAobG9naW5LZXlQYWlyKSB7XG4gICAgICBkZXJpdmVkUHVibGljS2V5ID0gSlNPTi5wYXJzZShsb2dpbktleVBhaXIpLnB1YmxpY0tleTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5cyA9IGtleWdlbigpO1xuICAgICAgZGVyaXZlZFB1YmxpY0tleSA9IHB1YmxpY0tleVRvQmFzZTU4Q2hlY2soa2V5cy5wdWJsaWMsIHtcbiAgICAgICAgbmV0d29yazogdGhpcy4jbmV0d29yayxcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgdGhpcy4jc3RvcmFnZVByb3ZpZGVyLnNldEl0ZW0oXG4gICAgICAgIExPQ0FMX1NUT1JBR0VfS0VZUy5sb2dpbktleVBhaXIsXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBwdWJsaWNLZXk6IGRlcml2ZWRQdWJsaWNLZXksXG4gICAgICAgICAgc2VlZEhleDoga2V5cy5zZWVkSGV4LFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy4jcGVuZGluZ1dpbmRvd1JlcXVlc3QgPSB7IHJlc29sdmUsIHJlamVjdCwgZXZlbnQgfTtcblxuICAgICAgY29uc3QgYXV0aGVudGljYXRlZFVzZXJLZXlzID0gW107XG4gICAgICBpZiAoc3RhdGUuY3VycmVudFVzZXI/LnByaW1hcnlEZXJpdmVkS2V5KSB7XG4gICAgICAgIGF1dGhlbnRpY2F0ZWRVc2VyS2V5cy5wdXNoKHN0YXRlLmN1cnJlbnRVc2VyPy5wdWJsaWNLZXkpO1xuICAgICAgfVxuICAgICAgY29uc3QgYWx0ZXJuYXRlVXNlcnMgPSBzdGF0ZS5hbHRlcm5hdGVVc2VycyA/PyB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGFsdGVybmF0ZVVzZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKGFsdGVybmF0ZVVzZXJzW2tleV0/LnByaW1hcnlEZXJpdmVkS2V5KSB7XG4gICAgICAgICAgYXV0aGVudGljYXRlZFVzZXJLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGlkZW50aXR5UGFyYW1zOiB7XG4gICAgICAgIGRlcml2ZWRQdWJsaWNLZXk6IHN0cmluZztcbiAgICAgICAgdHJhbnNhY3Rpb25TcGVuZGluZ0xpbWl0UmVzcG9uc2U6IFRyYW5zYWN0aW9uU3BlbmRpbmdMaW1pdFJlc3BvbnNlO1xuICAgICAgICBkZXJpdmU6IGJvb2xlYW47XG4gICAgICAgIGdldEZyZWVEZXNvPzogYm9vbGVhbjtcbiAgICAgICAgZXhwaXJhdGlvbkRheXM6IG51bWJlcjtcbiAgICAgICAgc2hvd1NraXA/OiBib29sZWFuO1xuICAgICAgfSA9IHtcbiAgICAgICAgZGVyaXZlOiB0cnVlLFxuICAgICAgICBkZXJpdmVkUHVibGljS2V5LFxuICAgICAgICB0cmFuc2FjdGlvblNwZW5kaW5nTGltaXRSZXNwb25zZTogdGhpcy4jZGVmYXVsdFRyYW5zYWN0aW9uU3BlbmRpbmdMaW1pdCxcbiAgICAgICAgZXhwaXJhdGlvbkRheXM6IHRoaXMuI2RlZmF1bHROdW1EYXlzQmVmb3JlRXhwaXJhdGlvbixcbiAgICAgICAgc2hvd1NraXA6IHRoaXMuI3Nob3dTa2lwLFxuICAgICAgICAuLi4oYXV0aGVudGljYXRlZFVzZXJLZXlzLmxlbmd0aCAmJiB7XG4gICAgICAgICAgYXV0aGVudGljYXRlZFVzZXJzOiBhdXRoZW50aWNhdGVkVXNlcktleXMuam9pbignLCcpLFxuICAgICAgICB9KSxcbiAgICAgIH07XG5cbiAgICAgIGlmIChnZXRGcmVlRGVzbykge1xuICAgICAgICBpZGVudGl0eVBhcmFtcy5nZXRGcmVlRGVzbyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuI2xhdW5jaElkZW50aXR5KCdkZXJpdmUnLCBpZGVudGl0eVBhcmFtcyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIG93bmVyU2VlZEhleCBUaGlzIGlzIHRoZSBzZWVkIGhleCBvZiB0aGUgb3duZXIga2V5LiBUaGlzIG11c3QgYmUgcHJvdmlkZWQgYnkgdGhlIGFwcC5cbiAgICogQHBhcmFtIG9wdGlvbnMuZGVyaXZlZFNlZWRIZXggVGhpcyBpcyBvcHRpb25hbCBhbmQgcHJpbWFyaWx5IG9ubHkgdXNlZCBmb3IgdGVzdGluZy4gSWYgbm90IHByb3ZpZGVkLCBhIG5ldyByYW5kb20gZGVyaXZlZCBrZXkgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gICAqL1xuICBhc3luYyBsb2dpbldpdGhBdXRvRGVyaXZlKFxuICAgIG93bmVyU2VlZEhleDogc3RyaW5nLFxuICAgIHsgZGVyaXZlZFNlZWRIZXggfTogeyBkZXJpdmVkU2VlZEhleD86IHN0cmluZyB9ID0ge31cbiAgKTogUHJvbWlzZTxJZGVudGl0eURlcml2ZVBheWxvYWQ+IHtcbiAgICBjb25zdCBldmVudCA9IE5PVElGSUNBVElPTl9FVkVOVFMuTE9HSU5fU1RBUlQ7XG4gICAgY29uc3Qgc3RhdGUgPSBhd2FpdCB0aGlzLiNnZXRTdGF0ZSgpO1xuICAgIHRoaXMuI3N1YnNjcmliZXJzLmZvckVhY2goKHMpID0+IHMoeyBldmVudCwgLi4uc3RhdGUgfSkpO1xuXG4gICAgY29uc3Qgb3duZXJLZXlzID0ga2V5Z2VuKG93bmVyU2VlZEhleCk7XG4gICAgY29uc3QgZGVyaXZlZEtleXMgPSBrZXlnZW4oZGVyaXZlZFNlZWRIZXgpO1xuICAgIGNvbnN0IGRlcml2ZWRQdWJsaWNLZXlCYXNlNTggPSBwdWJsaWNLZXlUb0Jhc2U1OENoZWNrKGRlcml2ZWRLZXlzLnB1YmxpYywge1xuICAgICAgbmV0d29yazogdGhpcy4jbmV0d29yayxcbiAgICB9KTtcblxuICAgIC8vIFdoZW4gdGhlIGRlcml2ZWQgcGF5bG9hZCBpcyBoYW5kbGVkLCB3ZSBsb29rIGF0IGxvY2FsIHN0b3JhZ2UgdG8gc2VlIGlmXG4gICAgLy8gdGhpcyBpcyBhIGxvZ2luIGRlcml2ZWQga2V5LCBzbyB3ZSBuZWVkIHRvIHNldCB0aGlzIGJlZm9yZSB3ZSBoYW5kbGUgdGhlIHJlc3BvbnNlLlxuICAgIGF3YWl0IHRoaXMuI3N0b3JhZ2VQcm92aWRlcj8uc2V0SXRlbShcbiAgICAgIExPQ0FMX1NUT1JBR0VfS0VZUy5sb2dpbktleVBhaXIsXG4gICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHB1YmxpY0tleTogZGVyaXZlZFB1YmxpY0tleUJhc2U1OCxcbiAgICAgICAgc2VlZEhleDogZGVyaXZlZEtleXMuc2VlZEhleCxcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCBnZW5lcmF0ZURlcml2ZWRLZXlQYXlsb2FkKFxuICAgICAgb3duZXJLZXlzLFxuICAgICAgZGVyaXZlZEtleXMsXG4gICAgICB0aGlzLiNkZWZhdWx0VHJhbnNhY3Rpb25TcGVuZGluZ0xpbWl0LFxuICAgICAgdGhpcy4jZGVmYXVsdE51bURheXNCZWZvcmVFeHBpcmF0aW9uLFxuICAgICAgdGhpcy4jbmV0d29ya1xuICAgICk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy4jcGVuZGluZ1dpbmRvd1JlcXVlc3QgPSB7IHJlc29sdmUsIHJlamVjdCwgZXZlbnQgfTtcbiAgICAgIC8vIE5PVEU6IFdlIHNldCB0aGlzIGZsYWcgc28gdGhhdCB3aGVuIHRoZSBpZGVudGl0eSByZXNwb25zZSBpcyBoYW5kbGVkLFxuICAgICAgLy8gd2Uga25vdyB0byBsZXQgdGhlIGxvZ2luIGZsb3cgY29udGludWUgZXZlbiBpZiB0aGUgdXNlciBoYXMgbm8gbW9uZXkgdG9cbiAgICAgIC8vIGF1dGhvcml6ZSB0aGUga2V5LiBJdCdzIHVwIHRvIHRoZSBhcHAgdG8gaGFuZGxlIGhvdyB0aGUgdXNlciBnZXRzXG4gICAgICAvLyBtb25leSwgYWZ0ZXIgd2hpY2ggdGhleSBjYW4gcmUtYXR0ZW1wdCB0byBhdXRob3JpemUgdGhlIGtleS5cbiAgICAgIHRoaXMuI2lzQXV0b0Rlcml2ZUxvZ2luID0gdHJ1ZTtcbiAgICAgIHRoaXMuI2hhbmRsZUlkZW50aXR5UmVzcG9uc2Uoe1xuICAgICAgICBzZXJ2aWNlOiAnaWRlbnRpdHknLFxuICAgICAgICBtZXRob2Q6ICdkZXJpdmUnLFxuICAgICAgICBwYXlsb2FkLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIGEgbG9nb3V0IGZsb3cuIFRoaXMgd2lsbCBvcGVuIGEgbmV3IHdpbmRvdyBhbmQgcHJvbXB0IHRoZSB1c2VyIHRvXG4gICAqIGNvbmZpcm0gdGhleSB3YW50IHRvIGxvZ291dC4gU2ltaWxhciB0byB0aGUgbG9naW4gZmxvdywgaWYgdGhlcmUgaXMgYW4gZXJyb3JcbiAgICogdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCByZWplY3Qgd2l0aCBhbiBlcnJvciB3aGljaCB5b3UgY2FuIGNhdGNoIGFuZCBoYW5kbGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaW1wb3J0IHsgaWRlbnRpdHkgfSBmcm9tICdAZGVzby9pZGVudGl0eSc7XG4gICAqXG4gICAqXG4gICAqIGF3YWl0IGlkZW50aXR5LmxvZ291dCgpLmNhdGNoKChlcnIpID0+IHtcbiAgICogICAvLyBoYW5kbGUgZXJyb3JzXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybnMgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB1bmRlZmluZWQsIG9yIHJlamVjdHMgaWYgdGhlcmVcbiAgICogd2FzIGFuIGVycm9yLlxuICAgKi9cbiAgYXN5bmMgbG9nb3V0KCk6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gICAgY29uc3QgZXZlbnQgPSBOT1RJRklDQVRJT05fRVZFTlRTLkxPR09VVF9TVEFSVDtcbiAgICBjb25zdCBzdGF0ZSA9IGF3YWl0IHRoaXMuI2dldFN0YXRlKCk7XG4gICAgdGhpcy4jc3Vic2NyaWJlcnMuZm9yRWFjaCgocykgPT4gcyh7IGV2ZW50LCAuLi5zdGF0ZSB9KSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgYWN0aXZlUHVibGljS2V5ID0gdGhpcy4jZ2V0QWN0aXZlUHVibGljS2V5KCk7XG4gICAgICBjb25zdCBsYXVuY2hJZGVudGl0eSA9IChhY3RpdmVQdWJsaWNLZXk6IHN0cmluZyB8IG51bGwpID0+IHtcbiAgICAgICAgdGhpcy4jcGVuZGluZ1dpbmRvd1JlcXVlc3QgPSB7IHJlc29sdmUsIHJlamVjdCwgZXZlbnQgfTtcbiAgICAgICAgaWYgKCFhY3RpdmVQdWJsaWNLZXkpIHtcbiAgICAgICAgICB0aGlzLiNwZW5kaW5nV2luZG93UmVxdWVzdC5yZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3IoJ2Nhbm5vdCBsb2dvdXQgd2l0aG91dCBhbiBhY3RpdmUgcHVibGljIGtleScpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiNsYXVuY2hJZGVudGl0eSgnbG9nb3V0JywgeyBwdWJsaWNLZXk6IGFjdGl2ZVB1YmxpY0tleSB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gTk9URTogaW4gdGhlIGNhc2Ugb2YgYSBicm93c2VyIGNvbnRleHQsIHdlIGFyZSB1c2luZyBzeW5jaHJvbm91cyBsb2NhbFxuICAgICAgLy8gc3RvcmFnZSwgV2UgY2Fubm90IGludHJvZHVjZSBhbnkgYXN5bmMgb3BlcmF0aW9ucyBiZWNhdXNlIGl0IG1heVxuICAgICAgLy8gdHJpZ2dlciBwb3B1cCBibG9ja2Vycywgd2hpY2ggaXMgd2h5IHdlIG5lZWQgdG8gYnJhbmNoIHRoZSBsb2dpYyBsaWtlXG4gICAgICAvLyB0aGlzLlxuICAgICAgaWYgKHR5cGVvZiBhY3RpdmVQdWJsaWNLZXkgPT09ICdzdHJpbmcnIHx8IGFjdGl2ZVB1YmxpY0tleSA9PT0gbnVsbCkge1xuICAgICAgICBsYXVuY2hJZGVudGl0eShhY3RpdmVQdWJsaWNLZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZlUHVibGljS2V5Py50aGVuKGxhdW5jaElkZW50aXR5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyBhIHRyYW5zYWN0aW9uIGhleCB1c2luZyB0aGUgZGVyaXZlZCBrZXkgaXNzdWVkIHRvIHRoZSBjdXJyZW50bHlcbiAgICogYWN0aXZlIHVzZXIgd2hlbiB0aGV5IGxvZ2dlZCBpbnRvIGFuIGFwcGxpY2F0aW9uLiBUaGUgYFRyYW5zYWN0aW9uSGV4YFxuICAgKiBwYXJhbWV0ZXIgc2hvdWxkIGNvbWUgZnJvbSBhIHRyYW5zYWN0aW9uIG9iamVjdCByZXR1cm5lZCBmcm9tIGEgdHJhbnNhY3Rpb25cbiAgICogY29uc3RydWN0aW9uIGVuZHBvaW50LCBzdWNoIGFzIHRoZSBgc3VibWl0LXBvc3RgIGVuZHBvaW50IG9mIHRoZSBEZVNvXG4gICAqIGJhY2tlbmQgYXBpLlxuICAgKlxuICAgKiBXZSByZXR1cm4gYSBzaWduZWQgdHJhbnNhY3Rpb24gaGV4IHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgdG8gc3VibWl0IGFcbiAgICogdHJhbnNhY3Rpb24gdG8gdGhlIG5ldHdvcmsgZm9yIGNvbmZpcm1hdGlvbi4gVGhpcyBtZXRob2QgaXMgdXNlZCBpbnRlcm5hbGx5XG4gICAqIGJ5IHRoZSBzaWduQW5kU3VibWl0IG1ldGhvZCwgd2hpY2ggaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgdG8gc2lnbiBhbmRcbiAgICogc3VibWl0IGEgdHJhbnNhY3Rpb24gaW4gYSBzaW5nbGUgc3RlcC4gSXQgY2FuIGFsc28gYmUgdXNlZCBhcyBhIHN0YW5kYWxvbmVcbiAgICogbWV0aG9kIGlmIHlvdSB3YW50IHRvIHNpZ24gYSB0cmFuc2FjdGlvbiBhbmQgc3VibWl0IGl0IHlvdXJzZWxmLlxuICAgKlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHNpZ25lZFR4SGV4ID0gYXdhaXQgaWRlbnRpdHkuc2lnblR4KHR4SGV4KTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBzaWduVHgoVHJhbnNhY3Rpb25IZXg6IHN0cmluZykge1xuICAgIGNvbnN0IHsgcHJpbWFyeURlcml2ZWRLZXkgfSA9IChhd2FpdCB0aGlzLiNnZXRDdXJyZW50VXNlcigpKSA/PyB7fTtcblxuICAgIGlmICghcHJpbWFyeURlcml2ZWRLZXk/LmRlcml2ZWRTZWVkSGV4KSB7XG4gICAgICAvLyBUaGlzICpzaG91bGQqIG5ldmVyIGhhcHBlbiwgYnV0IGp1c3QgaW4gY2FzZSB3ZSB0aHJvdyBoZXJlIHRvIHN1cmZhY2UgYW55IGJ1Z3MuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzaWduIHRyYW5zYWN0aW9uIHdpdGhvdXQgYSBkZXJpdmVkIHNlZWQgaGV4Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHNpZ25UeChUcmFuc2FjdGlvbkhleCwgcHJpbWFyeURlcml2ZWRLZXkuZGVyaXZlZFNlZWRIZXgsIHtcbiAgICAgIGlzRGVyaXZlZEtleTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJtaXRzIGEgc2lnbmVkIHRyYW5zYWN0aW9uIHRvIHRoZSBuZXR3b3JrIGZvciBjb25maXJtYXRpb24uIE5PVEU6IHlvdVxuICAgKiBtdXN0IHNpZ24gYSB0cmFuc2FjdGlvbiBiZWZvcmUgc3VibWl0dGluZyBpdC4gVGhpcyBtZXRob2QgaXMgdXNlZFxuICAgKiBpbnRlcm5hbGx5IGJ5IHRoZSBgc2lnbkFuZFN1Ym1pdGAgbWV0aG9kLCB3aGljaCBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCB0b1xuICAgKiBzaWduIGFuZCBzdWJtaXQgYSB0cmFuc2FjdGlvbiBpbiBhIHNpbmdsZSBzdGVwLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHN1Ym1pdHRlZFR4ID0gYXdhaXQgaWRlbnRpdHkuc3VibWl0VHgoc2lnbmVkVHhIZXgpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHN1Ym1pdFR4KFRyYW5zYWN0aW9uSGV4OiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNhcGkucG9zdChcbiAgICAgIGAke3RoaXMuI25vZGVVUkl9L2FwaS92MC9zdWJtaXQtdHJhbnNhY3Rpb25gLFxuICAgICAge1xuICAgICAgICBUcmFuc2FjdGlvbkhleCxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy5yZWZyZXNoRGVyaXZlZEtleVBlcm1pc3Npb25zKCk7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgdG8gc2lnbiBhbmQgc3VibWl0IGEgdHJhbnNhY3Rpb24gaW4gYSBzaW5nbGVcbiAgICogc3RlcC4gSXQgcmVjZWl2ZXMgYSB0cmFuc2FjdGlvbiBvYmplY3QgYW5kIHNpZ25zIGl0IHVzaW5nIHRoZSBkZXJpdmVkIGtleVxuICAgKiBpc3N1ZWQgdG8gdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlci4gVGhpcyBjYW4gYmUgY2hhaW5lZCB3aXRoXG4gICAqIHRyYW5zYWN0aW9uIGNvbnN0cnVjdGlvbiBwcm9taXNlcyB0aGF0IHJldHVybiBhIHRyYW5zYWN0aW9uIG9iamVjdCBzdWNoIGFzXG4gICAqIGEgcHJvbWlzZSB0aGF0IHdyYXBzIHRoZSBjYWxsIHRvIHRoZSBgc3VibWl0LXBvc3RgIGVuZHBvaW50IG9mIHRoZSBEZVNvXG4gICAqIGJhY2tlbmQgYXBpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHRyYW5zYWN0aW9uT2JqZWN0ID0gYXdhaXQgbXlBcGlDbGllbnQucG9zdCgnaHR0cHM6Ly9ub2RlLmRlc28ub3JnL2FwaS92MC9zdWJtaXQtcG9zdCcsIHsgLi4uZGF0YSB9KTtcbiAgICpcbiAgICogYXdhaXQgaWRlbnRpdHkuc2lnbkFuZFN1Ym1pdCh0cmFuc2FjdGlvbk9iamVjdCk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgc2lnbkFuZFN1Ym1pdCh0eDoge1xuICAgIFRyYW5zYWN0aW9uSGV4OiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPFN1Ym1pdFRyYW5zYWN0aW9uUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zdWJtaXRUeChhd2FpdCB0aGlzLnNpZ25UeCh0eC5UcmFuc2FjdGlvbkhleCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzaWduQW5kU3VibWl0IGluc3RlYWQuIFNpbmNlIHdlIGRvbid0IHN1cHBvcnQgdW5hdXRob3JpemVkXG4gICAqIGtleXMgYW55bW9yZSwgdGhpcyBpcyBubyBsb25nZXIgbmVjZXNzYXJ5LiBJdCdzIG9ubHkgcHVycG9zZSB3YXMgdG9cbiAgICogYXV0aG9yaXplIGEgZGVyaXZlZCBrZXkgaWYgaXQgd2Fzbid0IGFscmVhZHkgYXV0aG9yaXplZCBhbmQgcmV0cnkgdGhlXG4gICAqIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gY29uc3RydWN0VHggZ2VuZXJpYyBmdW5jdGlvbiBmb3IgY29uc3RydWN0aW5nIGEgdHJhbnNhY3Rpb24uIFNob3VsZFxuICAgKiByZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBzaWduQW5kU3VibWl0VHgoXG4gICAgY29uc3RydWN0VHg6ICgpID0+IFByb21pc2U8eyBUcmFuc2FjdGlvbkhleDogc3RyaW5nIH0+XG4gICkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnN0cnVjdFR4KCk7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zdWJtaXRUeChhd2FpdCB0aGlzLnNpZ25UeCh0eC5UcmFuc2FjdGlvbkhleCkpO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgLy8gaWYgdGhlIGRlcml2ZWQga2V5IGlzIG5vdCBhdXRob3JpemVkLCBhdXRob3JpemUgaXQgYW5kIHRyeSBhZ2FpblxuICAgICAgaWYgKGU/Lm1lc3NhZ2U/LmluY2x1ZGVzKCdSdWxlRXJyb3JEZXJpdmVkS2V5Tm90QXV0aG9yaXplZCcpKSB7XG4gICAgICAgIGNvbnN0IHsgcHJpbWFyeURlcml2ZWRLZXkgfSA9IChhd2FpdCB0aGlzLiNnZXRDdXJyZW50VXNlcigpKSA/PyB7fTtcbiAgICAgICAgaWYgKHByaW1hcnlEZXJpdmVkS2V5ID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2Fubm90IGF1dGhvcml6ZSBkZXJpdmVkIGtleSB3aXRob3V0IGEgbG9nZ2VkIGluIHVzZXInXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgZGVyaXZlZCBrZXkgaXMgbm90IGF1dGhvcml6ZWRcbiAgICAgICAgLy8gd2UgdHJ5IHRvIGF1dGhvcml6ZSBpdCBhbmQgcmV0cnlcbiAgICAgICAgYXdhaXQgdGhpcy4jYXV0aG9yaXplUHJpbWFyeURlcml2ZWRLZXkoXG4gICAgICAgICAgcHJpbWFyeURlcml2ZWRLZXkucHVibGljS2V5QmFzZTU4Q2hlY2tcbiAgICAgICAgKTtcblxuICAgICAgICAvLyByZWNvbnN0cnVjdCB0aGUgb3JpZ2luYWwgdHJhbnNhY3Rpb24gYW5kIHRyeSBhZ2FpblxuICAgICAgICAvLyB0aGlzIHdpbGwgdGhyb3cgaWYgdGhlIHByZXZpb3VzIGF1dGhvcml6YXRpb24gZmFpbGVkXG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgY29uc3RydWN0VHgoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc3VibWl0VHgoYXdhaXQgdGhpcy5zaWduVHgodHguVHJhbnNhY3Rpb25IZXgpKTtcbiAgICAgIH1cblxuICAgICAgLy8ganVzdCByZXRocm93IHVuZXhwZWN0ZWQgZXJyb3JzXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNyeXB0IGFuIGFyYml0cmFyeSBzdHJpbmcgdXNpbmcgdGhlIHJlY2lwaWVudCdzXG4gICAqIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgbWVzc2FnZSA9IFwiSGksIHRoaXMgaXMgbXkgZmlyc3QgZW5jcnlwdGVkIG1lc3NhZ2UhXCI7XG4gICAqXG4gICAqIGNvbnN0IGNpcGhlclRleHQgPSBhd2FpdCBpZGVudGl0eS5lbmNyeXB0TWVzc2FnZShcbiAgICogICByZWNpcGllbnRQdWJsaWNLZXlCYXNlNThDaGVjayxcbiAgICogICBtZXNzYWdlXG4gICAqICk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZW5jcnlwdE1lc3NhZ2UoXG4gICAgcmVjaXBpZW50UHVibGljS2V5QmFzZTU4Q2hlY2s6IHN0cmluZyxcbiAgICBtZXNzYWdlUGxhaW5UZXh0OiBzdHJpbmdcbiAgKSB7XG4gICAgY29uc3QgeyBwcmltYXJ5RGVyaXZlZEtleSB9ID0gKGF3YWl0IHRoaXMuI2dldEN1cnJlbnRVc2VyKCkpID8/IHt9O1xuXG4gICAgaWYgKCFwcmltYXJ5RGVyaXZlZEtleT8ubWVzc2FnaW5nUHJpdmF0ZUtleSkge1xuICAgICAgLy8gVGhpcyAqc2hvdWxkKiBuZXZlciBoYXBwZW4sIGJ1dCBqdXN0IGluIGNhc2Ugd2UgdGhyb3cgaGVyZSB0byBzdXJmYWNlIGFueSBidWdzLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZW5jcnlwdCBtZXNzYWdlIHdpdGhvdXQgYSBwcml2YXRlIG1lc3NhZ2luZyBrZXknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgZW5jcnlwdENoYXRNZXNzYWdlKFxuICAgICAgcHJpbWFyeURlcml2ZWRLZXkubWVzc2FnaW5nUHJpdmF0ZUtleSxcbiAgICAgIHJlY2lwaWVudFB1YmxpY0tleUJhc2U1OENoZWNrLFxuICAgICAgbWVzc2FnZVBsYWluVGV4dFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIG1lc3NhZ2UgVGhpcyBpcyBhIG1lc3NhZ2Ugb2JqZWN0IHJldHVybmVkIGFueSBvZiB0aGUgbWVzc2FnZXNcbiAgICogZW5kcG9pbnRzIG9mIHRoZSBEZVNvIGJhY2tlbmQgYXBpLCBjb3VsZCBiZSBhIERNIG9yIGEgR3JvdXAgbWVzc2FnZS5cbiAgICogQHBhcmFtIGdyb3VwcyBUaGlzIGlzIGFuIGFycmF5IG9mIGdyb3VwIGNoYXRzIHRoZSB1c2VyIGJlbG9uZ3MgdG8uIFRoaXMgaXNcbiAgICogcmVxdWlyZWQgdG8gZGVjcnlwdCBncm91cCBtZXNzYWdlcy5cbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGRlY3J5cHRNZXNzYWdlKFxuICAgIG1lc3NhZ2U6IE5ld01lc3NhZ2VFbnRyeVJlc3BvbnNlLFxuICAgIGdyb3VwczogQWNjZXNzR3JvdXBFbnRyeVJlc3BvbnNlW11cbiAgKTogUHJvbWlzZTxEZWNyeXB0ZWRNZXNzYWdlRW50cnlSZXNwb25zZT4ge1xuICAgIGNvbnN0IHsgcHJpbWFyeURlcml2ZWRLZXksIHB1YmxpY0tleTogdXNlclB1YmxpY0tleUJhc2U1OENoZWNrIH0gPVxuICAgICAgKGF3YWl0IHRoaXMuI2dldEN1cnJlbnRVc2VyKCkpID8/IHt9O1xuICAgIGlmICghKHByaW1hcnlEZXJpdmVkS2V5Py5tZXNzYWdpbmdQcml2YXRlS2V5ICYmIHVzZXJQdWJsaWNLZXlCYXNlNThDaGVjaykpIHtcbiAgICAgIC8vIFRoaXMgKnNob3VsZCogbmV2ZXIgaGFwcGVuLCBidXQganVzdCBpbiBjYXNlIHdlIHRocm93IGhlcmUgdG8gc3VyZmFjZSBhbnkgYnVncy5cbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlY3J5cHQgbWVzc2FnZXMgd2l0aG91dCBhIGxvZ2dlZCBpbiB1c2VyJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNTZW5kZXIgPVxuICAgICAgbWVzc2FnZS5TZW5kZXJJbmZvLk93bmVyUHVibGljS2V5QmFzZTU4Q2hlY2sgPT09XG4gICAgICAgIHVzZXJQdWJsaWNLZXlCYXNlNThDaGVjayAmJlxuICAgICAgKG1lc3NhZ2UuU2VuZGVySW5mby5BY2Nlc3NHcm91cEtleU5hbWUgPT09IHRoaXMuI2RlZmF1bHRHcm91cE5hbWUgfHxcbiAgICAgICAgIW1lc3NhZ2UuU2VuZGVySW5mby5BY2Nlc3NHcm91cEtleU5hbWUpO1xuICAgIGxldCBEZWNyeXB0ZWRNZXNzYWdlID0gJyc7XG4gICAgbGV0IGVycm9yTXNnID0gJyc7XG5cbiAgICBzd2l0Y2ggKG1lc3NhZ2UuQ2hhdFR5cGUpIHtcbiAgICAgIGNhc2UgQ2hhdFR5cGUuRE06XG4gICAgICAgIGlmIChtZXNzYWdlLk1lc3NhZ2VJbmZvPy5FeHRyYURhdGE/LnVuZW5jcnlwdGVkKSB7XG4gICAgICAgICAgRGVjcnlwdGVkTWVzc2FnZSA9IHVuZW5jcnlwdGVkSGV4VG9QbGFpblRleHQoXG4gICAgICAgICAgICBtZXNzYWdlLk1lc3NhZ2VJbmZvLkVuY3J5cHRlZFRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBEZWNyeXB0ZWRNZXNzYWdlID0gYXdhaXQgdGhpcy4jZGVjcnlwdERNKFxuICAgICAgICAgICAgICB1c2VyUHVibGljS2V5QmFzZTU4Q2hlY2ssXG4gICAgICAgICAgICAgIHByaW1hcnlEZXJpdmVkS2V5Lm1lc3NhZ2luZ1ByaXZhdGVLZXksXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIGlzU2VuZGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgZXJyb3JNc2cgPSBlPy50b1N0cmluZygpID8/ICdDb3VsZCBub3QgZGVjcnlwdCBkaXJlY3QgbWVzc2FnZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDaGF0VHlwZS5HUk9VUENIQVQ6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRGVjcnlwdGVkTWVzc2FnZSA9IGF3YWl0IHRoaXMuI2RlY3J5cHRHcm91cENoYXQoZ3JvdXBzLCBtZXNzYWdlKTtcbiAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgZXJyb3JNc2cgPSBlPy50b1N0cmluZygpID8/ICdDb3VsZCBub3QgZGVjcnlwdCBncm91cCBtZXNzYWdlJztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIElmIHdlIGFkZCBuZXcgY2hhdCB0eXBlcywgd2UgbmVlZCB0byBhZGQgZXhwbGljaXQgc3VwcG9ydCBmb3IgdGhlbS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBjaGF0IHR5cGU6ICR7bWVzc2FnZS5DaGF0VHlwZX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4ubWVzc2FnZSxcbiAgICAgIC4uLnsgRGVjcnlwdGVkTWVzc2FnZSwgSXNTZW5kZXI6IGlzU2VuZGVyLCBlcnJvcjogZXJyb3JNc2cgfSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY3J5cHRzIHRoZSBlbmNyeXB0ZWQgYWNjZXNzIGdyb3VwIHByaXZhdGUga2V5IHRoYXQgd2Ugd2lsbCBuZWVkIHRvIHVzZSB0byBkZWNyeXB0IGdyb3VwIG1lc3NhZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0gZW5jcnlwdGVkS2V5SGV4XG4gICAqIEByZXR1cm5zIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdCB0aGUgZGVjcnlwdGVkIGtleSBwYWlyLlxuICAgKi9cbiAgYXN5bmMgZGVjcnlwdEFjY2Vzc0dyb3VwS2V5UGFpcihlbmNyeXB0ZWRLZXlIZXg6IHN0cmluZykge1xuICAgIGNvbnN0IHsgcHJpbWFyeURlcml2ZWRLZXkgfSA9IChhd2FpdCB0aGlzLiNnZXRDdXJyZW50VXNlcigpKSA/PyB7fTtcblxuICAgIGlmICghcHJpbWFyeURlcml2ZWRLZXk/Lm1lc3NhZ2luZ1ByaXZhdGVLZXkpIHtcbiAgICAgIC8vIFRoaXMgKnNob3VsZCogbmV2ZXIgaGFwcGVuLCBidXQganVzdCBpbiBjYXNlIHdlIHRocm93IGhlcmUgdG8gc3VyZmFjZSBhbnkgYnVncy5cbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQgbWVzc2FnZSB3aXRob3V0IGEgcHJpdmF0ZSBtZXNzYWdpbmcga2V5Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVjcnlwdGVkUHJpdmF0ZUtleUhleCA9IGF3YWl0IGRlY3J5cHQoXG4gICAgICBwcmltYXJ5RGVyaXZlZEtleS5tZXNzYWdpbmdQcml2YXRlS2V5LFxuICAgICAgZW5jcnlwdGVkS2V5SGV4XG4gICAgKTtcblxuICAgIHJldHVybiBrZXlnZW4oZGVjcnlwdGVkUHJpdmF0ZUtleUhleCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBrZXkgcGFpciBmb3IgYW4gYWNjZXNzIGdyb3VwLiBUaGlzIGlzIHVzZWQgdG8gZW5jcnlwdCBhbmRcbiAgICogZGVjcnlwdCBncm91cCBtZXNzYWdlcy5cbiAgICpcbiAgICogQHBhcmFtIGdyb3VwTmFtZSB0aGUgcGxhaW50ZXh0IG5hbWUgb2YgdGhlIGdyb3VwIGNoYXRcbiAgICogQHBhcmFtIG9wdGlvbnMubWVzc2FnaW5nUHJpdmF0ZUtleSB0aGUgb3B0aW9uYWwgbWVzc2FnaW5nIHByaXZhdGUga2V5XG4gICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBuZXcga2V5IGluZm8uXG4gICAqL1xuICBhc3luYyBhY2Nlc3NHcm91cFN0YW5kYXJkRGVyaXZhdGlvbihcbiAgICBncm91cE5hbWU6IHN0cmluZ1xuICApOiBQcm9taXNlPEFjY2Vzc0dyb3VwUHJpdmF0ZUluZm8+IHtcbiAgICBjb25zdCB7IHByaW1hcnlEZXJpdmVkS2V5IH0gPSAoYXdhaXQgdGhpcy4jZ2V0Q3VycmVudFVzZXIoKSkgPz8ge307XG5cbiAgICBpZiAoIXByaW1hcnlEZXJpdmVkS2V5Py5tZXNzYWdpbmdQcml2YXRlS2V5KSB7XG4gICAgICAvLyBUaGlzICpzaG91bGQqIG5ldmVyIGhhcHBlbiwgYnV0IGp1c3QgaW4gY2FzZSB3ZSB0aHJvdyBoZXJlIHRvIHN1cmZhY2UgYW55IGJ1Z3MuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZXJpdmUgYWNjZXNzIGdyb3VwIHdpdGhvdXQgYSBtZXNzYWdpbmcga2V5Jyk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IGRlcml2ZUFjY2Vzc0dyb3VwS2V5UGFpcihcbiAgICAgIHByaW1hcnlEZXJpdmVkS2V5Py5tZXNzYWdpbmdQcml2YXRlS2V5LFxuICAgICAgZ3JvdXBOYW1lXG4gICAgKTtcbiAgICBjb25zdCBwdWJsaWNLZXlCYXNlNThDaGVjayA9IHB1YmxpY0tleVRvQmFzZTU4Q2hlY2soa2V5cy5wdWJsaWMsIHtcbiAgICAgIG5ldHdvcms6IHRoaXMuI25ldHdvcmssXG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgQWNjZXNzR3JvdXBQcml2YXRlS2V5SGV4OiBrZXlzLnNlZWRIZXgsXG4gICAgICBBY2Nlc3NHcm91cFB1YmxpY0tleUJhc2U1OENoZWNrOiBwdWJsaWNLZXlCYXNlNThDaGVjayxcbiAgICAgIEFjY2Vzc0dyb3VwS2V5TmFtZTogZ3JvdXBOYW1lLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgand0IHRva2VuIHNpZ25lZCBieSB0aGUgZGVyaXZlZCBrZXkgaXNzdWVkIHRvIHRoZSBjdXJyZW50bHkgYWN0aXZlIHVzZXIuIFRoaXMgY2FuIGJlIHVzZWQgdG8gcGFzcyB0b1xuICAgKiBhdXRoZW50aWNhdGVkIGVuZHBvaW50cyBvbiB0aGUgRGVTbyBiYWNrZW5kIGFwaSBvciB0byBjcmVhdGUgYXV0aGVudGljYXRlZCBlbmRwb2ludHMgb24geW91ciBvd24gYmFja2VuZC5cbiAgICogVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB1c2VkIHRvIGNvbnN0cnVjdCBhbiBBdXRob3JpemF0aW9uIGhlYWRlciBvciBwYXNzIGFzIGEgcGFyYW1ldGVyIGluIGEgcG9zdCBib2R5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHRva2VuID0gYXdhaXQgaWRlbnRpdHkuand0KCk7XG4gICAqXG4gICAqIGNvbnN0IGF1dGhIZWFkZXJzID0ge1xuICAgKiAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgKiB9XG4gICAqXG4gICAqIG15QXBpQ2xpZW50LnBvc3QoJ2h0dHBzOi8vbXlhcGkuY29tL3NvbWUtYXV0aGVudGljYXRlZC1lbmRwb2ludCcsIHsgLi4uZGF0YSB9LCB7IGhlYWRlcnM6IGF1dGhIZWFkZXJzIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGp3dCgpIHtcbiAgICBjb25zdCB7IHByaW1hcnlEZXJpdmVkS2V5IH0gPSAoYXdhaXQgdGhpcy4jZ2V0Q3VycmVudFVzZXIoKSkgPz8ge307XG5cbiAgICBpZiAoIXByaW1hcnlEZXJpdmVkS2V5Py5kZXJpdmVkU2VlZEhleCkge1xuICAgICAgLy8gVGhpcyAqc2hvdWxkKiBuZXZlciBoYXBwZW4sIGJ1dCBqdXN0IGluIGNhc2Ugd2UgdGhyb3cgaGVyZSB0byBzdXJmYWNlIGFueSBidWdzLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2lnbiBqd3Qgd2l0aG91dCBhIGRlcml2ZWQgc2VlZCBoZXgnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgZ2V0U2lnbmVkSldUKFxuICAgICAgcHJpbWFyeURlcml2ZWRLZXkuZGVyaXZlZFNlZWRIZXgsXG4gICAgICB0aGlzLiNqd3RBbGdvcml0aG0sXG4gICAgICB7XG4gICAgICAgIGRlcml2ZWRQdWJsaWNLZXlCYXNlNThDaGVjazpcbiAgICAgICAgICBwcmltYXJ5RGVyaXZlZEtleS5kZXJpdmVkUHVibGljS2V5QmFzZTU4Q2hlY2ssXG4gICAgICAgIGV4cGlyYXRpb246IDYwICogMTAsXG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIG9wZW4gYSBuZXcgaWRlbnRpdHkgd2luZG93IHdpdGggYSBvcHRpb25zIGZvciBnZXR0aW5nIGRlc29cbiAgICogYnkgdmVyaWZ5aW5nIGEgcGhvbmUgbnVtYmVyIG9yIGJ1eWluZy90cmFuc2ZlcnJpbmcgZGVzbyBhbm9ueW1vdXNseSBmb3IgdGhlXG4gICAqIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlci4gTk9URTogQSB1c2VyIG11c3QgYWxyZWFkeSBiZSBsb2dnZWQgaW4gdG8gdXNlXG4gICAqIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGF3YWl0IGlkZW50aXR5LmdldERlc28oKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBnZXREZXNvKCkge1xuICAgIGNvbnN0IGV2ZW50ID0gTk9USUZJQ0FUSU9OX0VWRU5UUy5HRVRfRlJFRV9ERVNPX1NUQVJUO1xuICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgdGhpcy4jZ2V0U3RhdGUoKTtcbiAgICB0aGlzLiNzdWJzY3JpYmVycy5mb3JFYWNoKChzKSA9PiBzKHsgZXZlbnQsIC4uLnN0YXRlIH0pKTtcblxuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBhY3RpdmVQdWJsaWNLZXkgPSB0aGlzLiNnZXRBY3RpdmVQdWJsaWNLZXkoKTtcbiAgICAgIGNvbnN0IGxhdW5jaElkZW50aXR5ID0gKGFjdGl2ZVB1YmxpY0tleTogc3RyaW5nIHwgbnVsbCkgPT4ge1xuICAgICAgICB0aGlzLiNwZW5kaW5nV2luZG93UmVxdWVzdCA9IHsgcmVzb2x2ZSwgcmVqZWN0LCBldmVudCB9O1xuXG4gICAgICAgIGlmICghYWN0aXZlUHVibGljS2V5KSB7XG4gICAgICAgICAgdGhpcy4jcGVuZGluZ1dpbmRvd1JlcXVlc3QucmVqZWN0KFxuICAgICAgICAgICAgbmV3IEVycm9yKCdDYW5ub3QgZ2V0IGZyZWUgZGVzbyB3aXRob3V0IGEgbG9nZ2VkIGluIHVzZXInKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4jbGF1bmNoSWRlbnRpdHkoJ2dldC1kZXNvJywge1xuICAgICAgICAgIHB1YmxpY0tleTogYWN0aXZlUHVibGljS2V5LFxuICAgICAgICAgIGdldEZyZWVEZXNvOiB0cnVlLFxuICAgICAgICAgIHNob3dTa2lwOiB0aGlzLiNzaG93U2tpcCxcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBOT1RFOiBpbiB0aGUgY2FzZSBvZiBhIGJyb3dzZXIgY29udGV4dCwgd2UgYXJlIHVzaW5nIHN5bmNocm9ub3VzIGxvY2FsXG4gICAgICAvLyBzdG9yYWdlLCBXZSBjYW5ub3QgaW50cm9kdWNlIGFueSBhc3luYyBvcGVyYXRpb25zIGJlY2F1c2UgaXQgbWF5XG4gICAgICAvLyB0cmlnZ2VyIHBvcHVwIGJsb2NrZXJzLCB3aGljaCBpcyB3aHkgd2UgbmVlZCB0byBicmFuY2ggdGhlIGxvZ2ljIGxpa2VcbiAgICAgIC8vIHRoaXMuXG4gICAgICBpZiAodHlwZW9mIGFjdGl2ZVB1YmxpY0tleSA9PT0gJ3N0cmluZycgfHwgYWN0aXZlUHVibGljS2V5ID09PSBudWxsKSB7XG4gICAgICAgIGxhdW5jaElkZW50aXR5KGFjdGl2ZVB1YmxpY0tleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVQdWJsaWNLZXk/LnRoZW4obGF1bmNoSWRlbnRpdHkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHZlcnkgc2ltaWxhciB0byBnZXREZXNvLCBidXQgaXQgd2lsbCBvbmx5IHByZXNlbnQgdGhlIG9wdGlvblxuICAgKiBmb3IgdmVyaWZ5aW5nIGEgcGhvbmUgbnVtYmVyIHRvIGdldCBkZXNvLiBBbHNvIHJlcXVpcmVzIGEgdXNlciB0byBiZSBsb2dnZWQgaW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogYXdhaXQgaWRlbnRpdHkudmVyaWZ5UGhvbmVOdW1iZXIoKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyB2ZXJpZnlQaG9uZU51bWJlcigpIHtcbiAgICBjb25zdCBldmVudCA9IE5PVElGSUNBVElPTl9FVkVOVFMuVkVSSUZZX1BIT05FX05VTUJFUl9TVEFSVDtcbiAgICBjb25zdCBzdGF0ZSA9IGF3YWl0IHRoaXMuI2dldFN0YXRlKCk7XG4gICAgdGhpcy4jc3Vic2NyaWJlcnMuZm9yRWFjaCgocykgPT4gcyh7IGV2ZW50LCAuLi5zdGF0ZSB9KSk7XG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGFjdGl2ZVB1YmxpY0tleSA9IHRoaXMuI2dldEFjdGl2ZVB1YmxpY0tleSgpO1xuICAgICAgY29uc3QgbGF1bmNoSWRlbnRpdHkgPSAoYWN0aXZlUHVibGljS2V5OiBzdHJpbmcgfCBudWxsKSA9PiB7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdXaW5kb3dSZXF1ZXN0ID0geyByZXNvbHZlLCByZWplY3QsIGV2ZW50IH07XG5cbiAgICAgICAgaWYgKCFhY3RpdmVQdWJsaWNLZXkpIHtcbiAgICAgICAgICB0aGlzLiNwZW5kaW5nV2luZG93UmVxdWVzdC5yZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3IoJ0Nhbm5vbiB2ZXJpZnkgcGhvbmUgbnVtYmVyIHdpdGhvdXQgYW4gYWN0aXZlIHVzZXInKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNsYXVuY2hJZGVudGl0eSgndmVyaWZ5LXBob25lLW51bWJlcicsIHtcbiAgICAgICAgICBwdWJsaWNfa2V5OiBhY3RpdmVQdWJsaWNLZXksXG4gICAgICAgICAgc2hvd1NraXA6IHRoaXMuI3Nob3dTa2lwLFxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE5PVEU6IGluIHRoZSBjYXNlIG9mIGEgYnJvd3NlciBjb250ZXh0LCB3ZSBhcmUgdXNpbmcgc3luY2hyb25vdXMgbG9jYWxcbiAgICAgIC8vIHN0b3JhZ2UsIFdlIGNhbm5vdCBpbnRyb2R1Y2UgYW55IGFzeW5jIG9wZXJhdGlvbnMgYmVjYXVzZSBpdCBtYXlcbiAgICAgIC8vIHRyaWdnZXIgcG9wdXAgYmxvY2tlcnMsIHdoaWNoIGlzIHdoeSB3ZSBuZWVkIHRvIGJyYW5jaCB0aGUgbG9naWMgbGlrZVxuICAgICAgLy8gdGhpcy5cbiAgICAgIGlmICh0eXBlb2YgYWN0aXZlUHVibGljS2V5ID09PSAnc3RyaW5nJyB8fCBhY3RpdmVQdWJsaWNLZXkgPT09IG51bGwpIHtcbiAgICAgICAgbGF1bmNoSWRlbnRpdHkoYWN0aXZlUHVibGljS2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2ZVB1YmxpY0tleT8udGhlbihsYXVuY2hJZGVudGl0eSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBzZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgdXNlci4gVGhpcyBpcyB1c2VmdWwgZm9yIGNoYW5naW5nXG4gICAqIGFjY291bnRzIHdoZW4gYSB1c2VyIGhhcyBsb2dnZWQgaW50byBhbiBhcHBsaWNhdGlvbiB3aXRoIG11bHRpcGxlIGFjY291bnRzLlxuICAgKiBOT1RFOiBUaGlzIG1ldGhvZCB3aWxsIG5vdCB0cmlnZ2VyIGEgbG9naW4gZXZlbnQsIGJ1dCwgcmF0aGVyLCBpdCB3aWxsIGRvIGFcbiAgICogbG9va3VwIG9uIGFsbCB0aGUgdXNlcnMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBsb2dnZWQgaW4gdG8gZmluZCB0aGUgdXNlclxuICAgKiB3aXRoIHRoZSBtYXRjaGluZyBwdWJsaWMga2V5LiAgSWYgdGhlIGtleSBpcyBub3QgZm91bmQsIGl0IHdpbGwgdGhyb3cgYW5cbiAgICogZXJyb3IuIFRoZSB1c2VycyB0aGF0IGFyZSBhdmFpbGFibGUgdG8gYmUgc2V0IGFzIGFjdGl2ZSBhcmUgcHJvdmlkZWQgdmlhXG4gICAqIHRoZSBgYWx0ZXJuYXRlVXNlcnNgIHByb3BlcnR5IG9uIHRoZSBzdGF0ZSBvYmplY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaWRlbnRpdHkuc2V0QWN0aXZlVXNlcihzb21lTG9nZ2VkSW5QdWJsaWNLZXkpO1xuICAgKiBgYGBcbiAgICovXG4gIHNldEFjdGl2ZVVzZXIocHVibGljS2V5OiBzdHJpbmcpOiBUIGV4dGVuZHMgU3RvcmFnZSA/IHZvaWQgOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBtYXliZVByb21pc2UgPSB0aGlzLiNzZXRBY3RpdmVVc2VyKHB1YmxpY0tleSk7XG4gICAgaWYgKHR5cGVvZiBtYXliZVByb21pc2U/LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIHdlJ3JlIGluIGFzeW5jIHN0b3JhZ2UgbW9kZVxuICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc25hcHNob3RQcm9taXNlID0gdGhpcy5zbmFwc2hvdCgpIGFzIFByb21pc2U8SWRlbnRpdHlTdGF0ZT47XG4gICAgICAgIHJldHVybiBzbmFwc2hvdFByb21pc2UudGhlbigoc3RhdGUpID0+IHtcbiAgICAgICAgICB0aGlzLnJlZnJlc2hEZXJpdmVkS2V5UGVybWlzc2lvbnMoKTtcbiAgICAgICAgICB0aGlzLiNzdWJzY3JpYmVycy5mb3JFYWNoKChzKSA9PlxuICAgICAgICAgICAgcyh7XG4gICAgICAgICAgICAgIGV2ZW50OiBOT1RJRklDQVRJT05fRVZFTlRTLkNIQU5HRV9BQ1RJVkVfVVNFUixcbiAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSkgYXMgVCBleHRlbmRzIFN0b3JhZ2UgPyB2b2lkIDogUHJvbWlzZTx2b2lkPjtcbiAgICB9XG5cbiAgICAvLyBzeW5jIHN0b3JhZ2VcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuI2dldFN0YXRlKCkgYXMgSWRlbnRpdHlTdGF0ZTtcbiAgICB0aGlzLnJlZnJlc2hEZXJpdmVkS2V5UGVybWlzc2lvbnMoKTtcbiAgICB0aGlzLiNzdWJzY3JpYmVycy5mb3JFYWNoKChzKSA9PlxuICAgICAgcyh7XG4gICAgICAgIGV2ZW50OiBOT1RJRklDQVRJT05fRVZFTlRTLkNIQU5HRV9BQ1RJVkVfVVNFUixcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICB9KVxuICAgICk7XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkIGFzIFQgZXh0ZW5kcyBTdG9yYWdlID8gdm9pZCA6IFByb21pc2U8dm9pZD47XG4gIH1cblxuICAvKipcbiAgICogUmVsb2FkcyB0aGUgZGVyaXZlZCBrZXkgcGVybWlzc2lvbnMgZm9yIHRoZSBhY3RpdmUgdXNlci4gTk9URTogSW4gZ2VuZXJhbFxuICAgKiBjb25zdW1lcnMgc2hvdWxkIG5vdCBuZWVkIHRvIGNhbGwgdGhpcyBkaXJlY3RseSwgYnV0IGl0IGlzIGV4cG9zZWQgZm9yXG4gICAqIGFkdmFuY2VkIHVzZSBjYXNlcy4gV2UgY2FsbCB0aGlzIGludGVybmFsbHkgYW55IHRpbWUgZGVyaXZlZCBrZXlcbiAgICogcGVybWlzc2lvbnMgYXJlIHVwZGF0ZWQsIGEgdHJhbnNhY3Rpb24gaXMgc3VibWl0dGVkLCBvciB0aGUgbG9nZ2VkIGluIHVzZXJcbiAgICogY2hhbmdlcy5cbiAgICogQHJldHVybnMgdm9pZFxuICAgKi9cbiAgYXN5bmMgcmVmcmVzaERlcml2ZWRLZXlQZXJtaXNzaW9ucygpIHtcbiAgICBjb25zdCB7IHByaW1hcnlEZXJpdmVkS2V5IH0gPSAoYXdhaXQgdGhpcy4jZ2V0Q3VycmVudFVzZXIoKSkgPz8ge307XG5cbiAgICBpZiAoXG4gICAgICBwcmltYXJ5RGVyaXZlZEtleSA9PSBudWxsIHx8XG4gICAgICBwcmltYXJ5RGVyaXZlZEtleS5kZXJpdmVkS2V5UmVnaXN0ZXJlZCA9PT0gZmFsc2VcbiAgICApIHtcbiAgICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgYSBsb2dnZWQgaW4gdXNlciwgd2UganVzdCBiYWlsXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLiNhcGkuZ2V0KFxuICAgICAgICBgJHt0aGlzLiNub2RlVVJJfS9hcGkvdjAvZ2V0LXNpbmdsZS1kZXJpdmVkLWtleS8ke1xuICAgICAgICAgIHByaW1hcnlEZXJpdmVkS2V5LnB1YmxpY0tleUJhc2U1OENoZWNrXG4gICAgICAgIH0vJHtwcmltYXJ5RGVyaXZlZEtleS5kZXJpdmVkUHVibGljS2V5QmFzZTU4Q2hlY2t9YFxuICAgICAgKTtcbiAgICAgIGF3YWl0IHRoaXMuI3VwZGF0ZVVzZXIocHJpbWFyeURlcml2ZWRLZXkucHVibGljS2V5QmFzZTU4Q2hlY2ssIHtcbiAgICAgICAgcHJpbWFyeURlcml2ZWRLZXk6IHtcbiAgICAgICAgICAuLi5wcmltYXJ5RGVyaXZlZEtleSxcbiAgICAgICAgICB0cmFuc2FjdGlvblNwZW5kaW5nTGltaXRzOlxuICAgICAgICAgICAgcmVzcC5EZXJpdmVkS2V5Py5UcmFuc2FjdGlvblNwZW5kaW5nTGltaXQgPz8gbnVsbCxcbiAgICAgICAgICBJc1ZhbGlkOiAhIXJlc3AuRGVyaXZlZEtleT8uSXNWYWxpZCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFRPRE86IGhhbmRsZSB0aGlzIGJldHRlcj9cbiAgICAgIGlmICh0aGlzLiN3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIGluIGEgYnJvd3NlciBjb250ZXh0IHdoZXJlIGxvY2FsU3RvcmFnZSBpcyB1c2VkIGFzIHRoZSBzdG9yYWdlXG4gICAqIHByb3ZpZGVyLCBhbmQgaXQgaXMgbmVjZXNzYXJ5IHRvIGNoZWNrIHBlcm1pc3Npb25zIHN5bmNocm9ub3VzbHkgdG8gcHJldmVudFxuICAgKiBpc3N1ZXMgd2l0aCBwb3AgdXAgYmxvY2tlcnMuIElmIGEgdXNlcidzIGRlcml2ZWQga2V5IGhhcyB0aGUgcGVybWlzc2lvbnMgdG9cbiAgICogcGVyZm9ybSBhIGdpdmVuIGFjdGlvbiBvciBiYXRjaCBvZiBhY3Rpb25zLiBUaGUgcGVybWlzc2lvbnMgYXJlIHBhc3NlZCBpblxuICAgKiBhcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyB0aGVcbiAgICogYFRyYW5zYWN0aW9uU3BlbmRpbmdMaW1pdFJlc3BvbnNlT3B0aW9uc2AgdHlwZSwgd2hpY2ggaXMgdGhlIHNhbWUgYXMgdGhlXG4gICAqIGBzcGVuZGluZ0xpbWl0T3B0aW9uc2AgcGFzc2VkIHRvIHRoZSBjb25maWd1cmUgbWV0aG9kLlxuICAgKlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBIZXJlIHdlIGNoZWNrIGlmIHRoZSB1c2VyIGhhcyB0aGUgcGVybWlzc2lvbnMgdG8gc3VibWl0IGF0IGxlYXN0IDEgcG9zdC5cbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBoYXNQZXJtaXNzaW9ucyA9IGlkZW50aXR5Lmhhc1Blcm1pc3Npb25zKHtcbiAgICogICBUcmFuc2FjdGlvbkNvdW50TGltaXRNYXA6IHtcbiAgICogICAgIFNVQk1JVF9QT1NUOiAxLFxuICAgKiAgICB9LFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICBoYXNQZXJtaXNzaW9ucyhcbiAgICBwZXJtaXNzaW9uc1RvQ2hlY2s6IFBhcnRpYWw8VHJhbnNhY3Rpb25TcGVuZGluZ0xpbWl0UmVzcG9uc2VPcHRpb25zPlxuICApOiBUIGV4dGVuZHMgU3RvcmFnZSA/IGJvb2xlYW4gOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoT2JqZWN0LmtleXMocGVybWlzc2lvbnNUb0NoZWNrKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcGFzcyBhdCBsZWFzdCBvbmUgcGVybWlzc2lvbiB0byBjaGVjaycpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXJzID0gdGhpcy4jZ2V0VXNlcnMoKTtcbiAgICBjb25zdCBjaGVja1Blcm1pc3Npb25zID0gKFxuICAgICAgdXNlcnM6IFJlY29yZDxzdHJpbmcsIFN0b3JlZFVzZXI+IHwgbnVsbCxcbiAgICAgIGFjdGl2ZUtleTogc3RyaW5nIHwgbnVsbFxuICAgICkgPT4ge1xuICAgICAgaWYgKCEodXNlcnMgJiYgYWN0aXZlS2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2UgYXMgYW55O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhY3RpdmVVc2VyID0gKHVzZXJzIGFzIFJlY29yZDxzdHJpbmcsIFN0b3JlZFVzZXI+KVtcbiAgICAgICAgYWN0aXZlS2V5IGFzIHN0cmluZ1xuICAgICAgXTtcblxuICAgICAgY29uc3QgeyBwcmltYXJ5RGVyaXZlZEtleSB9ID0gYWN0aXZlVXNlciA/PyB7fTtcblxuICAgICAgLy8gSWYgdGhlIGtleSBpcyBleHBpcmVkLCB1bmF1dGhvcml6ZWQsIG9yIGhhcyBubyBtb25leSB3ZSBjYW4ndCBkbyBhbnl0aGluZyB3aXRoIGl0XG4gICAgICBpZiAoXG4gICAgICAgICFwcmltYXJ5RGVyaXZlZEtleT8uSXNWYWxpZCB8fFxuICAgICAgICBwcmltYXJ5RGVyaXZlZEtleT8uZGVyaXZlZEtleVJlZ2lzdGVyZWQgPT09IGZhbHNlXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlIGFzIGFueTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlIGtleSBoYXMgbm8gc3BlbmRpbmcgbGltaXRzLCB3ZSBjYW4ndCBkbyBhbnl0aGluZyB3aXRoIGl0XG4gICAgICBpZiAoIXByaW1hcnlEZXJpdmVkS2V5Py50cmFuc2FjdGlvblNwZW5kaW5nTGltaXRzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZSBhcyBhbnk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb21wYXJlVHJhbnNhY3Rpb25TcGVuZGluZ0xpbWl0cyhcbiAgICAgICAgcGVybWlzc2lvbnNUb0NoZWNrLFxuICAgICAgICBwcmltYXJ5RGVyaXZlZEtleS50cmFuc2FjdGlvblNwZW5kaW5nTGltaXRzXG4gICAgICApO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHVzZXJzPy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBhc3luYyBtb2RlXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3VzZXJzLCB0aGlzLiNnZXRBY3RpdmVQdWJsaWNLZXkoKV0pLnRoZW4oXG4gICAgICAgIChbdXNlcnMsIGFjdGl2ZUtleV0pID0+IGNoZWNrUGVybWlzc2lvbnModXNlcnMsIGFjdGl2ZUtleSlcbiAgICAgICkgYXMgYW55O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzeW5jIG1vZGVcbiAgICAgIGNvbnN0IGFjdGl2ZUtleSA9IHRoaXMuI2dldEFjdGl2ZVB1YmxpY0tleSgpO1xuICAgICAgcmV0dXJuIGNoZWNrUGVybWlzc2lvbnMoXG4gICAgICAgIHVzZXJzIGFzIFJlY29yZDxzdHJpbmcsIFN0b3JlZFVzZXI+LFxuICAgICAgICBhY3RpdmVLZXkgYXMgc3RyaW5nXG4gICAgICApIGFzIGFueTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgd2lsbCByZXF1ZXN0IHBlcm1pc3Npb25zIGZyb20gdGhlIHVzZXIgdG8gcGVyZm9ybSBhbiBhY3Rpb24gb3JcbiAgICogYmF0Y2ggb2YgYWN0aW9ucy4gSXQgd2lsbCBvcGVuIGFuIGlkZW50aXR5IHdpbmRvdyBhbmQgcHJvbXB0IHRoZSB1c2VyIHRvXG4gICAqIGFwcHJvdmUgdGhlIHBlcm1pc3Npb25zIHJlcXVlc3RlZC4gSXQgYWxzbyB0YWtlcyBhXG4gICAqIGBUcmFuc2FjdGlvblNwZW5kaW5nTGltaXRSZXNwb25zZU9wdGlvbnNgIG9iamVjdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBhd2FpdCBpZGVudGl0eS5yZXF1ZXN0UGVybWlzc2lvbnMoe1xuICAgKiAgIFRyYW5zYWN0aW9uQ291bnRMaW1pdE1hcDoge1xuICAgKiAgICAgU1VCTUlUX1BPU1Q6ICdVTkxJTUlURUQnLFxuICAgKiAgICB9LFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyByZXF1ZXN0UGVybWlzc2lvbnMoXG4gICAgdHJhbnNhY3Rpb25TcGVuZGluZ0xpbWl0UmVzcG9uc2U6IFBhcnRpYWw8VHJhbnNhY3Rpb25TcGVuZGluZ0xpbWl0UmVzcG9uc2VPcHRpb25zPlxuICApIHtcbiAgICBjb25zdCB7IHByaW1hcnlEZXJpdmVkS2V5IH0gPSAoYXdhaXQgdGhpcy4jZ2V0Q3VycmVudFVzZXIoKSkgPz8ge307XG4gICAgaWYgKHByaW1hcnlEZXJpdmVkS2V5ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlcXVlc3QgcGVybWlzc2lvbnMgd2l0aG91dCBhIGxvZ2dlZCBpbiB1c2VyJyk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBwdWJsaWNLZXlCYXNlNThDaGVjaywgZGVyaXZlZFB1YmxpY0tleUJhc2U1OENoZWNrIH0gPVxuICAgICAgcHJpbWFyeURlcml2ZWRLZXk7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kZXJpdmUodHJhbnNhY3Rpb25TcGVuZGluZ0xpbWl0UmVzcG9uc2UsIHtcbiAgICAgIG93bmVyUHVibGljS2V5OiBwdWJsaWNLZXlCYXNlNThDaGVjayxcbiAgICAgIGRlcml2ZWRQdWJsaWNLZXk6IGRlcml2ZWRQdWJsaWNLZXlCYXNlNThDaGVjayxcbiAgICAgIGV4cGlyYXRpb25EYXlzOiB0aGlzLiNkZWZhdWx0TnVtRGF5c0JlZm9yZUV4cGlyYXRpb24sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBpc3N1ZSBhIGRlcml2ZSByZXF1ZXN0IHRvIGlkZW50aXR5IHdoaWNoIGNhbiBiZSB1c2VkIHRvXG4gICAqIGVpdGhlciBjcmVhdGUgYSBuZXcgZGVyaXZlZCBrZXkgb3IgdG8gdXBkYXRlIGFuIGV4aXN0aW5nIGRlcml2ZWQga2V5LiAgSXRcbiAgICogd2lsbCBvcGVuIGFuIGlkZW50aXR5IHdpbmRvdyBhbmQgcHJvbXB0IHRoZSB1c2VyIHRvIGFwcHJvdmUgdGhlIGFjdGlvbiBmb3JcbiAgICogdGhlIGRlcml2ZWQga2V5LiBJdCBvcHRpb25hbGx5IHRha2UgYW4gZXhpc3RpbmcgZGVyaXZlZCBrZXkgYW5kL29yIGFuIG93bmVyXG4gICAqIHB1YmxpYyBrZXkuIElmIHRoZSBvd25lciBrZXkgaXMgbm90IHByb3ZpZGVkLCB0aGUgdXNlciB3aWxsIGZpcnN0IGJlIGFza2VkXG4gICAqIHRvIGxvZ2luIG9yIGNyZWF0ZSBhbiBhY2NvdW50LiBPdGhlcndpc2UgdGhlIHVzZXIgd2lsbCBiZSBwcm9tcHRlZCB3aXRoIHRoZVxuICAgKiBkZXJpdmVkIGtleSBhcHByb3ZhbCB3aW5kb3cgaW1tZWRpYXRlbHkuIElmIGEgZGVyaXZlZCBrZXkgaXMgbm90IHByb3ZpZGVkLFxuICAgKiBhIG5ldyBvbmUgd2lsbCBiZSBjcmVhdGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGF3YWl0IGlkZW50aXR5LmRlcml2ZSh7XG4gICAqICAgVHJhbnNhY3Rpb25Db3VudExpbWl0TWFwOiB7XG4gICAqICAgICBTVUJNSVRfUE9TVDogJ1VOTElNSVRFRCcsXG4gICAqICAgIH0sXG4gICAqIH0sIHtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZGVyaXZlKFxuICAgIHRyYW5zYWN0aW9uU3BlbmRpbmdMaW1pdFJlc3BvbnNlOiBQYXJ0aWFsPFRyYW5zYWN0aW9uU3BlbmRpbmdMaW1pdFJlc3BvbnNlT3B0aW9ucz4sXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIGRlcml2ZWRQdWJsaWNLZXk/OiBzdHJpbmc7XG4gICAgICBleHBpcmF0aW9uRGF5cz86IG51bWJlcjtcbiAgICAgIGRlbGV0ZUtleT86IGJvb2xlYW47XG4gICAgICBvd25lclB1YmxpY0tleT86IHN0cmluZztcbiAgICB9XG4gICk6IFByb21pc2U8SWRlbnRpdHlEZXJpdmVQYXlsb2FkPiB7XG4gICAgY29uc3QgZXZlbnQgPSBOT1RJRklDQVRJT05fRVZFTlRTLlJFUVVFU1RfUEVSTUlTU0lPTlNfU1RBUlQ7XG4gICAgY29uc3Qgc3RhdGUgPSBhd2FpdCB0aGlzLiNnZXRTdGF0ZSgpO1xuICAgIHRoaXMuI3N1YnNjcmliZXJzLmZvckVhY2goKHMpID0+IHMoeyBldmVudCwgLi4uc3RhdGUgfSkpO1xuXG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuI3BlbmRpbmdXaW5kb3dSZXF1ZXN0ID0geyByZXNvbHZlLCByZWplY3QsIGV2ZW50IH07XG5cbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgZGVyaXZlOiB0cnVlLFxuICAgICAgICAuLi4oISFvcHRpb25zPy5kZXJpdmVkUHVibGljS2V5ICYmIHtcbiAgICAgICAgICBkZXJpdmVkUHVibGljS2V5OiBvcHRpb25zLmRlcml2ZWRQdWJsaWNLZXksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4oISFvcHRpb25zPy5leHBpcmF0aW9uRGF5cyAmJiB7XG4gICAgICAgICAgZXhwaXJhdGlvbkRheXM6IG9wdGlvbnMuZXhwaXJhdGlvbkRheXMsXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4oISFvcHRpb25zPy5kZWxldGVLZXkgJiYge1xuICAgICAgICAgIGRlbGV0ZUtleTogb3B0aW9ucy5kZWxldGVLZXksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4oISFvcHRpb25zPy5vd25lclB1YmxpY0tleSAmJiB7IHB1YmxpY0tleTogb3B0aW9ucy5vd25lclB1YmxpY0tleSB9KSxcbiAgICAgICAgdHJhbnNhY3Rpb25TcGVuZGluZ0xpbWl0UmVzcG9uc2U6IGJ1aWxkVHJhbnNhY3Rpb25TcGVuZGluZ0xpbWl0UmVzcG9uc2UoXG4gICAgICAgICAgdHJhbnNhY3Rpb25TcGVuZGluZ0xpbWl0UmVzcG9uc2VcbiAgICAgICAgKSxcbiAgICAgICAgc2hvd1NraXA6IHRoaXMuI3Nob3dTa2lwLFxuICAgICAgfTtcblxuICAgICAgdGhpcy4jbGF1bmNoSWRlbnRpdHkoJ2Rlcml2ZScsIHBhcmFtcyk7XG4gICAgfSk7XG4gIH1cblxuICBkZXNvQWRkcmVzc1RvRXRoZXJldW1BZGRyZXNzKGFkZHJlc3M6IHN0cmluZykge1xuICAgIGNvbnN0IGRlc29QS0J5dGVzID0gYnM1OFB1YmxpY0tleVRvQnl0ZXMoYWRkcmVzcykuc2xpY2UoMSk7XG4gICAgY29uc3QgZXRoUEtIZXggPSBlY1V0aWxzLmJ5dGVzVG9IZXgoa2VjY2FrXzI1NihkZXNvUEtCeXRlcykpLnNsaWNlKDI0KTtcbiAgICAvLyBFSVAtNTUgcmVxdWlyZXMgYSBjaGVja3N1bS4gUmVmZXJlbmNlIGltcGxlbWVudGF0aW9uOiBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTU1XG4gICAgY29uc3QgY2hlY2tzdW0gPSBlY1V0aWxzLmJ5dGVzVG9IZXgoa2VjY2FrXzI1NihldGhQS0hleCkpO1xuXG4gICAgcmV0dXJuIEFycmF5LmZyb20oZXRoUEtIZXgpLnJlZHVjZShcbiAgICAgIChldGhBZGRyZXNzLCBjaGFyLCBpbmRleCkgPT5cbiAgICAgICAgZXRoQWRkcmVzcyArXG4gICAgICAgIChwYXJzZUludChjaGVja3N1bVtpbmRleF0sIDE2KSA+PSA4ID8gY2hhci50b1VwcGVyQ2FzZSgpIDogY2hhciksXG4gICAgICAnMHgnXG4gICAgKTtcbiAgfVxuXG4gIC8vIFRPRE86IG1ha2Ugc3VyZSB0aGlzIHdvcmtzIGFuZCB3cml0ZSBhIHRlc3QgZm9yIGl0Li4uXG4gIGFzeW5jIGV0aGVyZXVtQWRkcmVzc1RvRGVzb0FkZHJlc3MoYWRkcmVzczogc3RyaW5nKSB7XG4gICAgaWYgKCEvXjB4W2EtZkEtRjAtOV17NDB9JC8udGVzdChhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEV0aGVyZXVtIGFkZHJlc3MnKTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBhd2FpdCB0aGlzLiNnZXRFVEhUcmFuc2FjdGlvbnNTaWduZWRCeUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgaWYgKHRyYW5zYWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEVUSCBhZGRyZXNzIG11c3Qgc2lnbiBhdCBsZWFzdCBvbmUgdHJhbnNhY3Rpb24gaW4gb3JkZXIgdG8gcmVjb3ZlciBpdHMgcHVibGljIGtleTogJHthZGRyZXNzfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZXRoTmV0ID0gREVTT19ORVRXT1JLX1RPX0VUSF9ORVRXT1JLW3RoaXMuI25ldHdvcmtdO1xuICAgIGxldCBldGhlcmV1bVB1YmxpY0tleSA9ICcnO1xuXG4gICAgZm9yIChjb25zdCB7IGhhc2ggfSBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLiNxdWVyeUVUSFJQQyh7XG4gICAgICAgICAgTWV0aG9kOiAnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJyxcbiAgICAgICAgICBQYXJhbXM6IFtoYXNoXSxcbiAgICAgICAgICBVc2VOZXR3b3JrOiBldGhOZXQsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0eG4gPSByZXNwLnJlc3VsdCBhcyBJbmZ1cmFUeDtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gZXRoZXJzLnV0aWxzLmpvaW5TaWduYXR1cmUoe1xuICAgICAgICAgIHI6IHR4bi5yLFxuICAgICAgICAgIHM6IHR4bi5zLFxuICAgICAgICAgIHY6IHBhcnNlSW50KHR4bi52LCAxNiksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNwZWNpYWwgdGhhbmtzIGZvciB0aGlzIGFuc3dlciBvbiBldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbTogaHR0cHM6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9hLzEyNjMwOFxuICAgICAgICBsZXQgdHhuRGF0YTogYW55O1xuICAgICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IGhvdyB0byBoYW5kbGUgQWNjZXNzTGlzdCAodHlwZSAxKSB0cmFuc2FjdGlvbnMuXG4gICAgICAgIHN3aXRjaCAocGFyc2VJbnQodHhuLnR5cGUsIDE2KSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHR4bkRhdGEgPSB7XG4gICAgICAgICAgICAgIGdhc1ByaWNlOiB0eG4uZ2FzUHJpY2UsXG4gICAgICAgICAgICAgIGdhc0xpbWl0OiB0eG4uZ2FzLFxuICAgICAgICAgICAgICB2YWx1ZTogdHhuLnZhbHVlLFxuICAgICAgICAgICAgICBub25jZTogcGFyc2VJbnQodHhuLm5vbmNlLCAxNiksXG4gICAgICAgICAgICAgIGRhdGE6IHR4bi5pbnB1dCxcbiAgICAgICAgICAgICAgY2hhaW5JZDogcGFyc2VJbnQoXG4gICAgICAgICAgICAgICAgdHhuLmNoYWluSWQgPyB0eG4uY2hhaW5JZCA6IGV0aE5ldCA9PT0gJ2dvZXJsaScgPyAnMHg1JyA6ICcweDEnLFxuICAgICAgICAgICAgICAgIDE2XG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIHRvOiB0eG4udG8sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdHhuRGF0YSA9IHtcbiAgICAgICAgICAgICAgZ2FzTGltaXQ6IHR4bi5nYXMsXG4gICAgICAgICAgICAgIHZhbHVlOiB0eG4udmFsdWUsXG4gICAgICAgICAgICAgIG5vbmNlOiBwYXJzZUludCh0eG4ubm9uY2UsIDE2KSxcbiAgICAgICAgICAgICAgZGF0YTogdHhuLmlucHV0LFxuICAgICAgICAgICAgICBjaGFpbklkOiBwYXJzZUludChcbiAgICAgICAgICAgICAgICB0eG4uY2hhaW5JZCA/IHR4bi5jaGFpbklkIDogZXRoTmV0ID09PSAnZ29lcmxpJyA/ICcweDUnIDogJzB4MScsXG4gICAgICAgICAgICAgICAgMTZcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgdG86IHR4bi50byxcbiAgICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0eG4ubWF4RmVlUGVyR2FzLFxuICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogdHhuLm1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHR4biB0eXBlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByc3R4biA9IGF3YWl0IGV0aGVycy51dGlscy5yZXNvbHZlUHJvcGVydGllcyh0eG5EYXRhKTtcbiAgICAgICAgY29uc3QgcmF3ID0gZXRoZXJzLnV0aWxzLnNlcmlhbGl6ZVRyYW5zYWN0aW9uKHJzdHhuIGFzIGFueSk7IC8vIHJldHVybnMgUkxQIGVuY29kZWQgdHJhbnNhY3Rpb25IYXNoXG4gICAgICAgIGNvbnN0IG1zZ0hhc2ggPSBldGhlcnMudXRpbHMua2VjY2FrMjU2KHJhdyk7IC8vIGFzIHNwZWNpZmllZCBieSBFQ0RTQVxuICAgICAgICBjb25zdCBtc2dCeXRlcyA9IGV0aGVycy51dGlscy5hcnJheWlmeShtc2dIYXNoKTsgLy8gY3JlYXRlIGJpbmFyeSBoYXNoXG4gICAgICAgIGNvbnN0IHJlY292ZXJlZFB1YktleSA9IGV0aGVycy51dGlscy5yZWNvdmVyUHVibGljS2V5KFxuICAgICAgICAgIG1zZ0J5dGVzLFxuICAgICAgICAgIHNpZ25hdHVyZVxuICAgICAgICApO1xuICAgICAgICBjb25zdCByZWNvdmVyZWRBZGRyZXNzID0gZXRoZXJzLnV0aWxzLmNvbXB1dGVBZGRyZXNzKHJlY292ZXJlZFB1YktleSk7XG4gICAgICAgIGlmIChyZWNvdmVyZWRBZGRyZXNzLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGByZWNvdmVyZWQgYWRkcmVzcyAke3JlY292ZXJlZEFkZHJlc3N9IGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIGFkZHJlc3MgJHthZGRyZXNzfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGV0aGVyZXVtUHVibGljS2V5ID0gcmVjb3ZlcmVkUHViS2V5LnNsaWNlKDIpO1xuICAgICAgICAvLyBicmVhayBvdXQgb2YgdGhlIGxvb3AgZm9yIHRoZSBmaXJzdCBzdWNjZXNzZnVsIHJlY292ZXJ5XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBsb2cgdGhlIGVycm9yIGJ1dCBrZWVwIGxvb2tpbmdcbiAgICAgICAgY29uc29sZS5lcnJvcihgZXJyb3IgcmVjb3ZlcmluZyBwdWJsaWMga2V5IGZyb20gdHhuOiAke2hhc2h9YCwgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFldGhlcmV1bVB1YmxpY0tleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgZmFpbGVkIHRvIHJlY292ZXIgcHVibGljIGtleSBmb3IgZXRoIGFkZHJlc3M6ICR7YWRkcmVzc31gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXByZXNzZWRFdGhLZXkgPSBQb2ludC5mcm9tSGV4KGV0aGVyZXVtUHVibGljS2V5KS50b1Jhd0J5dGVzKHRydWUpO1xuICAgIHJldHVybiBwdWJsaWNLZXlUb0Jhc2U1OENoZWNrKGNvbXByZXNzZWRFdGhLZXksIHsgbmV0d29yazogdGhpcy4jbmV0d29yayB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdG8gaGFuZGxlIHRoZSByZWRpcmVjdCBVUkkgZnJvbSB0aGUgaWRlbnRpdHkgc2VydmljZS4gVHlwaWNhbGx5IHRoaXNcbiAgICogd291bGQgYmUgdXNlZnVsIGluIGEgbW9iaWxlIGNvbnRleHQgd2hlcmUgdGhlIHVzZXIgaXMgcmVkaXJlY3RlZCBiYWNrIHRvXG4gICAqIHRoZSBhcHAgYWZ0ZXIgY29tcGxldGluZyB0aGUgaWRlbnRpdHkgZmxvdy5cbiAgICovXG4gIGhhbmRsZVJlZGlyZWN0VVJJKHJlZGlyZWN0VVJJOiBzdHJpbmcpIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgVVJMIGNvbnRhaW5zIGlkZW50aXR5IHF1ZXJ5IHBhcmFtcyBhdCBzdGFydHVwXG4gICAgY29uc3QgcXVlcnkgPSByZWRpcmVjdFVSSS5zcGxpdCgnPycpWzFdO1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhxdWVyeSk7XG5cbiAgICBpZiAocXVlcnlQYXJhbXMuZ2V0KCdzZXJ2aWNlJykgPT09IElERU5USVRZX1NFUlZJQ0VfVkFMVUUpIHtcbiAgICAgIGNvbnN0IGluaXRpYWxSZXNwb25zZSA9IHBhcnNlUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpO1xuICAgICAgLy8gU3RyaXAgdGhlIGlkZW50aXR5IHF1ZXJ5IHBhcmFtcyBmcm9tIHRoZSBVUkwuIHJlcGxhY2VTdGF0ZSByZW1vdmVzIGl0IGZyb20gYnJvd3NlciBoaXN0b3J5XG4gICAgICB0aGlzLiN3aW5kb3cuaGlzdG9yeT8ucmVwbGFjZVN0YXRlKFxuICAgICAgICB7fSxcbiAgICAgICAgJycsXG4gICAgICAgIHRoaXMuI3dpbmRvdy5sb2NhdGlvbi5wYXRobmFtZVxuICAgICAgKTtcbiAgICAgIHRoaXMuI2hhbmRsZUlkZW50aXR5UmVzcG9uc2UoaW5pdGlhbFJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghdGhpcy4jZGlkQ29uZmlndXJlKSB7XG4gICAgICAgIHRoaXMucmVmcmVzaERlcml2ZWRLZXlQZXJtaXNzaW9ucygpO1xuICAgICAgfVxuICAgIH0sIDUwKTtcbiAgfVxuXG4gIGFzeW5jICNxdWVyeUVUSFJQQyhwYXJhbXM6IFF1ZXJ5RVRIUlBDUmVxdWVzdCk6IFByb21pc2U8SW5mdXJhUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jYXBpLnBvc3QoXG4gICAgICBgJHt0aGlzLiNub2RlVVJJfS9hcGkvdjAvcXVlcnktZXRoLXJwY2AsXG4gICAgICBwYXJhbXNcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgI2dldEVUSFRyYW5zYWN0aW9uc1NpZ25lZEJ5QWRkcmVzcyhcbiAgICBhZGRyZXNzOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxFdGhlcnNjYW5UcmFuc2FjdGlvbltdPiB7XG4gICAgaWYgKCEvXjB4W2EtZkEtRjAtOV17NDB9JC8udGVzdChhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEV0aGVyZXVtIGFkZHJlc3MnKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwID0gKGF3YWl0IHRoaXMuI2FwaS5nZXQoXG4gICAgICBgJHtcbiAgICAgICAgdGhpcy4jbm9kZVVSSVxuICAgICAgfS9hcGkvdjAvZ2V0LWV0aC10cmFuc2FjdGlvbnMtZm9yLWV0aC1hZGRyZXNzLyR7YWRkcmVzc30/ZXRoX25ldHdvcms9JHtcbiAgICAgICAgREVTT19ORVRXT1JLX1RPX0VUSF9ORVRXT1JLW3RoaXMuI25ldHdvcmtdXG4gICAgICB9YFxuICAgICkpIGFzIEV0aGVyc2NhblRyYW5zYWN0aW9uc0J5QWRkcmVzc1Jlc3BvbnNlO1xuXG4gICAgaWYgKHJlc3Auc3RhdHVzICE9PSAnMScgfHwgIXJlc3AubWVzc2FnZS5zdGFydHNXaXRoKCdPSycpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFcnJvciBmZXRjaGluZyBFVEggdHJhbnNhY3Rpb25zIGZvciBhZGRyZXNzICR7YWRkcmVzc306ICR7cmVzcC5tZXNzYWdlfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3AucmVzdWx0LmZpbHRlcihcbiAgICAgICh0eCkgPT4gdHguZnJvbS50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyAjYXV0aG9yaXplRGVyaXZlZEtleShwYXJhbXM6IEF1dGhvcml6ZURlcml2ZWRLZXlSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI2FwaS5wb3N0KFxuICAgICAgYCR7dGhpcy4jbm9kZVVSSX0vYXBpL3YwL2F1dGhvcml6ZS1kZXJpdmVkLWtleWAsXG4gICAgICBwYXJhbXNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAjc2V0QWN0aXZlVXNlcihwdWJsaWNLZXk6IHN0cmluZyk6IFQgZXh0ZW5kcyBTdG9yYWdlID8gdm9pZCA6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHVzZXJzID0gdGhpcy4jZ2V0VXNlcnMoKTtcbiAgICBjb25zdCB1cGRhdGVBY3RpdmVLZXkgPSAoXG4gICAgICB1c2VyczogUmVjb3JkPHN0cmluZywgU3RvcmVkVXNlcj4gfCBudWxsLFxuICAgICAgbmV3QWN0aXZlUHVibGljS2V5OiBzdHJpbmcgfCBudWxsXG4gICAgKTogVCBleHRlbmRzIFN0b3JhZ2UgPyB2b2lkIDogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICBpZiAoIShuZXdBY3RpdmVQdWJsaWNLZXkgJiYgdXNlcnM/LltuZXdBY3RpdmVQdWJsaWNLZXldKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYE5vIHVzZXIgZm91bmQgZm9yIHB1YmxpYyBrZXkuIFN0b3JlZCB1c2VyczogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIHVzZXJzID8/IHt9XG4gICAgICAgICAgKX1gXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy4jc3RvcmFnZVByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnTm8gc3RvcmFnZSBwcm92aWRlciBhdmFpbGFibGUuIERpZCB5b3UgZm9yZ2V0IHRvIGNvbmZpZ3VyZSBhIHN0b3JhZ2VQcm92aWRlcj8nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLiNzdG9yYWdlUHJvdmlkZXIuc2V0SXRlbShcbiAgICAgICAgTE9DQUxfU1RPUkFHRV9LRVlTLmFjdGl2ZVB1YmxpY0tleSxcbiAgICAgICAgbmV3QWN0aXZlUHVibGljS2V5XG4gICAgICApIGFzIGFueTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiB1c2Vycz8udGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHVzZXJzLnRoZW4oKHVzZXJzKSA9PiB1cGRhdGVBY3RpdmVLZXkodXNlcnMsIHB1YmxpY0tleSkpIGFzIGFueTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGl2ZUtleShcbiAgICAgICAgdXNlcnMgYXMgUmVjb3JkPHN0cmluZywgU3RvcmVkVXNlcj4gfCBudWxsLFxuICAgICAgICBwdWJsaWNLZXlcbiAgICAgICkgYXMgYW55O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgI2dldEVycm9yVHlwZShlOiBFcnJvcik6IEVSUk9SX1RZUEVTIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoXG4gICAgICBlPy5tZXNzYWdlPy5pbmRleE9mKFxuICAgICAgICAnVG90YWwgaW5wdXQgMCBpcyBub3Qgc3VmZmljaWVudCB0byBjb3ZlciB0aGUgc3BlbmQgYW1vdW50J1xuICAgICAgKSA+PSAwXG4gICAgKSB7XG4gICAgICByZXR1cm4gRVJST1JfVFlQRVMuTk9fTU9ORVk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgI2F1dGhvcml6ZVByaW1hcnlEZXJpdmVkS2V5KG93bmVyUHVibGljS2V5OiBzdHJpbmcpIHtcbiAgICBjb25zdCBzdGF0ZTEgPSBhd2FpdCB0aGlzLiNnZXRTdGF0ZSgpO1xuICAgIHRoaXMuI3N1YnNjcmliZXJzLmZvckVhY2goKHMpID0+XG4gICAgICBzKHtcbiAgICAgICAgZXZlbnQ6IE5PVElGSUNBVElPTl9FVkVOVFMuQVVUSE9SSVpFX0RFUklWRURfS0VZX1NUQVJULFxuICAgICAgICAuLi5zdGF0ZTEsXG4gICAgICB9KVxuICAgICk7XG4gICAgY29uc3QgdXNlcnMgPSBhd2FpdCB0aGlzLiNnZXRVc2VycygpO1xuICAgIGNvbnN0IHByaW1hcnlEZXJpdmVkS2V5ID0gdXNlcnM/Lltvd25lclB1YmxpY0tleV0/LnByaW1hcnlEZXJpdmVkS2V5O1xuXG4gICAgaWYgKHByaW1hcnlEZXJpdmVkS2V5ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE5vIHByaW1hcnkgZGVyaXZlZCBrZXkgZm91bmQgZm9yIHVzZXIgJHtvd25lclB1YmxpY0tleX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHRyaW1tZWRBcHBOYW1lID0gdGhpcy4jYXBwTmFtZS50cmltKCk7XG4gICAgY29uc3QgTWVtbyA9XG4gICAgICB0cmltbWVkQXBwTmFtZS5sZW5ndGggPiAwXG4gICAgICAgID8gdHJpbW1lZEFwcE5hbWVcbiAgICAgICAgOiB0aGlzLiN3aW5kb3cubG9jYXRpb24/Lmhvc3RuYW1lID8/ICd1bmtub3duJztcblxuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLiNhdXRob3JpemVEZXJpdmVkS2V5KHtcbiAgICAgIE93bmVyUHVibGljS2V5QmFzZTU4Q2hlY2s6IHByaW1hcnlEZXJpdmVkS2V5LnB1YmxpY0tleUJhc2U1OENoZWNrLFxuICAgICAgRGVyaXZlZFB1YmxpY0tleUJhc2U1OENoZWNrOlxuICAgICAgICBwcmltYXJ5RGVyaXZlZEtleS5kZXJpdmVkUHVibGljS2V5QmFzZTU4Q2hlY2ssXG4gICAgICBFeHBpcmF0aW9uQmxvY2s6IHByaW1hcnlEZXJpdmVkS2V5LmV4cGlyYXRpb25CbG9jayxcbiAgICAgIEFjY2Vzc1NpZ25hdHVyZTogcHJpbWFyeURlcml2ZWRLZXkuYWNjZXNzU2lnbmF0dXJlLFxuICAgICAgRGVsZXRlS2V5OiBmYWxzZSxcbiAgICAgIERlcml2ZWRLZXlTaWduYXR1cmU6IGZhbHNlLFxuICAgICAgTWluRmVlUmF0ZU5hbm9zUGVyS0I6IDEwMDAsXG4gICAgICBUcmFuc2FjdGlvblNwZW5kaW5nTGltaXRIZXg6XG4gICAgICAgIHByaW1hcnlEZXJpdmVkS2V5LnRyYW5zYWN0aW9uU3BlbmRpbmdMaW1pdEhleCxcbiAgICAgIE1lbW8sXG4gICAgICBBcHBOYW1lOiB0aGlzLiNhcHBOYW1lLFxuICAgICAgVHJhbnNhY3Rpb25GZWVzOiBbXSxcbiAgICAgIEV4dHJhRGF0YToge30sXG4gICAgfSk7XG5cbiAgICBjb25zdCBzaWduZWRUeCA9IGF3YWl0IHRoaXMuc2lnblR4KHJlc3AuVHJhbnNhY3Rpb25IZXgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc3VibWl0VHgoc2lnbmVkVHgpO1xuICAgIGNvbnN0IHN0YXRlMiA9IGF3YWl0IHRoaXMuI2dldFN0YXRlKCk7XG5cbiAgICB0aGlzLiNzdWJzY3JpYmVycy5mb3JFYWNoKChzKSA9PlxuICAgICAgcyh7XG4gICAgICAgIGV2ZW50OiBOT1RJRklDQVRJT05fRVZFTlRTLkFVVEhPUklaRV9ERVJJVkVEX0tFWV9FTkQsXG4gICAgICAgIC4uLnN0YXRlMixcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gICNoYW5kbGVQb3N0TWVzc2FnZShldjogTWVzc2FnZUV2ZW50KSB7XG4gICAgaWYgKFxuICAgICAgZXYub3JpZ2luICE9PSB0aGlzLiNpZGVudGl0eVVSSSB8fFxuICAgICAgZXYuZGF0YS5zZXJ2aWNlICE9PSBJREVOVElUWV9TRVJWSUNFX1ZBTFVFIHx8XG4gICAgICBldi5zb3VyY2UgPT09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXYuZGF0YS5tZXRob2QgPT09ICdpbml0aWFsaXplJykge1xuICAgICAgZXYuc291cmNlLnBvc3RNZXNzYWdlKFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IGV2LmRhdGEuaWQsXG4gICAgICAgICAgc2VydmljZTogSURFTlRJVFlfU0VSVklDRV9WQUxVRSxcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBhcHBOYW1lOiB0aGlzLiNhcHBOYW1lLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMuI2lkZW50aXR5VVJJIGFzIFdpbmRvd1Bvc3RNZXNzYWdlT3B0aW9uc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaGFuZGxlSWRlbnRpdHlSZXNwb25zZShldi5kYXRhKTtcbiAgICAgIHRoaXMuI2lkZW50aXR5UG9wdXBXaW5kb3c/LmNsb3NlKCk7XG4gICAgICBpZiAodGhpcy4jYm91bmRQb3N0TWVzc2FnZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy4jd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgJ21lc3NhZ2UnLFxuICAgICAgICAgIHRoaXMuI2JvdW5kUG9zdE1lc3NhZ2VMaXN0ZW5lclxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy4jYm91bmRQb3N0TWVzc2FnZUxpc3RlbmVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgI2hhbmRsZUlkZW50aXR5UmVzcG9uc2UoeyBtZXRob2QsIHBheWxvYWQgPSB7fSB9OiBJZGVudGl0eVJlc3BvbnNlKSB7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ2Rlcml2ZSc6XG4gICAgICAgIHRoaXMuI2hhbmRsZURlcml2ZU1ldGhvZChwYXlsb2FkIGFzIElkZW50aXR5RGVyaXZlUGF5bG9hZClcbiAgICAgICAgICAudGhlbihhc3luYyAocmVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGF3YWl0IHRoaXMuI2dldFN0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLiNzdWJzY3JpYmVycy5mb3JFYWNoKChzKSA9PlxuICAgICAgICAgICAgICBzKHtcbiAgICAgICAgICAgICAgICBldmVudDpcbiAgICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdXaW5kb3dSZXF1ZXN0Py5ldmVudCA9PT1cbiAgICAgICAgICAgICAgICAgIE5PVElGSUNBVElPTl9FVkVOVFMuTE9HSU5fU1RBUlRcbiAgICAgICAgICAgICAgICAgICAgPyBOT1RJRklDQVRJT05fRVZFTlRTLkxPR0lOX0VORFxuICAgICAgICAgICAgICAgICAgICA6IE5PVElGSUNBVElPTl9FVkVOVFMuUkVRVUVTVF9QRVJNSVNTSU9OU19FTkQsXG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy4jcGVuZGluZ1dpbmRvd1JlcXVlc3Q/LnJlc29sdmUocmVzKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgd2UncmUgaW4gYSBsb2dpbiBmbG93IGp1c3QgZG9uJ3QgbGV0IHRoZSB1c2VyIGxvZyBpbiBpZiB3ZVxuICAgICAgICAgICAgLy8gY2FuJ3QgYXV0aG9yaXplIHRoZWlyIGRlcml2ZWQga2V5LiAgd2UndmUgYWxyZWFkeSBzdG9yZWQgdGhlIHVzZXJcbiAgICAgICAgICAgIC8vIGluIGxvY2FsIHN0b3JhZ2UgYmVmb3JlIGF0dGVtcHRpbmcgdG8gYXV0aG9yaXplLCBzbyB3ZSByZW1vdmVcbiAgICAgICAgICAgIC8vIHRoZWlyIGRhdGEuXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VXNlciA9IGF3YWl0IHRoaXMuI2dldEN1cnJlbnRVc2VyKCk7XG4gICAgICAgICAgICBjb25zdCBzaG93U2tpcEFuZE5vTW9uZXkgPVxuICAgICAgICAgICAgICAodGhpcy4jc2hvd1NraXAgfHwgdGhpcy4jaXNBdXRvRGVyaXZlTG9naW4pICYmXG4gICAgICAgICAgICAgIGUubWVzc2FnZS5pbmRleE9mKCdSdWxlRXJyb3JJbnN1ZmZpY2llbnRCYWxhbmNlJykgPj0gMDtcbiAgICAgICAgICAgIGlmIChzaG93U2tpcEFuZE5vTW9uZXkgJiYgY3VycmVudFVzZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLiN1cGRhdGVVc2VyKGN1cnJlbnRVc2VyLnB1YmxpY0tleSwge1xuICAgICAgICAgICAgICAgIHByaW1hcnlEZXJpdmVkS2V5OiB7XG4gICAgICAgICAgICAgICAgICAuLi5jdXJyZW50VXNlci5wcmltYXJ5RGVyaXZlZEtleSxcbiAgICAgICAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICAgICAgICBkZXJpdmVkS2V5UmVnaXN0ZXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuI3N0b3JhZ2VQcm92aWRlci5zZXRJdGVtKFxuICAgICAgICAgICAgICAgIExPQ0FMX1NUT1JBR0VfS0VZUy5hY3RpdmVQdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgY3VycmVudFVzZXIucHVibGljS2V5XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nV2luZG93UmVxdWVzdD8uZXZlbnQgPT09XG4gICAgICAgICAgICAgICAgTk9USUZJQ0FUSU9OX0VWRU5UUy5MT0dJTl9TVEFSVCAmJlxuICAgICAgICAgICAgICBjdXJyZW50VXNlciAhPSBudWxsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdGhpcy4jcHVyZ2VVc2VyRGF0YUZvclB1YmxpY0tleShjdXJyZW50VXNlci5wdWJsaWNLZXkpO1xuXG4gICAgICAgICAgICAgIGlmICghdGhpcy4jc3RvcmFnZVByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdG9yYWdlIHByb3ZpZGVyIGF2YWlsYWJsZS4nKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuI3N0b3JhZ2VQcm92aWRlci5yZW1vdmVJdGVtKFxuICAgICAgICAgICAgICAgIExPQ0FMX1NUT1JBR0VfS0VZUy5hY3RpdmVQdWJsaWNLZXlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgdGhpcy4jZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuI3N1YnNjcmliZXJzLmZvckVhY2goKHMpID0+XG4gICAgICAgICAgICAgIHMoe1xuICAgICAgICAgICAgICAgIGV2ZW50OiBOT1RJRklDQVRJT05fRVZFTlRTLkFVVEhPUklaRV9ERVJJVkVEX0tFWV9GQUlMLFxuICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSB0aGUgZXJyb3IgdG8gdGhlIGV4dGVybmFsIGNhbGxlclxuICAgICAgICAgICAgdGhpcy4jcGVuZGluZ1dpbmRvd1JlcXVlc3Q/LnJlamVjdCh0aGlzLiNnZXRFcnJvckluc3RhbmNlKGUpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsb2dpbic6XG4gICAgICAgIHRoaXMuI2hhbmRsZUxvZ2luTWV0aG9kKHBheWxvYWQgYXMgSWRlbnRpdHlMb2dpblBheWxvYWQpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgLy8gcHJvcGFnYXRlIGFueSBlcnJvciB0byB0aGUgZXh0ZXJuYWwgY2FsbGVyXG4gICAgICAgICAgdGhpcy4jcGVuZGluZ1dpbmRvd1JlcXVlc3Q/LnJlamVjdCh0aGlzLiNnZXRFcnJvckluc3RhbmNlKGUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG1ldGhvZDogJHttZXRob2R9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyAjaGFuZGxlTG9naW5NZXRob2QocGF5bG9hZDogSWRlbnRpdHlMb2dpblBheWxvYWQpIHtcbiAgICBjb25zdCBhY3RpdmVQdWJsaWNLZXkgPSBhd2FpdCB0aGlzLiNnZXRBY3RpdmVQdWJsaWNLZXkoKTtcblxuICAgIC8vIE5PVEU6IHRoaXMgaXMgYSBiaXQgY291bnRlcmludHVpdGl2ZSwgYnV0IGEgbWlzc2luZyBwdWJsaWNLZXlBZGRlZFxuICAgIC8vIGlkZW50aWZpZXMgdGhpcyBhcyBhIGxvZ291dCAoZXZlbiB0aG91Z2ggdGhlIG1ldGhvZCBpcyAnbG9naW4nKS5cbiAgICBpZiAoIXBheWxvYWQucHVibGljS2V5QWRkZWQpIHtcbiAgICAgIGlmICghYWN0aXZlUHVibGljS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWN0aXZlIHB1YmxpYyBrZXkgZm91bmQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLiNzdG9yYWdlUHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdG9yYWdlIHByb3ZpZGVyIGF2YWlsYWJsZS4nKTtcbiAgICAgIH1cblxuICAgICAgYXdhaXQgdGhpcy4jc3RvcmFnZVByb3ZpZGVyLnJlbW92ZUl0ZW0oXG4gICAgICAgIExPQ0FMX1NUT1JBR0VfS0VZUy5hY3RpdmVQdWJsaWNLZXlcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHRoaXMuI3B1cmdlVXNlckRhdGFGb3JQdWJsaWNLZXkoYWN0aXZlUHVibGljS2V5KTtcblxuICAgICAgY29uc3Qgc3RhdGUgPSBhd2FpdCB0aGlzLiNnZXRTdGF0ZSgpO1xuICAgICAgdGhpcy4jc3Vic2NyaWJlcnMuZm9yRWFjaCgocykgPT5cbiAgICAgICAgcyh7XG4gICAgICAgICAgZXZlbnQ6IE5PVElGSUNBVElPTl9FVkVOVFMuTE9HT1VUX0VORCxcbiAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICB0aGlzLiNwZW5kaW5nV2luZG93UmVxdWVzdD8ucmVzb2x2ZShwYXlsb2FkKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgcGF5bG9hZC5wdWJsaWNLZXlBZGRlZCAmJlxuICAgICAgIXBheWxvYWQuc2lnbmVkVXAgJiZcbiAgICAgIHBheWxvYWQucHVibGljS2V5QWRkZWQgPT09IGFjdGl2ZVB1YmxpY0tleVxuICAgICkge1xuICAgICAgbGV0IGVuZEV2ZW50OiBOT1RJRklDQVRJT05fRVZFTlRTO1xuICAgICAgY29uc3Qgc3RhcnRFdmVudCA9IHRoaXMuI3BlbmRpbmdXaW5kb3dSZXF1ZXN0Py5ldmVudDtcbiAgICAgIGlmIChzdGFydEV2ZW50ID09PSBOT1RJRklDQVRJT05fRVZFTlRTLkdFVF9GUkVFX0RFU09fU1RBUlQpIHtcbiAgICAgICAgZW5kRXZlbnQgPSBOT1RJRklDQVRJT05fRVZFTlRTLkdFVF9GUkVFX0RFU09fRU5EO1xuICAgICAgfSBlbHNlIGlmIChzdGFydEV2ZW50ID09PSBOT1RJRklDQVRJT05fRVZFTlRTLlZFUklGWV9QSE9ORV9OVU1CRVJfU1RBUlQpIHtcbiAgICAgICAgZW5kRXZlbnQgPSBOT1RJRklDQVRJT05fRVZFTlRTLlZFUklGWV9QSE9ORV9OVU1CRVJfRU5EO1xuICAgICAgfSBlbHNlIGlmIChzdGFydEV2ZW50ID09PSBOT1RJRklDQVRJT05fRVZFTlRTLkxPR0lOX1NUQVJUKSB7XG4gICAgICAgIGVuZEV2ZW50ID0gTk9USUZJQ0FUSU9OX0VWRU5UUy5MT0dJTl9FTkQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgaWRlbnRpdHkgZXZlbnQ6ICR7c3RhcnRFdmVudH1gKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4jYXV0aG9yaXplUHJpbWFyeURlcml2ZWRLZXkocGF5bG9hZC5wdWJsaWNLZXlBZGRlZClcbiAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuI3BlbmRpbmdXaW5kb3dSZXF1ZXN0Py5yZXNvbHZlKHBheWxvYWQpO1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgdGhpcy4jZ2V0U3RhdGUoKTtcbiAgICAgICAgICB0aGlzLiNzdWJzY3JpYmVycy5mb3JFYWNoKChzKSA9PiBzKHsgZXZlbnQ6IGVuZEV2ZW50LCAuLi5zdGF0ZSB9KSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChhc3luYyAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgdGhpcy4jZ2V0U3RhdGUoKTtcbiAgICAgICAgICB0aGlzLiNzdWJzY3JpYmVycy5mb3JFYWNoKChzKSA9PlxuICAgICAgICAgICAgcyh7XG4gICAgICAgICAgICAgIGV2ZW50OiBOT1RJRklDQVRJT05fRVZFTlRTLkFVVEhPUklaRV9ERVJJVkVEX0tFWV9GQUlMLFxuICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLiNwZW5kaW5nV2luZG93UmVxdWVzdD8ucmVqZWN0KHRoaXMuI2dldEVycm9ySW5zdGFuY2UoZSkpO1xuICAgICAgICB9KTtcbiAgICAgIC8vIFRoaXMgY29uZGl0aW9uIGlkZW50aWZpZXMgdGhlIGxlZ2FjeSBub24gZGVyaXZlZCBrZXkgbG9naW4gZmxvdy5cbiAgICAgIC8vIFdlIGRlZmF1bHQgdG8gZGVyaXZlZCBrZXkgbG9naW4sIGJ1dCB0aGUgbGVnYWN5IGZsb3cgY2FuIGJlIGVuYWJsZWRcbiAgICAgIC8vIHRvIHN1cHBvcnQgc2ltcGxlIGdhdGVkIGNvbnRlbnQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9kZXNvLXByb3RvY29sL2Rlc28tanMvaXNzdWVzLzFcbiAgICB9IGVsc2UgaWYgKHBheWxvYWQucHVibGljS2V5QWRkZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMuI3VwZGF0ZVVzZXIoXG4gICAgICAgIHBheWxvYWQucHVibGljS2V5QWRkZWQsXG4gICAgICAgIHBheWxvYWQudXNlcnNbcGF5bG9hZC5wdWJsaWNLZXlBZGRlZF1cbiAgICAgICk7XG4gICAgICB0aGlzLiNwZW5kaW5nV2luZG93UmVxdWVzdD8ucmVzb2x2ZShwYXlsb2FkKTtcbiAgICAgIGF3YWl0IHRoaXMuI3N0b3JhZ2VQcm92aWRlci5zZXRJdGVtKFxuICAgICAgICBMT0NBTF9TVE9SQUdFX0tFWVMuYWN0aXZlUHVibGljS2V5LFxuICAgICAgICBwYXlsb2FkLnB1YmxpY0tleUFkZGVkXG4gICAgICApO1xuICAgICAgY29uc3Qgc3RhdGUgPSBhd2FpdCB0aGlzLiNnZXRTdGF0ZSgpO1xuICAgICAgdGhpcy4jc3Vic2NyaWJlcnMuZm9yRWFjaCgocykgPT5cbiAgICAgICAgcyh7IGV2ZW50OiBOT1RJRklDQVRJT05fRVZFTlRTLkxPR0lOX0VORCwgLi4uc3RhdGUgfSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vdCBzdXJlIGhvdyB3ZSB3b3VsZCBnZXQgaGVyZSwgYnV0IGxldHMgbG9nIGl0IGp1c3QgaW4gY2FzZSB3ZSBoYXZlbid0IGFjdHVhbGx5XG4gICAgICAvLyBoYW5kbGVkIGFsbCB0aGUgY2FzZXMuXG4gICAgICBjb25zb2xlLndhcm4oJ3VuaGFuZGxlZCBpZGVudGl0eSBsb2dpbiBwYXlsb2FkJywgcGF5bG9hZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyAjcHVyZ2VVc2VyRGF0YUZvclB1YmxpY0tleShwdWJsaWNLZXk6IHN0cmluZykge1xuICAgIGlmICghdGhpcy4jc3RvcmFnZVByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN0b3JhZ2UgcHJvdmlkZXIgaXMgYXZhaWxhYmxlLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgdGhpcy4jc3RvcmFnZVByb3ZpZGVyLmdldEl0ZW0oXG4gICAgICBMT0NBTF9TVE9SQUdFX0tFWVMuaWRlbnRpdHlVc2Vyc1xuICAgICk7XG4gICAgaWYgKHVzZXJzKSB7XG4gICAgICBjb25zdCB1c2Vyc09iaiA9IEpTT04ucGFyc2UodXNlcnMpO1xuICAgICAgZGVsZXRlIHVzZXJzT2JqW3B1YmxpY0tleV07XG4gICAgICBpZiAoT2JqZWN0LmtleXModXNlcnNPYmopLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhd2FpdCB0aGlzLiNzdG9yYWdlUHJvdmlkZXIucmVtb3ZlSXRlbShcbiAgICAgICAgICBMT0NBTF9TVE9SQUdFX0tFWVMuaWRlbnRpdHlVc2Vyc1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy4jc3RvcmFnZVByb3ZpZGVyLnNldEl0ZW0oXG4gICAgICAgICAgTE9DQUxfU1RPUkFHRV9LRVlTLmlkZW50aXR5VXNlcnMsXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkodXNlcnNPYmopXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyAjaGFuZGxlRGVyaXZlTWV0aG9kKFxuICAgIHBheWxvYWQ6IElkZW50aXR5RGVyaXZlUGF5bG9hZFxuICApOiBQcm9taXNlPElkZW50aXR5RGVyaXZlUGF5bG9hZD4ge1xuICAgIGNvbnN0IHsgcHJpbWFyeURlcml2ZWRLZXkgfSA9IChhd2FpdCB0aGlzLiNnZXRDdXJyZW50VXNlcigpKSA/PyB7fTtcblxuICAgIC8vIE5PVEU6IElmIHdlIGdlbmVyYXRlZCB0aGUga2V5cyBhbmQgcHJvdmlkZWQgdGhlIGRlcml2ZWQgcHVibGljIGtleSxcbiAgICAvLyBpZGVudGl0eSB3aWxsIHJlc3BvbmQgd2l0aCBhbiBlbXB0eSBzdHJpbmcgaW4gdGhlIGRlcml2ZWRTZWVkSGV4IGZpZWxkLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gaW5hZHZlcnRlbnRseSBvdmVyd3JpdGUgb3VyIGRlcml2ZWQgc2VlZCBoZXggd2l0aCB0aGVcbiAgICAvLyBlbXB0eSBzdHJpbmcsIHNvIHdlIGRlbGV0ZSB0aGUgZmllbGQgaWYgaXQncyBlbXB0eS5cbiAgICBpZiAocGF5bG9hZC5kZXJpdmVkU2VlZEhleCA9PT0gJycpIHtcbiAgICAgIGRlbGV0ZSBwYXlsb2FkLmRlcml2ZWRTZWVkSGV4O1xuICAgIH1cblxuICAgIGlmICghdGhpcy4jc3RvcmFnZVByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN0b3JhZ2UgcHJvdmlkZXIgaXMgYXZhaWxhYmxlLicpO1xuICAgIH1cblxuICAgIC8vIHdlIG1heSBvciBtYXkgbm90IGhhdmUgYSBsb2dpbiBrZXkgcGFpciBpbiBsb2NhbFN0b3JhZ2UuIElmIHdlIGRvLCBpdCBtZWFucyB3ZVxuICAgIC8vIGluaXRpYXRlZCBhIGxvZ2luIGZsb3cuXG4gICAgY29uc3QgbWF5YmVMb2dpbktleVBhaXIgPSBhd2FpdCB0aGlzLiNzdG9yYWdlUHJvdmlkZXIuZ2V0SXRlbShcbiAgICAgIExPQ0FMX1NUT1JBR0VfS0VZUy5sb2dpbktleVBhaXJcbiAgICApO1xuICAgIC8vIGluIHRoZSBjYXNlIG9mIGEgbG9naW4sIHdlIGFsd2F5cyBjbGVhbiB1cCB0aGUgbG9naW4ga2V5IHBhaXIgZnJvbSBsb2NhbFN0b3JhZ2UuXG4gICAgYXdhaXQgdGhpcy4jc3RvcmFnZVByb3ZpZGVyLnJlbW92ZUl0ZW0oTE9DQUxfU1RPUkFHRV9LRVlTLmxvZ2luS2V5UGFpcik7XG5cbiAgICAvLyBUaGlzIG1lYW5zIHdlJ3JlIGRvaW5nIGEgZGVyaXZlZCBrZXkgcGVybWlzc2lvbnMgdXBncmFkZSBmb3IgdGhlIGN1cnJlbnQgdXNlciAobm90IGEgbG9naW4pLlxuICAgIGlmIChcbiAgICAgIHByaW1hcnlEZXJpdmVkS2V5ICE9IG51bGwgJiZcbiAgICAgIHByaW1hcnlEZXJpdmVkS2V5LnB1YmxpY0tleUJhc2U1OENoZWNrID09PSBwYXlsb2FkLnB1YmxpY0tleUJhc2U1OENoZWNrICYmXG4gICAgICBwcmltYXJ5RGVyaXZlZEtleS5kZXJpdmVkUHVibGljS2V5QmFzZTU4Q2hlY2sgPT09XG4gICAgICAgIHBheWxvYWQuZGVyaXZlZFB1YmxpY0tleUJhc2U1OENoZWNrXG4gICAgKSB7XG4gICAgICBhd2FpdCB0aGlzLiN1cGRhdGVVc2VyKHBheWxvYWQucHVibGljS2V5QmFzZTU4Q2hlY2ssIHtcbiAgICAgICAgcHJpbWFyeURlcml2ZWRLZXk6IHsgLi4ucHJpbWFyeURlcml2ZWRLZXksIC4uLnBheWxvYWQgfSxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYXV0aG9yaXplUHJpbWFyeURlcml2ZWRLZXkoXG4gICAgICAgIHBheWxvYWQucHVibGljS2V5QmFzZTU4Q2hlY2tcbiAgICAgICkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcHJpbWFyeURlcml2ZWRLZXkgfSA9IChhd2FpdCB0aGlzLiNnZXRDdXJyZW50VXNlcigpKSA/PyB7fTtcbiAgICAgICAgYXdhaXQgdGhpcy4jdXBkYXRlVXNlcihwYXlsb2FkLnB1YmxpY0tleUJhc2U1OENoZWNrLCB7XG4gICAgICAgICAgcHJpbWFyeURlcml2ZWRLZXk6IHtcbiAgICAgICAgICAgIC4uLnByaW1hcnlEZXJpdmVkS2V5LFxuICAgICAgICAgICAgZGVyaXZlZEtleVJlZ2lzdGVyZWQ6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgW3VzZXJzLCBhY3RpdmVQdWJsaWNLZXldID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy4jZ2V0VXNlcnMoKSxcbiAgICAgIHRoaXMuI2dldEFjdGl2ZVB1YmxpY0tleSgpLFxuICAgIF0pO1xuXG4gICAgLy8gVGhpcyBtZWFucyB3ZSdyZSBqdXN0IHN3aXRjaGluZyB0byBhIHVzZXIgd2UgYWxyZWFkeSBoYXZlIGluIGxvY2FsU3RvcmFnZSwgd2UgdXNlIHRoZSBzdG9yZWQgdXNlciBiYyB0aGV5XG4gICAgLy8gbWF5IGFscmVhZHkgaGF2ZSBhbiBhdXRob3JpemVkIGRlcml2ZWQga2V5IHRoYXQgd2UgY2FuIHVzZS5cbiAgICBpZiAoXG4gICAgICB1c2Vycz8uW3BheWxvYWQucHVibGljS2V5QmFzZTU4Q2hlY2tdICE9IG51bGwgJiZcbiAgICAgIHBheWxvYWQucHVibGljS2V5QmFzZTU4Q2hlY2sgIT09IGFjdGl2ZVB1YmxpY0tleVxuICAgICkge1xuICAgICAgYXdhaXQgdGhpcy4jc2V0QWN0aXZlVXNlcihwYXlsb2FkLnB1YmxpY0tleUJhc2U1OENoZWNrKTtcbiAgICAgIC8vIGlmIHRoZSBsb2dnZWQgaW4gdXNlciBjaGFuZ2VzLCB3ZSB0cnkgdG8gcmVmcmVzaCB0aGUgZGVyaXZlZCBrZXkgcGVybWlzc2lvbnMgaW4gdGhlIGJhY2tncm91bmRcbiAgICAgIC8vIGFuZCBqdXN0IHJldHVybiB0aGUgcGF5bG9hZCBpbW1lZGlhdGVseS5cbiAgICAgIHRoaXMucmVmcmVzaERlcml2ZWRLZXlQZXJtaXNzaW9ucygpO1xuICAgICAgcmV0dXJuIHBheWxvYWQ7XG5cbiAgICAgIC8vIFRoaXMgbWVhbnMgd2UncmUgbG9nZ2luZyBpbiBhIHVzZXIgd2UgaGF2ZW4ndCBzZWVuIHlldFxuICAgIH0gZWxzZSBpZiAobWF5YmVMb2dpbktleVBhaXIpIHtcbiAgICAgIGNvbnN0IHsgc2VlZEhleCB9ID0gSlNPTi5wYXJzZShtYXliZUxvZ2luS2V5UGFpcik7XG4gICAgICBhd2FpdCB0aGlzLiN1cGRhdGVVc2VyKHBheWxvYWQucHVibGljS2V5QmFzZTU4Q2hlY2ssIHtcbiAgICAgICAgcHJpbWFyeURlcml2ZWRLZXk6IHtcbiAgICAgICAgICAuLi5wcmltYXJ5RGVyaXZlZEtleSxcbiAgICAgICAgICAuLi5wYXlsb2FkLFxuICAgICAgICAgIGRlcml2ZWRTZWVkSGV4OiBzZWVkSGV4LFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBhd2FpdCB0aGlzLiNzdG9yYWdlUHJvdmlkZXIuc2V0SXRlbShcbiAgICAgICAgTE9DQUxfU1RPUkFHRV9LRVlTLmFjdGl2ZVB1YmxpY0tleSxcbiAgICAgICAgcGF5bG9hZC5wdWJsaWNLZXlCYXNlNThDaGVja1xuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2F1dGhvcml6ZVByaW1hcnlEZXJpdmVkS2V5KFxuICAgICAgICBwYXlsb2FkLnB1YmxpY0tleUJhc2U1OENoZWNrXG4gICAgICApLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHByaW1hcnlEZXJpdmVkS2V5IH0gPSAoYXdhaXQgdGhpcy4jZ2V0Q3VycmVudFVzZXIoKSkgPz8ge307XG4gICAgICAgIGF3YWl0IHRoaXMuI3VwZGF0ZVVzZXIocGF5bG9hZC5wdWJsaWNLZXlCYXNlNThDaGVjaywge1xuICAgICAgICAgIHByaW1hcnlEZXJpdmVkS2V5OiB7XG4gICAgICAgICAgICAuLi5wcmltYXJ5RGVyaXZlZEtleSxcbiAgICAgICAgICAgIGRlcml2ZWRTZWVkSGV4OiBzZWVkSGV4LFxuICAgICAgICAgICAgZGVyaXZlZEtleVJlZ2lzdGVyZWQ6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICBwdWJsaWNLZXlBZGRlZDogcGF5bG9hZC5wdWJsaWNLZXlCYXNlNThDaGVjayxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEZvciBhbGwgb3RoZXIgZGVyaXZlIGZsb3dzLCB3ZSBqdXN0IHJldHVybiB0aGUgcGF5bG9hZCBkaXJlY3RseS5cbiAgICByZXR1cm4gcGF5bG9hZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgI3VwZGF0ZVVzZXIoXG4gICAgbWFzdGVyUHVibGljS2V5OiBzdHJpbmcsXG4gICAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9XG4gICkge1xuICAgIGlmICghdGhpcy4jc3RvcmFnZVByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN0b3JhZ2UgcHJvdmlkZXIgaXMgYXZhaWxhYmxlLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgdGhpcy4jc3RvcmFnZVByb3ZpZGVyLmdldEl0ZW0oXG4gICAgICBMT0NBTF9TVE9SQUdFX0tFWVMuaWRlbnRpdHlVc2Vyc1xuICAgICk7XG4gICAgaWYgKHVzZXJzKSB7XG4gICAgICBjb25zdCB1c2Vyc09iaiA9IEpTT04ucGFyc2UodXNlcnMpO1xuICAgICAgaWYgKCF1c2Vyc09ialttYXN0ZXJQdWJsaWNLZXldKSB7XG4gICAgICAgIHVzZXJzT2JqW21hc3RlclB1YmxpY0tleV0gPSB7XG4gICAgICAgICAgcHVibGljS2V5OiBtYXN0ZXJQdWJsaWNLZXksXG4gICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVzZXJzT2JqW21hc3RlclB1YmxpY0tleV0gPSB7XG4gICAgICAgICAgcHVibGljS2V5OiBtYXN0ZXJQdWJsaWNLZXksXG4gICAgICAgICAgLi4udXNlcnNPYmpbbWFzdGVyUHVibGljS2V5XSxcbiAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy4jc3RvcmFnZVByb3ZpZGVyLnNldEl0ZW0oXG4gICAgICAgIExPQ0FMX1NUT1JBR0VfS0VZUy5pZGVudGl0eVVzZXJzLFxuICAgICAgICBKU09OLnN0cmluZ2lmeSh1c2Vyc09iailcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHRoaXMuI3N0b3JhZ2VQcm92aWRlci5zZXRJdGVtKFxuICAgICAgICBMT0NBTF9TVE9SQUdFX0tFWVMuaWRlbnRpdHlVc2VycyxcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIFttYXN0ZXJQdWJsaWNLZXldOiB7IHB1YmxpY0tleTogbWFzdGVyUHVibGljS2V5LCAuLi5hdHRyaWJ1dGVzIH0sXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgI2J1aWxkUXVlcnlQYXJhbXMocGFyYW1zUG9qbzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIGNvbnN0IHFwcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoXG4gICAgICBPYmplY3QuZW50cmllcyhwYXJhbXNQb2pvKS5yZWR1Y2U8UmVjb3JkPHN0cmluZywgYW55Pj4oKGFjYywgW2ssIHZdKSA9PiB7XG4gICAgICAgIGFjY1trXSA9XG4gICAgICAgICAgdHlwZW9mIHYgPT09ICdvYmplY3QnICYmIHYgIT09IG51bGxcbiAgICAgICAgICAgID8gZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHYpKVxuICAgICAgICAgICAgOiB2O1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pXG4gICAgKTtcblxuICAgIGlmICh0aGlzLiNuZXR3b3JrID09PSAndGVzdG5ldCcpIHtcbiAgICAgIHFwcy5hcHBlbmQoJ3Rlc3RuZXQnLCAndHJ1ZScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLiNyZWRpcmVjdFVSSSkge1xuICAgICAgcXBzLmFwcGVuZCgncmVkaXJlY3RfdXJpJywgdGhpcy4jcmVkaXJlY3RVUkkpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFdlIGNhbiByZW1vdmUgdGhpcyBmZWF0dXJlIGZsYWcgb25jZSB0aGlzIGJlY29tZXMgdGhlIGRlZmF1bHRcbiAgICAvLyBiZWhhdmlvciBpbiB0aGUgaWRlbnRpdHkgc2VydmljZS5cbiAgICBxcHMuYXBwZW5kKCdzdWJBY2NvdW50cycsICd0cnVlJyk7XG5cbiAgICByZXR1cm4gcXBzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAjb3BlbklkZW50aXR5UG9wdXAodXJsOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy4jaWRlbnRpdHlQb3B1cFdpbmRvdyAhPSBudWxsKSB7XG4gICAgICB0aGlzLiNpZGVudGl0eVBvcHVwV2luZG93LmNsb3NlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgaCA9IDEwMDA7XG4gICAgY29uc3QgdyA9IDgwMDtcbiAgICBjb25zdCB5ID0gdGhpcy4jd2luZG93Lm91dGVySGVpZ2h0IC8gMiArIHRoaXMuI3dpbmRvdy5zY3JlZW5ZIC0gaCAvIDI7XG4gICAgY29uc3QgeCA9IHRoaXMuI3dpbmRvdy5vdXRlcldpZHRoIC8gMiArIHRoaXMuI3dpbmRvdy5zY3JlZW5YIC0gdyAvIDI7XG5cbiAgICB0aGlzLiNpZGVudGl0eVBvcHVwV2luZG93ID0gdGhpcy4jd2luZG93Lm9wZW4oXG4gICAgICB1cmwsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBgdG9vbGJhcj1ubywgd2lkdGg9JHt3fSwgaGVpZ2h0PSR7aH0sIHRvcD0ke3l9LCBsZWZ0PSR7eH1gXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgI2xhdW5jaElkZW50aXR5KHBhdGg6IHN0cmluZywgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgY29uc3QgcXBzID0gdGhpcy4jYnVpbGRRdWVyeVBhcmFtcyhwYXJhbXMpO1xuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuI2lkZW50aXR5VVJJfS8ke3BhdGgucmVwbGFjZSgvXlxcLy8sICcnKX0/JHtxcHN9YDtcblxuICAgIC8vIElmIHdlIGhhdmUgYSBjdXN0b20gcHJlc2VudGVyLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJyb3dzZXIgQVBJcy5cbiAgICAvLyBUaGlzIHdvdWxkIHR5cGljYWxseSBiZSB1c2VkIGZvciBtb2JpbGUgYXBwcy5cbiAgICBpZiAodHlwZW9mIHRoaXMuI2lkZW50aXR5UHJlc2VudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNpZGVudGl0eVByZXNlbnRlcih1cmwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy4jd2luZG93Lm9wZW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ05vIGlkZW50aXR5IHByZXNlbnRlciBpcyBhdmFpbGFibGUuIERpZCB5b3UgZm9yZ2V0IHRvIGNvbmZpZ3VyZSBhIGN1c3RvbSBpZGVudGl0eVByZXNlbnRlcj8nXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChxcHMuZ2V0KCdyZWRpcmVjdF91cmknKSkge1xuICAgICAgdGhpcy4jd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHdlIGhhZCBhIHByZXZpb3VzbHkgYXR0YWNoZWQgbGlzdGVuZXIsIHJlbW92ZSBpdCBhbmQgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgIGlmICh0aGlzLiNib3VuZFBvc3RNZXNzYWdlTGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLiN3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAnbWVzc2FnZScsXG4gICAgICAgICAgdGhpcy4jYm91bmRQb3N0TWVzc2FnZUxpc3RlbmVyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLiNib3VuZFBvc3RNZXNzYWdlTGlzdGVuZXIgPSB0aGlzLiNoYW5kbGVQb3N0TWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy4jd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLiNib3VuZFBvc3RNZXNzYWdlTGlzdGVuZXIpO1xuICAgICAgdGhpcy4jb3BlbklkZW50aXR5UG9wdXAodXJsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gICNnZXRFcnJvckluc3RhbmNlKGU6IGFueSk6IEVycm9yIHtcbiAgICBjb25zdCBlcnJvclR5cGUgPSB0aGlzLiNnZXRFcnJvclR5cGUoZSk7XG4gICAgaWYgKCFlcnJvclR5cGUpIHJldHVybiBlO1xuXG4gICAgcmV0dXJuIG5ldyBEZVNvQ29yZUVycm9yKGUubWVzc2FnZSwgZXJyb3JUeXBlLCBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgI2RlY3J5cHRHcm91cENoYXQoXG4gICAgZ3JvdXBzOiBBY2Nlc3NHcm91cEVudHJ5UmVzcG9uc2VbXSxcbiAgICBtZXNzYWdlOiBOZXdNZXNzYWdlRW50cnlSZXNwb25zZVxuICApIHtcbiAgICAvLyBBU1NVTVBUSU9OOiBpZiBpdCdzIGEgZ3JvdXAgY2hhdCwgdGhlbiB0aGUgUkVDSVBJRU5UIGhhcyB0aGUgZ3JvdXAga2V5IG5hbWUgd2UgbmVlZD9cbiAgICBjb25zdCBhY2Nlc3NHcm91cCA9IGdyb3Vwcy5maW5kKChnKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBnLkFjY2Vzc0dyb3VwS2V5TmFtZSA9PT0gbWVzc2FnZS5SZWNpcGllbnRJbmZvLkFjY2Vzc0dyb3VwS2V5TmFtZSAmJlxuICAgICAgICBnLkFjY2Vzc0dyb3VwT3duZXJQdWJsaWNLZXlCYXNlNThDaGVjayA9PT1cbiAgICAgICAgICBtZXNzYWdlLlJlY2lwaWVudEluZm8uT3duZXJQdWJsaWNLZXlCYXNlNThDaGVjayAmJlxuICAgICAgICBnLkFjY2Vzc0dyb3VwTWVtYmVyRW50cnlSZXNwb25zZVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGlmICghYWNjZXNzR3JvdXA/LkFjY2Vzc0dyb3VwTWVtYmVyRW50cnlSZXNwb25zZT8uRW5jcnlwdGVkS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FjY2VzcyBncm91cCBrZXkgbm90IGZvdW5kIGZvciBncm91cCBtZXNzYWdlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVjcnlwdGVkS2V5cyA9IGF3YWl0IHRoaXMuZGVjcnlwdEFjY2Vzc0dyb3VwS2V5UGFpcihcbiAgICAgIGFjY2Vzc0dyb3VwLkFjY2Vzc0dyb3VwTWVtYmVyRW50cnlSZXNwb25zZS5FbmNyeXB0ZWRLZXlcbiAgICApO1xuXG4gICAgcmV0dXJuIGF3YWl0IGRlY3J5cHRDaGF0TWVzc2FnZShcbiAgICAgIGRlY3J5cHRlZEtleXMuc2VlZEhleCxcbiAgICAgIG1lc3NhZ2UuU2VuZGVySW5mby5BY2Nlc3NHcm91cFB1YmxpY0tleUJhc2U1OENoZWNrLFxuICAgICAgbWVzc2FnZS5NZXNzYWdlSW5mby5FbmNyeXB0ZWRUZXh0XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgI2RlY3J5cHRETShcbiAgICB1c2VyUHVibGljS2V5QmFzZTU4Q2hlY2s6IHN0cmluZyxcbiAgICBwcml2YXRlS2V5SGV4OiBzdHJpbmcsXG4gICAgbWVzc2FnZTogTmV3TWVzc2FnZUVudHJ5UmVzcG9uc2UsXG4gICAgaXNTZW5kZXI6IGJvb2xlYW5cbiAgKSB7XG4gICAgY29uc3QgYWNjZXNzR3JvdXBJbmZvID0gaXNTZW5kZXJcbiAgICAgID8gbWVzc2FnZS5TZW5kZXJJbmZvXG4gICAgICA6IG1lc3NhZ2UuUmVjaXBpZW50SW5mbztcblxuICAgIGlmIChcbiAgICAgIG1lc3NhZ2U/Lk1lc3NhZ2VJbmZvPy5FeHRyYURhdGEgJiZcbiAgICAgIG1lc3NhZ2UuTWVzc2FnZUluZm8uRXh0cmFEYXRhLnVuZW5jcnlwdGVkXG4gICAgKSB7XG4gICAgICByZXR1cm4gdW5lbmNyeXB0ZWRIZXhUb1BsYWluVGV4dChtZXNzYWdlLk1lc3NhZ2VJbmZvLkVuY3J5cHRlZFRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpc1JlY2lwaWVudCA9XG4gICAgICAgIG1lc3NhZ2UuUmVjaXBpZW50SW5mby5Pd25lclB1YmxpY0tleUJhc2U1OENoZWNrID09PVxuICAgICAgICAgIHVzZXJQdWJsaWNLZXlCYXNlNThDaGVjayAmJlxuICAgICAgICBtZXNzYWdlLlJlY2lwaWVudEluZm8uQWNjZXNzR3JvdXBLZXlOYW1lID09PVxuICAgICAgICAgIGFjY2Vzc0dyb3VwSW5mby5BY2Nlc3NHcm91cEtleU5hbWU7XG5cbiAgICAgIGNvbnN0IHB1YmxpY0RlY3J5cHRpb25LZXkgPSBpc1JlY2lwaWVudFxuICAgICAgICA/IG1lc3NhZ2UuU2VuZGVySW5mby5BY2Nlc3NHcm91cFB1YmxpY0tleUJhc2U1OENoZWNrXG4gICAgICAgIDogbWVzc2FnZS5SZWNpcGllbnRJbmZvLkFjY2Vzc0dyb3VwUHVibGljS2V5QmFzZTU4Q2hlY2s7XG5cbiAgICAgIHJldHVybiBhd2FpdCBkZWNyeXB0Q2hhdE1lc3NhZ2UoXG4gICAgICAgIHByaXZhdGVLZXlIZXgsXG4gICAgICAgIHB1YmxpY0RlY3J5cHRpb25LZXksXG4gICAgICAgIG1lc3NhZ2UuTWVzc2FnZUluZm8uRW5jcnlwdGVkVGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgRGVTb0NvcmVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgdHlwZTogRVJST1JfVFlQRVM7XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCB0eXBlOiBFUlJPUl9UWVBFUywgb3JpZ2luYWxFcnJvcjogYW55ID0ge30pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9yaWdpbmFsRXJyb3IpO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5uYW1lID0gJ0RlU29Db3JlRXJyb3InO1xuICB9XG59XG5cbmNvbnN0IHVuZW5jcnlwdGVkSGV4VG9QbGFpblRleHQgPSAoaGV4OiBzdHJpbmcpID0+IHtcbiAgY29uc3QgYnl0ZXMgPSBlY1V0aWxzLmhleFRvQnl0ZXMoaGV4KTtcbiAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgcmV0dXJuIHRleHREZWNvZGVyLmRlY29kZShieXRlcyk7XG59O1xuIl19